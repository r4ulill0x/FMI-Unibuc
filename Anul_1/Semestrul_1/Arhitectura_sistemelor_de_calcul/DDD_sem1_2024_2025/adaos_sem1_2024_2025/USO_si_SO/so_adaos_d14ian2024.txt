1. Compilarea fisierelor C cu gcc, lucrul cu biblioteci:
========================================================


1.1. Utilizarea compilatorului gcc, compilare conditionata:
-----------------------------------------------------------

 Etapele compilarii (este o schema de principiu, fisierele intermediare
exista conceptual, nu apar neaparat ca atare):

   fis1.c ... fisn.c   (fisiere sursa C nepreprocesate)
    | fisiere header (.h) incluse in surse cu '#include'
    |  | preprocesare
    V  V
   fis1.i ... fisn.i   (fisiere sursa C preprocesate)
    | translatare in assembler
    V
   fis1.S ... fisn.S   (fisiere sursa assembler nepreprocesate)
    | preprocesare assembler
    V
   fis1.s ... fisn.s   (fisiere sursa assembler preprocesate)
    | compilare propriuzisa (asamblare)
    V
   fis1.o ... fisn.o  (fisiere obiect)
    | biblioteci
    |  |  linkeditare
    V  V
    fisier  (a.out)  (un singur fisier executabil)

 Fiecare fisier '.c', '.i', '.S', '.s' este procesat individual pana la
'.o', compilatorul nu cauta informatii necesare acestuia in alte fisiere
'.c', '.i', '.S', '.s', '.o'. De aceea, pentru a se compila la '.o',
fiecare sursa trebuie sa contina declaratiile obiectelor pe care le
foloseste dar care sunt definite in alta parte - header-ele functiilor,
declaratiile variabilelor cu 'extern'; acestea pot fi si importate la
preprocesare din fisiere header '.h'. Abia la linkeditare, fisierele
'.o' si bibliotecile sunt considerate impreuna.
 Unele biblioteci sunt luate in considerare automat (de exemplu,
biblioteca standard C), altele doar daca sunt specificate cu optiunea '-l';
bibliotecile specificate cu '-l' sunt cautate in directoarele predefinite
si in directoare specificate cu optiunea '-L' (a se vedea mai jos).

 Compilarea cu gcc:

   gcc   optiuni...   fisiere_intrare...

fisierele de intrare pot fi de mai multe tipuri, recunoscute dupa extensie,
si pentru fiecare compilarea va incepe de la etapa corespunzatoare tipului.

 Cateva otiuni uzuale:

 --version ==> afisaza versiunea instalata de gcc

 -o fisier ==> fisierul rezultat se va numi 'fisier' (altfel, s.n. 'a.out');

 -Wall ==> afisaza toate avertismentele uzuale (warning), nu doar pe cele mai
    importante;

 -g ==> insereaza informatii pentru debugging (ulterior, programul se poate
    depana cu 'gdb');

 -fsyntax-only ==> nu compileaza, doar verifica corectitudinea sintactica;

 -Onr ==> optimizeaza codul rezultat; 'nr' poate fi 0, 1, 2, 3 si indica
    nivelul de optimizare; cu cat 'nr' e mai mic, optimizarea e mai slaba;
    pentru nr = 0 nu se optimizeaza;

 -std=standard ==> precizeaza standardul limbajului (ex: -std=c99);

 -D name ==> predefineste macro-ul '#define nume 1';
 -D name= ==> predefineste macro-ul '#define nume' (valoare vida);
 -D name=definition ==> predefineste macro-ul '#define nume=definition';
    (daca 'definition' contine caractere speciale shell, ca sa putem folosi
    optiunea in linia de comanda, trebuie sa le despecializam);
 -U name ==> anuleaza orice definitie anterioara a lui 'nume',
    indiferent daca este built in sau furnizata printr-un '-D';

  optiunile '-D' si '-U' sunt procesate in ordinea aparitiei in linia de
  comanda si inainte de a efectua includerea fisierelor '#include';

 -include file ==> proceseaza fisierul 'file' ca si cand ar aparea
        #include "file"
    ca prima linie in fisierul sursa primar; fisierul este cautat intai in
    directorul curent al preprocesorului (nu in directorul care contine
    fisierul sursa principal) iar daca nu este gasit aici, este cautat in
    restul canalului de cautare pentru #include "..." ca de obicei;
    daca sunt prezente mai optiuni '-include', fisierele sunt incluse in
    ordinea aparitiei in linia de comanda;

  -Idir ==> ia in consideratie si directorul 'dir' pentru cautarea fisierelor
    incluse in surse cu '#include"..."' sau '#include<...>'; in linia de
    comanda gcc putem scrie mai multe specificari '-I' iar directoarele vor
    fi scanate inaintea celor standard si in ordinea specificarii;

  -lnume ==> ia in consideratie la linkeditare si biblioteca statica
    'libnume.a' sau partajata 'libnume.so' (deci adauga implicit prefixul
    'lib' si extensia '.a' sau '.so'), aflata in directoarele de cautare
    implicite sau specificate explicit cu '-L'; daca sunt gasite atat
    biblioteci statice cat si partajate, este preferata cea partajata, cu
    exceptia cazului cand am folosit si optiunea '-static';
   in linia de comanda gcc putem specifica mai multe biblioteci,
     fiecare avand cate un '-l';
   atentie: obiectele aflate intr-o biblioteca sunt vazute doar de
     entitatile aflate inaintea ei in linia de comanda gcc; de exemplu,
     daca se specifica 'foo.o -lz bar.o', se cauta in biblioteca 'z'
     dupa fisierul 'foo.o' dar inainte de 'bar.o' - astfel, daca 'bar.o'
     refera functii din 'z', aceste functii s-ar putea sa nu fie preluate;
   o solutie in cazul cand biblioteci sau fisiere obiect se refera reciproc
     este sa repetam unul dintre ele in lina de comanda: '-la -lb -la';

  -Ldir ==> ia in consideratie si directorul 'dir' pentru cautarea
     bibliotecilor specificate cu '-l'; in linia de comanda gcc putem scrie
     mai multe specificari '-L' iar directoarele vor fi scanate in ordinea
     specificarii;
   in principiu, un director specificat cu '-L' este folosesit doar la
     specificarile cu '-l' aflate dupa el in linia de comanda gcc.

 Compilarea se poate face doar pana la o etapa intermediara, folosind
una din optiunile:

 -c ==> se opreste inainte de linkeditare; produce fisierele '.o';

 -S ==> se opreste inainte de asamblare; produce fisierele '.s';

 -E ==> se opreste dupa prima etapa, de preprocesare; rezultatul (cod sursa
     preprocesat) este trimis spre stdout (se poate redirecta spre un fisier
     adaugand la sfarsitul liniei de comanda '> fisier');

de fiecare data, fisierele de intrare ce nu necesita parcurgerea etapelor
efectuate (deoarece sunt necesare abia la etape ulterioare, de exemplu
fisierele de intrare .o) sunt ignorate.

In toate cazurile, la finalul compilarii nu raman si fisierele intermediare
(dar se poate cere si salvarea fisierelor intermediare, adaugand optiunea
'–save-temps').

Exemplul 1:
===========

$ls
f.c
$cat f.c
#include <stdio.h>
#include <math.h>
int main() {
  int x = nr;
  printf("%lf %d\n", sqrt(x), errno);
  return 0;
}

$gcc -o prog f.c -D nr=2 -include errno.h -lm
$ls
f.c  prog
$./prog
1.414214 0
$gcc -o prog f.c -D nr=2 -include errno.h -lm -save-temps
$ls
f.c  f.i  f.o  f.s  prog

Comentarii:
- prin '-D nr=2 -include errno.h' am facut ca programul sa fie compilat
 ca si cand ar fi continut '#define nr=2' si '#include <errno.h>'; fara
 aceste optiuni, s-ar fi semnalat eroare deoarece nu s-ar fi gasit o
 definitie/declaratie pentru 'nr', respectiv 'errno';
- am adaugat '-lm' deoarece biblioteca matematica 'libm.a' nu este luata
 in considerare implicit la linkeditare (chiar daca am scris in program
 '#include <math.h>');
- daca scriam '-lm' inainte de 'f.c', se semnala eroare la linkeditare,
 deoarece 'f.c' solicita 'sqrt()' care este definit in 'libm.a' iar in
 linia de comanda gcc solicitantul trebuie scris inainte de solicitat;
- observam ca cu '-save-temps' sunt pastrate si fisierele intermediare.

Exemplul 2 (afisarea reprezentarea binara a unui numar natural):
================================================================

$ls
f.c  u.c  z.c
$cat f.c
#include <stdio.h>
void z(unsigned);
void u(unsigned);
int main() {
  unsigned x;
  scanf("%u", &x);
  z(x); u(x);
  printf("\n");
  return 0;
}

$cat u.c
#include <stdio.h>
void z(unsigned);
void u(unsigned x) {
  if(x % 2 != 1) return;
  if(x / 2 != 0) {z(x / 2); u(x / 2);}
  putchar('1');
}

$cat z.c
#include <stdio.h>
void u(unsigned);
void z(unsigned x) {
  if(x % 2 != 0) return;
  if(x / 2 != 0) {z(x / 2); u(x / 2);}
  putchar('0');
}

$gcc -c z.c u.c
$ls
f.c  u.c  u.o  z.c  z.o
$gcc -o prog f.c z.o u.o
$./prog
26
11010

Comentarii:
- mai intai am transformat separat fisierele sursa cu functiile 'z.c', 'u.c'
 in fisiere obiect 'gcc -c z.c u.c', apoi al creat programul 'prog' din ele
 'gcc -o prog f.c z.o u.o'; pe disc au ramas si fisierul 'prog' si fisierele
 'z.o', 'u.o';
  daca ulterior modificam 'z.c', 'u.c' si recompilam programul cu comanda
 'gcc -o prog f.c z.o u.o', nu vor fi sesizate modificarile deoarece nu se
 recompileaza automat si 'z.c', 'u.c' si vor fi folosite vechile 'z.o u.o';
  mai notam ca desi 'z.o' si 'u.o' se refera reciproc, nu a contat ordinea
 in care am scris in linia de comanda 'f.c', 'z.o', 'u.c'; ordinea conteaza
 doar la specificarea bibliotecilor cu '-l';
- puteam compila programul cu o sigura comanda 'gcc -o prog z.c u.c f.c' si
 atunci nu ar fi ramas pe disc decat 'prog' (nu si 'z.o', 'u.o'), dar daca
 ulterior am fi modificat 'z.c', 'u.c', recompilarea lui 'prog' cu aceeasi
 comanda ar fi sesizat modificarile (de fiecare data s-ar fi recompilat toate
 fisierele 'f.c', 'z.c', 'u.c').

 Pentru o organizare eficienta a codului, este util sa cream fisiere header
'.h' cu declaratiile entitatilor definite si fisiere de implementare '.c'
cu definitiile acestora - ele vor include fisierele header. Atunci, pentru
a preveni incluziunile multiple, este util sa protejam continutul fisierelor
incluse punandu-l intre directive '#ifndef NUME', '#define NUME' si '#endif'
(unde 'NUME' este ales sa indice unic pentru fisierul respectiv).

Exemplu 3:
==========

Varianta incorecta (in 'f.c' ajung doua definitii 'int a'):

$cat a.h
int a = 10;

$cat b.h
#include "a.h"
int b = 20;

$cat f.c
#include "a.h"
#include "b.h"
int main(){
  int x = a + b;
  return 0;
}

$gcc -o prog f.c
 ...
a.h:1:5: error: redefinition of ‘a’
    1 | int a = 10;
 ...
$gcc -E f.c
# 1 "f.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 31 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 32 "<command-line>" 2
# 1 "f.c"
# 1 "a.h" 1
int a = 10;
# 2 "f.c" 2
# 1 "b.h" 1
# 1 "a.h" 1
int a = 10;
# 2 "b.h" 2
int b = 20;
# 3 "f.c" 2
int main(){
  int x = a + b;
  return 0;
}

Varianta corecta (doar prima tentativa de a include 'a.h' in 'f.c'
  reuseste):

$cat a.h
#ifndef __A_H
#define __A_H
int a = 10;
#endif

$cat b.h
#ifndef __B_H
#define __B_H
#include "a.h"
int b = 20;
#endif

$cat f.c
#include "a.h"
#include "b.h"
int main(){
  int x = a + b;
  return 0;
}

$gcc -o prog f.c
$gcc -E f.c
# 1 "f.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 31 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 32 "<command-line>" 2
# 1 "f.c"
# 1 "a.h" 1


int a = 10;
# 2 "f.c" 2
# 1 "b.h" 1



int b = 20;
# 3 "f.c" 2
int main(){
  int x = a + b;
  return 0;
}


1.2. Biblioteci:
----------------

 O biblioteca este un fisier continand o colectie de obiecte compilate ce
pot participa la o linkeditare.
 Exista biblioteci predefinite (situate de regula in directoarele '/lib',
'/usr/lib' si '/usr/local/lib') - la compilarea cu gcc unele sunt luate in
considerare implicit, altele doar daca sunt invocate in linia de comanda cu
'-l' (de exemplu, biblioteca de functii matematice 'libm.a').
 Se pot crea biblioteci utilizator, care se pot invoca in linia de comanda
gcc cu '-l'; in cazul in care bibliotecile nu se afla in directoarele
standard, directoarele in care se afla trebuie precizate cu '-L'.

 Bibliotecile pot fi cu legare statica (static library) sau dinamica
(shared library).
 Cand cream cu gcc un produs (de exemplu un executabil) si invocam o
biblioteca cu legare statica, continutul cerut din aceasta este inclus in
produs. Astfel produsul poate fi folosit (de exemplu rulat) ulterior
independent de prezenta in sistem a bibliotecii, deoarece contine in el tot
ce-i trebuie, dar are o dimensiune mai mare.
 Cand cream cu gcc un produs (de exemplu un executabil) si invocam o
biblioteca cu legare dinamica, continutul cerut din aceasta nu este inclus
in produs, dar produsul este creat a.i. sa poata apela continutul
bibliotecii la momentul folosirii (de exemplu rularii). Astfel, produsul nu
poate fi folosit (de exemplu rulat) ulterior decat daca in sistem este
incarcata si biblioteca, iar continutul cerut din aceasta este utilizat
direct de acolo. Produsul, insa, are dimensiunea mai mica (nu include in el
continutul folosit din biblioteca), In plus, daca mai multe produse folosesc
aceeasi biblioteca cu legare dinamica, aceasta este incarcata intr-un singur
exemplar in memorie (folosit in comun).
 Bibliotecile cu legare dinamica sunt analoage dll-urilor din Windows.


1.2.1. Biblioteci cu legare statica:
------------------------------------

 In general, o biblioteca cu legare statica este o arhiva '.a' (creata cu
utilitarul de arhivare 'ar') de obiecte '.o'. Explicam lucrul cu asemenea
biblioteci direct pe un exemplu:

Exemplul 4:
===========

Presupunem ca avem in directorul curent fisierele:

fa.h:
   #ifndef __FA_H
   #define __FA_H
   void a();
   #endif

fa.c:
   #include<stdio.h>
   void a(){printf("a ");}

fb.h:
   #ifndef __FB_H
   #define __FB_H
   void b();
   #endif

fb.c:
   #include<stdio.h>
   void b(){printf("b ");}

fc.h:
   #ifndef __FC_H
   #define __FC_H
   void c();
   #endif

fc.c:
   #include<stdio.h>
   void c(){printf("c ");}

fd.h:
   #ifndef __FD_H
   #define __FD_H
   void d();
   #endif

fd.c:
   #include<stdio.h>
   #include"fa.h"
   #include"fb.h"
   #include"fd.h"
   void d(){a(); b(); printf("d ");}

fe.h:
   #ifndef __FE_H
   #define __FE_H
   void e();
   #endif

fe.c:
   #include<stdio.h>
   #include"fe.h"
   void e(){printf("e ");}

prog.c:
   #include<stdio.h>
   #include"fd.h"
   #include"fe.h"
   int main(){
     d(); printf("\n");
     e(); printf("\n");
     return 0;
   }

Aceste fisiere depind unele de altele dupa schema:

      fa, fb ---> fd ---> prog <--- fe
          fc

 fisierele 'fa', 'fb', 'fc', 'fd', 'fe' contin functii ce afisaza respectiv
 'a', 'b', 'c', 'a b d', 'e'; programul 'prog' apeleaza functiile 'd()' si
 'e()' pentru a afisa 'a b d' si respectiv 'e';

Cu comanda urmatoare se compileaza fisierele sursa 'fa.c', 'fb.c', 'fc.c' si
 'fd.c', obtinand fisierele obiect 'fa.o', 'fb.o', 'fc.o' si 'fd.o':

$ gcc -c fa.c fb.c fc.c fd.c

Apoi, cu comanda urmatoare se creaza biblioteca cu legare statica 'libabc.a'
 din continuturile reunite ale fisierelor obiect 'fa.o', 'fb.o', 'fc.o':

$ ar rcs libabc.a fa.o fb.o fc.o

In aceasta comanda, 'ar' este numele unui program de arhivare (o biblioteca
 '.a' este practic o arhiva facuta cu 'ar' de obiecte '.o'), 'libabc.a' este
 numele arhivei iar 'fa.o fb.o fc.o' fisierele obiect de intrare (care vor
 fi cuprinse in arhiva); 'rcs' sunt optiuni care spun lui 'ar' sa insereze
 fisierele de intrare ca membri in arhiva suprascriind eventual versiunile
 lor mai vechi deja existente in ea ('r'), sa nu mai afiseze un avertisment
 daca arhiva se creaza ca arhiva noua ('c') si sa adauge (sau sa actualizeze,
 daca exista deja) un index arhivei ('s') - prezenta indexului va accelera
 legarea la biblioteca si va permite rutinelor din biblioteca sa se apeleze
 unele pe altele indiferent de ordinea in care sunt amplasate in arhiva.

Apoi cu urmatoarea comanda cream fisierul executabil 'prog':

$ gcc -o prog -L. fd.o -labc fe.c prog.c

Aceasta comanda spune ca se creaza executabilul 'prog' compiland mai intai
 pana la fisier obiect sursele 'fe.c' si 'prog.c' si apoi linkeditand
 obiectele din biblioteca 'libabc.a', obiectul 'fd.o' si obiectele provenite
 din sursele 'fe.c' si 'prog.c'; optiunea '-labc' face compilatorul sa
 considere implicit prefixul 'lib' si extensia '.a' (adica biblioteca
 'libabc.a').
Daca schimbam ordinea si scriam 'gcc -o prog -L. -labc fd.o fe.c prog.c'
 se semnala eroare, deoarece continutul lui 'fd.o' invoca continutul
 bibliotecii 'libabc.a' (anume functia 'd()' din 'fd.o' apeleaza functiile
 'a()' si 'b()' din 'libabc.a'), iar 'fd.o' este scris dupa '-labc' in linia
 de comanda gcc.
In absenta lui '-L.' (care adauga directorul curent '.' la lista
 directoarelor in care se cauta bibliotecile la compilarea curenta) se
 semnaleaza eroare, deoarece gcc nu stie implicit sa caute bibliotecile si
 in directorul curent.

Apoi rulam programul:

$ ./prog
a b d
e

Exemplul 5: reluam programul din exemplul 2, cu o alta organizare a codului:
===========

$ls
f.c  headers  u.c  z.c
$ls headers
u.h  z.h
$cat headers/z.h
#ifndef __Z_H
#define __Z_H
void z(unsigned);
#endif

$cat headers/u.h
#ifndef __U_H
#define __U_H
void u(unsigned);
#endif

$cat z.c
#include <stdio.h>
#include "z.h"
#include "u.h"
void z(unsigned x) {
  if(x % 2 != 0) return;
  if(x / 2 != 0) {z(x / 2); u(x / 2);}
  putchar('0');
}

$cat u.c
#include <stdio.h>
#include "z.h"
#include "u.h"
void u(unsigned x) {
  if(x % 2 != 1) return;
  if(x / 2 != 0) {z(x / 2); u(x / 2);}
  putchar('1');
}

$cat f.c
#include <stdio.h>
#include "z.h"
#include "u.h"
int main() {
  unsigned x;
  scanf("%u", &x);
  z(x); u(x);
  printf("\n");
  return 0;
}

$gcc -c -Iheaders z.c u.c
$ls
f.c  headers  u.c  u.o  z.c  z.o
$ar rcs libzu.a z.o u.o
$ls
f.c  headers  libzu.a  u.c  u.o  z.c  z.o
$gcc -o prog -Iheaders -L. f.c -lzu
$ls
f.c  headers  libzu.a  prog  u.c  u.o  z.c  z.o
$./prog
26
11010

Comentarii:
- am avut nevoie de '-Iheaders', deoarece fisierele header sunt in
 subdirectorul 'headers' iar includerile '#include"..."' le-ar fi cautat
 in directorul curent;
- desi fisierele obiect 'z.o' si 'u.o' se refera reciproc (functiile 'z()'
 si 'u()' se apeleaza una pe alta), nu sunt probleme atunci cand sunt
 incluse in arhiva 'libzu.a', deoarece optiunea 's' a lui 'ar' a generat
 indexul, care permite rutinelor din biblioteca sa se apeleze unele pe
 altele indiferent de ordinea in care sunt amplasate in arhiva.


1.2.2. Biblioteci cu legare dinamica:
-------------------------------------

 O biblioteca cu legare dinamica (shared object) are un nume real
('real name', numele de fisier) si un nume special (il vom numi 'soname').
 Numele special (soname) este de forma 'libnume.so.nr' (are prefixul 'lib',
apoi un nume, apoi extensia '.so', apoi un numar de versiune '.nr' care se
schimba de fiecare data cand se schimba interfata (compatibilitatea cu
biblioteca respectiva)); exceptie: bibliotecile C de nivelul cel mai jos
nu incep cu 'lib'. El poate figura intr-un director si se poate specifica
complet adaugand in fata calea catre directorul respectiv. Ca implementare,
soname-ul este de fapt o legatura simbolica catre numele real.
 Numele real (numele fisierului ce contine codul propriuzis) este format
din soname, dupa care urmeaza un alt '.nr' (un numar minor de versiune),
apoi eventual un alt '.nr' (un numar de release). Deci numele real este de
forma 'libnume.so.nr1.nr2' sau 'libnume.so.nr1.nr2.nr3', unde
'libnume.so.nr1' este so-name-ul.
 De asemenea, bibliotecile cu legare dinamica mai au un nume
('linker name'), care este folosit in liniile de comanda gcc atunci cand
sunt invocate; acesta este de fapt soname-ul fara numerele de versiune si
release, de exemplu 'libnume.so' (care se subintelege cand specificam
optiunea '-lnume').

 Concret, o biblioteca cu legare dinamica este creata (folosind, de exemplu,
gcc) cu un realname dar in interiorul ei se codeaza soname-ul.
 Apoi biblioteca trebuie instalata intr-un director standard (de regula
'/usr/local/lib') cu utilitarul 'ldconfig' (o comanda de forma
'ldconfig  -n  directorul_cu_biblioteci_cu_legare_dinamica'), care il
creaza pe soname ca legatura simbolica la realname.
 Totodata se creaza si linkername ca legatura simbolica la soname sau
la realname-ul unei versiuni date explicit (de exemplu o versiune mai
veche).
 In final, liniile de comanda gcc vor invoca biblioteca prin linkername.
Compilatorul va accesa fisierul-biblioteca, va citi din el numele soname
si il va inregistra in programul executabil creat; programul isi va declara,
astfel, dependenta de biblioteca folosind soname, nu linkername sau
realname. In progarmul executabil creat in format ELF, va exista o
sectiune '.interp' care va contine specificatorul unui dynamic linker, el
insusi un shared object ('ld-linux.so' pe sistemele Linux) si o sectiunea
NEEDED care va contine soname-ul bibliotecii inregistrate (e copiat din
biblioteca).

 Cand un program compilat ca mai sus este lansat ulterior in executie (de
exemplu, dam comanda shell './program' iar shell-ul incarca si lanseaza
programul cu apelul 'exec()', care invoca un loader din sistem), loader-ul
din sistem descopera in executabilul in format ELF al programului sectiunea
'.interp' care specifica dynamic linker-ul, il incarca pe acesta in memorie
(daca nu era deja incarcat) si il lanseaza pe acesta; dynamic linker-ul
incarca in memorie (daca nu era deja incarcata) biblioteca inregistrata
in executabil prin soname (vom vedea ca numele respectiv il cauta
intr-o lista de directoare inregistrate in variabila de environment
'LD_LIBRARY_PATH'), finalizeaza legaturile (referirile) in memorie intre
codul din program si codul bibliotecii, apoi transfera controlul executiei
catre program.

 Procedand ca mai sus, este posibila gestionarea eficienta a mai multor
versiuni ale aceleiasi biblioteci. Programele vor rula mereu cu cea mai
recenta versiune, iar compilarile pot fi setate sa foloseasca versiuni
fixate (eventual mai vechi).
 Intr-adevar, cand se instaleaza o noua versiune a bibliotecii, compatibila
cu precedenta, va diferi realname prin numarul minor de versiune si cel
de release, dar nu va diferi 'somane'; legaturile simbolice linkername si
soname vor fi redirectionate catre noul realname, dar in biblioteca si in
executabile va ramane scris acelasi soname.

 De exemplu un soname complet calificat (cu cale) poate fi:

   /usr/lib/libreadline.so.3

pe el ldconfig il poate crea ca legatura simbolica spre un realname gen:

  /usr/lib/libreadline.so.3.0

de asemenea, va fi si un linkername:

  /usr/lib/libreadline.so

care poate fi o legatura simbolica la /usr/lib/libreadline.so.3

  Putem inspecta un executabil spre a vedea ce biblioteci dinamice sunt
inregistrate in el folosind comanda 'readelf', de exemplu:

$readelf -d /bin/ls | grep 'NEEDED'
 0x0000000000000001 (NEEDED)             Shared library: [libselinux.so.1]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]

Comentariu: comanda 'readelf' afisaza informatii despre un
 executabil in format ELF; aici, este vorba despre executabilul
 comenzii 'ls': '/bin/ls';  cu optiunea 'd', afisaza continutul
 sectiunii dinamice a executabilului, daca exista una; output-ul
 a fost filtrat prin 'grep' a.i. sa pastram doar liniile care
 mentioneaza sectiunea 'NEEDED'.

 Bibliotecile dinamice cerute de un executabil pot depinde de alte
biblioteci. Putem repeta comanda 'readelf' pe oricare din bibliotecile
respective, dar ne trebuie realname-ul ei; acesta se poate afla cu
comanda 'locate', de exemplu:

$locate libc.so.6
/usr/lib/i386-linux-gnu/libc.so.6
/usr/lib/x86_64-linux-gnu/libc.so.6
 ...

Comentariu: comanda 'locate' exploreaza o baza de date intretinuta cu
 comanda 'updatedb' pentru a gasi toate aparitiile numelui dat ca argument
 ca fisier in sistem; inspecteaza doar baza de date, nu si daca fisierele
 respective chiar mai exista.

 In continuare, putem da, de exemplu:

$readelf -d /usr/lib/x86_64-linux-gnu/libc.so.6 | grep 'NEEDED'
 0x0000000000000001 (NEEDED)             Shared library: [ld-linux-x86-64.so.2]

 Pentru a afisa dependintele de biblioteci dinamice ale unui program,
putem folosi si comanda 'ldd fisier_executabil', de exemplu:

$ldd /bin/ls
	linux-vdso.so.1 (0x00007fff8bb19000)
	libselinux.so.1 => /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f0df5072000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f0df4e80000)
	libpcre2-8.so.0 => /lib/x86_64-linux-gnu/libpcre2-8.so.0 (0x00007f0df4def000)
	libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f0df4de9000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f0df50e4000)
	libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f0df4dc6000)

Atentie insa sa nu aplicam 'ldd' asupra unor programe in care nu
 avem incredere, deoarece comanda de mai sus executa efectiv fisierul
 'fisier_executabil'.

 Putem cere explicit din codul utilizator incarcarea si legarea la runtime
a programului cu o biblioteca dinamica folosind apelul 'dlopen()' (vom vedea
mai tarziu).

 Daca vrem sa utilizam niste biblioteci cu legare dinamica si nu vrem (sau
n-avem drept) sa le instalam in directoarele standard, le putem pune intr-un
director propriu, dar atunci va trebui sa memoram calea catre directorul
respectiv intr-o variabila de environment exportabila a shell-ului
(interpretorului de comenzi); in acest scop sunt folosite variabilele de
environment urmatoare, care trebuie setate cu un sir de cai separate prin
':':

LD_LIBRARY_PATH
  directoarele in care sunt cautate bibliotecile inaintea directoarelor
  standard;

LD_PRELOAD
  directoarele ce contin biblioteci cu legare dinamica cu functii care
  prevaleaza (override) in fata celor standard.

setarea acestor variabile de environment va face posibila legarea dinamica
automata a programelor la biblioteci la momentul executiei (dynamic linker-ul
'ld-linux.so' consulta aceste variabile pentru a afla directoarele in care
trebuie sa caute bibliotecile specificate in programul executabil prin
soname); nu va influenta insa liniile de comanda gcc, unde va trebui in
continuare sa specificam cu '-L' directorul in care se afla bibliotecile
si cu '-l' bibliotecile (indicate prin linkername).

 Pentru a crea o biblioteca cu legare dinamica, intai trebuie sa cream
niste fisiere obiect '.o' pe care sa le punem in ea. In acest scop vom
folosi gcc, cu optiunea '-c' (am vazut deja), dar si cu optiunea '-fPIC'
(care instruieste gcc sa creeze 'position independent code', o cerinta
obligatorie in cazul bibliotecilor cu legare dinamica).

 Apoi se creaza biblioteca cu legare dinamica folosind gcc cu optiunile:
   -shared
       pentru a crea o entitate ce se poate lega dinamic la alte
        entitati;
   -Wl,-soname,my_soname
       pentru a specifica soname-ul (sub forma acelui 'my_soname');
        notam ca in toata sintagma '-Wl,-soname,my_soname' nu exista
        blank-uri; daca totusi vrem sa avem blank-uri in soname, le
        despecializam cu '\'; acest nume este scris de compilator in
        biblioteca; nu este creat acum si ca legatura simbolica - aceasta
        o putem face separat, mai tarziu;
   -o numele_real
       pentru a preciza numele real al bibliotecii (conform conventiilor
        de mai sus); optiunea '-o' a mai fost discutata.
Evident, linia de comanda gcc va mai contine fisierele obiect '.o' cuprinse
in biblioteca si eventual alte biblioteci folosite la linkeditare (cu '-L'
si '-l'); de multe ori se foloseste biblioteca standard C ('libc.so.N', unde
N este >= 6), motiv pentru care se adauga la lina de comanda '-lc'.
Obs: 'man gcc' recomanda ca la crearea bibliotecii cu '-shared' sa se
adauge aceleasi optiuni de compilare ca la obiectele componente, in
particular '-fPIC'.

 Daca vrem sa implementam si dependente inverse, adica biblioteca sa poata
invoca simboluri nedefinite in ea ci in programele care o folosesc, vom
include in linia de comanda gcc a programelor respective si optiunea
urmatoare (fara blank-uri in ea):
   -Wl,-export-dynamic
     adauga la tabela de simboluri dinamice a programului toate simbolurile;
     tabela este setul de simboluri care sunt vizibile de la obiecte dinamice
     in timpul rularii; fara aceasta optiune, tabela va contine in mod normal
     doar acele simboluri la care face referire vreunul dintre obiectele
     dinamice mentionate la linkeditare.
 De exemplu, vom folosi optiunea '-Wl,-export-dynamic' la compilarea unui
program care foloseste biblioteca ca un plugin (programul isi va avea
simbolurile accesibile dinamic si astfel biblioteca va putea vedea
simbolurile definite in program).
 Optiunea '-Wl,-export-dynamic' nu este relevanta la compilarea bibliotecii
cu legare dinamica propriuzise, deoarece in cazul ei este implicita.

 Pentru a instala biblioteca, daca nu dorim (sau n-avem dreptul) sa o
instalam intr-un director standard, efectuam urmatorii pasi:
- punem biblioteca intr-un director oarecare, cu realname;
- ii cream manual soname-ul si linkername-ul, ca legaturi simbolice, cu
 comanda 'ln';
- pentru a putea linkedita cu ea, vom mentiona in linia de comanda gcc
 directorul linkername-lui cu '-L' si biblioteca propriuzisa cu '-l' (ca
 si la bibliotecile cu legare statica);
- pentru a putea rula programe legate la ea, adaugam directorul soname-lui
 la variabila de environment 'LD_LIBRARY_PATH' cu comanda urmatoare
 ('director' este calea catre directorul respectiv):

 export LD_LIBRARY_PATH=director:$LD_LIBRARY_PATH

 dupa care putem rula obisnuit programele care folosesc biblioteca.

Exemplul 6:
==========

Consideram aceleasi fisiere de inceput ca in exemplul 4.
Reamintim ca aceste fisiere depind unele de altele dupa schema:

      fa, fb ---> fd ---> prog <--- fe
          fc

 fisierele 'fa', 'fb', 'fc', 'fd', 'fe' contin functii ce afisaza respectiv
 'a', 'b', 'c', 'a b d', 'e'; programul 'prog' apeleaza functiile 'd()' si
 'e()' pentru a afisa 'a b d' si respectiv 'e'.

 Vedem aceste fisiere:

$ls -1F
fa.c
fa.h
fb.c
fb.h
fc.c
fc.h
fd.c
fd.h
fe.c
fe.h
prog.c

(optiunea '-1' face sa se afiseze fiecare nume pe cate o linie iar '-F'
face sa se afiseze caractere suplimentare, care nu fac parte din nume, dar
care dau indicatii despre tipul si drepturile fisierului - aici nu e nevoie).

 Cream directoarele 'dirr', 'dirs', 'dirl' (subdirectoare al directorului
curent) in care vom pune respectiv bibliotecile cu legare dinamica
(realname), soname-urile si linkername-urile (in principiu poate fi si
acelasi director sau chiar directorul curent):

$mkdir dirr
$mkdir dirs
$mkdir dirl

 Vedem continutul directorului curent:

$ls -1F
dirl/
dirr/
dirs/
fa.c
fa.h
fb.c
fb.h
fc.c
fc.h
fd.c
fd.h
fe.c
fe.h
prog.c

(optiunea '-F' face sa se afiseze numele directoarelor urmat de '/', dar
 acest caracter nu face parte din nume).

 Compilam la stadiul de obiect fisierele (independente) 'fa' si 'fb', in
vederea reunirii lor intr-o biblioteca cu legare dinamica (deci cu '-fPIC'):

$gcc -fPIC -c fa.c fb.c

apoi vedem fisierele obiect rezultate:

$ls *.o
fa.o  fb.o

 Reunim fisierele obiect 'fa.o' si 'fb.o' intr-o biblioteca cu legare
dinamica aflata ca fisier (realname-ul) in directorul 'dirr':

$gcc -fPIC -shared -Wl,-soname,libab.so.1 -o dirr/libab.so.1.1 fa.o fb.o

aceasta comanda creaza biblioteca cu legare dinamica avand soname-ul
'libab.so.1' scris in biblioteca si numele real 'libab.so.1.1' aflat
in directorul 'dirr' (conform specificarii '-o dirr/libab.so.1.1').
Biblioteca contine corpurile functiilor 'a()' si 'b()'.

 Vedem fisierele nou aparute:

$ls -1F
dirl/
dirr/
dirs/
fa.c
fa.h
fa.o
fb.c
fb.h
fb.o
fc.c
fc.h
fd.c
fd.h
fe.c
fe.h
prog.c
$ls -1F dirr
libab.so.1.1*

constatam ca practic s-a creat doar fisierul fizic al bibliotecii avand
realname-ul 'libab.so.1.1' (soname-ul 'libab.so.1' e codificat in interiorul
acestui fisier); caracterul '*' este afisat ca urmare a folosirii optiunii
'-F', el nu face parte din nume.

 Cream manual cele doua legaturi simbolice soname si linkername,
in cele doua directoare create special pentru asta, folosind comanda
'ln -s sursa destinatie', care creaza fisierul 'destinatie' ca o
legatura simbolica la fisierul 'sursa' (fara '-s' s-ar crea o legatura
fizica, care este doar un nou nume pentru fisierul 'sursa', nu un fisier
de sine statator):

$ln -s $PWD/dirr/libab.so.1.1 dirs/libab.so.1
$ln -s $PWD/dirs/libab.so.1 dirl/libab.so

Notam prezenta lui '$PWD' la inceputul caii sursa; 'PWD' este o variabila de
environment a shell-ului setata automat cu calea absoluta catre directorul
curent; in orice linie de comanda shell constructia '$PWD' se expandeaza la
continutul sau (calea absoluta catre directorul curent); astfel, in comenzile
'ln -s' sursa este specificata cu cale absoluta - fara o asemenea specificare
(cu cale absoluta) legatura simbolica rezultata s-ar putea sa nu fie
functionala.

 Observam fisierele nou create:

$ls -1F
dirl/
dirr/
dirs/
fa.c
fa.h
fa.o
fb.c
fb.h
fb.o
fc.c
fc.h
fd.c
fd.h
fe.c
fe.h
prog.c
$ls -1F dirr
libab.so.1.1*
$ls -1F dirs
libab.so.1@
$ls -1F dirl
libab.so@

'libab.so' este linkername-ul iar 'libab.so.1' este soname-ul; caracterul
'@' este adaugat de 'ls' la afisare (datorita optiunii '-F') pentru a marca
ca e vorba de un fisier legatura simbolica, el nu face parte din nume.

 Cream acum intr-o maniera similara o noua biblioteca cu legare dinamica ce
contine functia 'd()'; intai cream fisierul obiect ce va fi introdus in
biblioteca:

$gcc -fPIC -c fd.c

Vedem ca a aparut:

$ls *.o
fa.o  fb.o  fd.o

 Cream acum biblioteca cu legare dinamica:

$gcc -fPIC -shared -Wl,-soname,libd.so.1 -o dirr/libd.so.1.1 -L./dirl -lab fd.o

 Practic am creat doar fisierul fizic (cu realname) 'libd.so.1.1' din
directorul 'dirr', soname-ul 'libd.so.1' este scris in biblioteca;
intrucat noua biblioteca depinde de 'libab' (deoarece functia 'd()' din
'fd.o' apeleaza functiile 'a()' si 'b()' din 'libab'), am precizat in
linia de comanda calea catre directorul unde se afla linkername-ul ei
folosind '-L./dirl' si apoi pe ea insasi cu '-lab'.
 Noua biblioteca 'libd' contine efectiv doar corpul functiei 'd()' (preluat
din 'fd.o') si doar refera (nu contine) functiile 'a()' si 'b()' din 'libab'.
Deci, pentru a putea rula un program linkeditat dinamic cu 'libd.so' trebuie
sa fie prezente in sistem (si incarcate in memorie) atat 'libd.so' cat si
'libab.so', dar nu mai e nevoie sa fie prezent 'fd.o' (continutul necesar din
el a fost copiat deja 'libd').

 Cream si acum manual legaturile simbolice soname si linkername ale noii
biblioteci:

$ln -s $PWD/dirr/libd.so.1.1 dirs/libd.so.1
$ln -s $PWD/dirs/libd.so.1 dirl/libd.so

 Observam fisierele nou create:

$ls -1F
dirl/
dirr/
dirs/
fa.c
fa.h
fa.o
fb.c
fb.h
fb.o
fc.c
fc.h
fd.c
fd.h
fd.o
fe.c
fe.h
prog.c
$ls -1F dirr
libab.so.1.1*
libd.so.1.1*
$ls -1F dirs
libab.so.1@
libd.so.1@
$ls -1F dirl
libab.so@
libd.so@

Observam ca bibliotecile cu legare dinamica sunt create cu dreptul de
executie setat (caracterul '*').

 Cream acum dupa tehnica deja cunoscuta o biblioteca cu legare statica
continand functiile 'c()' si 'e()'; intai compilam fisierele (independente)
'fc.c' si 'fe.c':

$gcc -c fc.c fe.c

 Vedem cele doua fisiere obiect 'fc.o' si 'fe.o' nou aparute:

$ls *.o
fa.o  fb.o  fc.o  fd.o  fe.o

 Acum cream biblioteca, numita 'libce.a':

$ar rcs libce.a fc.o fe.o

apoi vedem fisierul '.a' rezultat:

$ls *.a
libce.a

acest fisier contine corpurile functiilor 'c()' si 'e()'.

 Sa cream un executabil 'prog1' ce foloseste 'libce.a' si 'libd.so' (si
implicit 'libab.so'):

$gcc -o prog1 -L./dirl -L. prog.c -ld -lab -lce

 Executabilul 'prog1' se obtine din 'prog.c' (care se si compileaza cu
ocazia aceasta, dar fisierul obiect nu ramane efectiv pe disc), 'libce',
'libd' si 'libab' (de unde isi ia functiile); in executabil este inclus
efectiv doar corpul functiilor 'main()' (provenit din 'prog.c') si 'e()'
(provenit din biblioteca cu legare statica 'libce'), functia 'd()' fiind
doar referita (nu inclusa) intrucat se afla intr-o biblioteca cu legare
dinamica; intrucat bibliotecile 'libab' si 'libd' se afla in directorul
'dirl' (linkername-ul) iar biblioteca 'libce' se afla in directorul curent
'.', cele doua directoare de cautare trebuie specificate in linia de comanda
gcc cu '-L./dirl', respectiv '-L.'; bibliotecile prorpiuzise (linkername-ul)
sunt specificate cu '-lab', '-ld', respectiv '-lce'.
 Avand in vedere ca in linia de comanda bibliotecile trebuie precizate
cu '-l' dupa codul care le solicita iar pentru noi ordinea
solicitant <-- solicitat este:
    prog <-- libd <-- libab
         <-- libc
o ordine corecta de scriere a lor in linia de comanda este
'prog.c -ld -lab -lc'; daca am fi scris '-lab -ld -lce', ar fi dat
eroare la linkeditare.

 Pentru a putea rula executabilul 'prog1', calea catre directorul 'dirs' ce
contine soname-ul bibliotecilor cu legare dinamica invocate de el trebuie
adaugat cu ':' la variabila de environment 'LD_LIBRARY_PATH', care trebuie
sa ramana exportabila (reamintim ca la rularea programului cu './prog',
loader-ul din sistem va inspecta executabilul ELF, va gasi in sectiunea
'.interp' dynamic linker-ul 'ld-linux.so' si il va lansa pe acesta, iar
acesta va gasi in sectiunea NEEDED soname-urile 'libab.so.1', 'libd.so.1', pe
care le va cauta ca nume in directoarele inregistrate in 'LD_LIBRARY_PATH');
in acest scop dam comanda:

$export LD_LIBRARY_PATH=$PWD/dirs:$LD_LIBRARY_PATH

(ca si mai inainte, constructiile de forma '$variabila' din linia de comanda
shell sunt expandate automat la valoarea curenta a lui 'variabila').

 Acum putem rula programul, obtinand:

$./prog1
a b d
e

 Sa verificam dependentele executabilului 'prog1':

$ldd prog1
	linux-vdso.so.1 (0x00007ffed8b9c000)
	libd.so.1 => /home/dragulici/.../work/dirs/libd.so.1 (0x00007f95bac88000)
	libab.so.1 => /home/dragulici/.../work/dirs/libab.so.1 (0x00007f95bac83000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f95baa71000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f95bac94000)

(observam ca depinde de 'libab' si 'libd'; 'libc' este biblioteca standard C).

Exemplul 7: biblioteca cu legare dinamica si dependente inverse:
===========

 Presupunem ca avem in directorul curent fisierele:

functii.h:
   #ifndef __FUNCII_H
   #define __FUNCTII_H
   void afisaza_suma();
   void afisaza_produs();
   #endif

functii.c:
   #include<stdio.h>
   #include"prog.h"
   #include"functii.h"
   void afisaza_suma(){printf("Suma este: %d\n",operand1+operand2);}
   void afisaza_produs(){printf("Produsul este: %d\n",operand1*operand2);}

prog.h:
   #ifndef __PROG_H
   #define __PROG_H
   extern int operand1, operand2;
   #endif

prog.c:
   #include<stdio.h>
   #include"prog.h"
   #include"functii.h"
   int operand1, operand2;
   int main(){
     printf("Primul operand = "); scanf("%d",&operand1);
     printf("Al 2-lea operand = "); scanf("%d",&operand2);
     afisaza_suma();
     afisaza_produs();
     return 0;
   }

(deci biblioteca de functii refera variabilele 'operand1' si 'operand2'
definite in program).

 Vedem cele 4 fisiere:

$ls
functii.c  functii.h  prog.c  prog.h

 Cream biblioteca cu legare dinamica 'libfunctii'. Vom lucra minimalist: vom
pune toate numele in directorul curent si vom crea doar linkername-ul, pe
care il vom folosi si ca realname si ca soname:

$gcc -fPIC -shared -Wl,-soname,libfunctii.so -o libfunctii.so functii.c

vedem ce a aparut:

$ls
functii.c  functii.h  libfunctii.so  prog.c  prog.h

 Cream un executabil 'prog' din 'prog.c' si biblioteca 'libfunctii'

$ gcc -Wl,-export-dynamic -o prog prog.c -L. -lfunctii

Notam prezenta optiunii '-Wl,-export-dynamic' care face ca toate simbolurile
din programul principal sa fie vizibile in biblioteca (vrem sa putem accesa
din biblioteca variabilele 'operand1', 'operand2'); linkername-ul bibliotecii
'libfunctii' este in directorul curent, deci a trebuit precizat '-L.' si
'-lfunctii'.

 Stocam directorul curent (puteam doar sa-l adaugam, ca mai inainte) in
variabila de environment 'LD_LIBRARY_PATH' (aici se afla soname-ul
bibliotecii):

$export LD_LIBRARY_PATH=.

 Acum putem rula programul:

$./prog
Primul operand = 10
Al 2-lea operand = 20
Suma este: 30
Produsul este: 200


1.3. Pluginuri:
---------------

 Bibliotecile cu legare dinamica sunt utile pentru a implementa conceptul de
plugin; un plugin este o biblioteca compilata, care se poate adauga unui
program deja compilat, iar acesta sa o vada si sa utilizeze obiectele din
ea fara sa fie nevoie sa-l recompilam.
 In acest scop sunt utile apelurile:

#include <dlfcn.h>

void *dlopen(const char *filename, int flag);
   incarca biblioteca cu legare dinamica avand linkername-ul
    'filename' (daca este dat fara cale, este cautat in directoarele
    standard si in cele memorate in 'LD_LIBRARY_PATH') si o deschide
    intr-unul dintre modurile 'flag', care poate fi 'RTLD_NOW' (si atunci
    simbolurile nedefinite din biblioteca sunt rezolvate inainte de returnul
    din 'dlopen') sau 'RTLD_LAZY' (si atunci simbolurile sunt rezolvate doar
    pe masura ce codul care le refera se executa);
   referintele la variabile sunt intotdeauna asociate imediat (immediately
    bound) cand biblioteca partajata este incarcata; asocierea intarziata
    (lazy binding) este efectuata doar in cazul referintelor la functii;
   functia 'dlopen()' returneaza adresa unei entitati handler opac care va
    referi in continuare biblioteca (sau NULL in caz de eroare) - acest
    handler va fi folosit in continuare de celelalte functii pentru a
    referi biblioteca;
  daca 'filename' este NULL, handlerul returnat este pentru programul
    principal;
  daca obiectul specificat de 'filename' are dependinte catre alte obiecte
    partajate, acestea sunt de asemenea incarcate de dynamic linker,
    folosind aceleasi reguli (proces recursiv);
  daca aceeasi biblioteca este deschisa cu 'dlopen()' din nou, este returnata
    aceeasi adresa handler;
  dynamic linker-ul contorizeaza deschiderile/inchiderile unei biblioteci,
    contorul creste cu 1 la 'dlopen()' si scade cu 1 la 'dlclose()' iar
    biblioteca este incarcata /descarcata in memorie doar cand contorul trece
    0 -> 1, respeciv 1 -> 0;

void *dlsym(void *handle, const char *symbol);
    returneaza adresa unde se afla incarcat in memorie simbolul cu
     numele 'symbol' din biblioteca referita de 'handle' (care este o
     valoare returnata anterior de un apel 'dlopen()'); in caz de eroare
     returneaza NULL;

int dlclose(void *handle);
    inchide biblioteca referita de 'handle' (care este o valoare
     returnata anterior de un apel 'dlopen()'), scazand numarul de referinte
     la ea; daca numarul de referinte ajunge la 0 si nici o alta biblioteca
     incarcata nu mai foloseste simboluri din ea, biblioteca este
     descarcata; returneaza 0 la succes si o valoare nenula la esec;

char *dlerror(void);
    returneaza adresa unui string intern continand un mesaj ce descrie
     ultima eroare produsa la un apel 'dlopen()', 'dlclose()' sau 'dlsym()';
     totodata sterge consemnarea acelei erori; returneaza NULL daca nu s-a
     produs nici o eroare de la initializare sau daca ultima functie
     apelata a fost tot 'dlerror()' (care a sters consemnarea erorii
     anterioare);

Exemplul 8: exemplu luat din 'man dlopen', in care se incarca biblioteca
===========    matematica si se invoca din ea functia 'cos()' pentru a afisa
               valoarea cos(2):

Avem un singur fisier, 'prog.c' continand:

       #include <stdio.h>
       #include <stdlib.h>
       #include <dlfcn.h>
       #include <gnu/lib-names.h>  /* Defines LIBM_SO (which will be a
                                      string such as "libm.so.6") */
       int main(void)
       {
           void *handle;
           double (*cosine)(double);
           char *error;

           handle = dlopen(LIBM_SO, RTLD_LAZY);
           if (!handle) {
               fprintf(stderr, "%s\n", dlerror());
               exit(EXIT_FAILURE);
           }

           dlerror();    /* Clear any existing error */

           cosine = (double (*)(double)) dlsym(handle, "cos");

           /* varianta:
                  *(void **) (&cosine) = dlsym(handle, "cos");
           */

           error = dlerror();
           if (error != NULL) {
               fprintf(stderr, "%s\n", error);
               exit(EXIT_FAILURE);
           }

           printf("%f\n", (*cosine)(2.0));
           dlclose(handle);
           exit(EXIT_SUCCESS);
       }

El se compileaza cu:

$gcc -o prog prog.c -ldl

(optiunea '-ldl' este necesara pentru a se face linkeditarea
cu biblioteca standard 'libdl' unde sunt definite functiile
'dlopen()', 'dlclose()', 'dlsym()', 'dlerror()' si care altfel
nu este luata in consideratie; constatam ca nu este necesara
linkeditarea cu biblioteca standard de matematica 'libm', deoarece
aceasta este deschisa explicit in program).

La rulare obtinem:

$./prog
-0.416147

Exemplul 9: Ilustrarea lucrului cu plugin-uri:
===========

Consideram urmatorul program 'prog.c' care afisaza un meniu,
citeste de la standard input o optiune, apoi executa comanda din
meniu cu numarul respectiv. El definieste o lista de nume de comenzi,
o lista de comenzi asociate si o variabila de recuperare a codului
de eroare, care vor fi populate la runtime pe baza pulgin-urilor
prezente in directorul curent (sub forma unor biblioteci partajate
cu nume terminate in '.plugin'):

#include <sys/types.h>
#include <dirent.h>
#include <dlfcn.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

char *nume_comanda[1024];
void (*comanda[1024])(void);
int nr_comenzi;
int cod_eroare;

void comanda_iesire(void) {exit(0);}

int main(){
  DIR *pd; struct dirent *pde; int i;

  nume_comanda[0] = "iesire";
  comanda[0] = comanda_iesire;
  nr_comenzi = 1;

  if((pd = opendir(".")) == NULL) {
    perror("."); return 1;
  }
  while((pde = readdir(pd)) != NULL) {
    char nume[258]; void *bib; void (*f)(void);
    if(strlen(pde -> d_name) < 7 ||
       strcmp(pde -> d_name + (strlen(pde -> d_name) - 7), ".plugin") != 0
    ) continue;
    sprintf(nume, "./%s", pde -> d_name);
    if((bib = dlopen(nume, RTLD_LAZY)) == NULL)
      continue;
    if((f = (void (*) (void)) dlsym(bib, "populeaza")) == NULL)
      continue;
    (*f)();
  }
  closedir(pd);

  do {
    printf("Comenzi:\n");
    for(i = 0; i < nr_comenzi; ++i)
      printf("  %d. %s\n", i, nume_comanda[i]);
    printf("Introduceti comanda: "); scanf("%d", &i);
    if(i < 0 || i >= nr_comenzi) continue;
    comanda[i]();
    if(cod_eroare != 0) printf("S-a produs eroarea nr. %d\n", cod_eroare);
  } while(1);

  return 0;
}

Comentarii:
- 'nume_comanda', 'comanda', 'nr_comenzi' definesc meniul; prima
 comanda ('iesire') este inregistrata in 'main()', restul vor
 fi inregistrate de plugin-urile gasite in directorul curent
 prin functia lor 'populeaza()';
- plugin-urile din directorul curent, in fapt biblioteci partajate,
 le-am specificat la 'dlopen()' prin './nume', altfel ar fi fost
 cautate in in directoarele standard si in cele memorate in
 'LD_LIBRARY_PATH', nu in directorul curent;
- deoarece 'nume_comanda', 'comanda', 'nr_comenzi', 'cod_eroare'
 trebuie sa fie vizibile in plugin-uri, programul trebuie compilat
 cu optiunea '-Wl,-export-dynamic';

  Compilam programul de mai sus:

$gcc -Wl,-export-dynamic -o prog prog.c -ldl

  La rulare, vom avea la dispozitie o singura comanda in meniu:

$./prog
Comenzi:
  0. iesire
Introduceti comanda: 0

  Sa adaugam acum indirectorul curent un plugin ca biblioteca
partajata, 'divizor.plugin', provenit din urmatorul fisier sursa
'divizor.c'; el adauga doua comenzi in meniul programului, pentru
cmmdc si cmmmc doi intregi:

#include <stdlib.h>
#include <stdio.h>

extern char *nume_comanda[1024];
extern void (*comanda[1024])(void);
extern int nr_comenzi;
extern int cod_eroare;

void comanda_cmmdc();
void comanda_cmmmc();

void populeaza() {
  nume_comanda[nr_comenzi] = "cmmdc";
  comanda[nr_comenzi] = comanda_cmmdc;
  ++ nr_comenzi;
  nume_comanda[nr_comenzi] = "cmmmc";
  comanda[nr_comenzi] = comanda_cmmmc;
  ++ nr_comenzi;
}


int cmmdc(int a, int b) {
  if(a == 0 || b == 0) return a + b;
  while(a != b) if(a < b) b -= a; else a -= b;
  return a;
}
void comanda_cmmdc() {
  int a, b;
  printf("    a = "); scanf("%d", &a);
  printf("    b = "); scanf("%d", &b);
  if(a < 0 || b < 0 || (a == 0 && b == 0))
    {cod_eroare = 1; return;}
  printf("    cmmdc(%d, %d) = %d\n", a, b, cmmdc(a, b));
  cod_eroare = 0;
}
void comanda_cmmmc() {
  int a, b;
  printf("    a = "); scanf("%d", &a);
  printf("    b = "); scanf("%d", &b);
  if(a < 0 || b < 0 || (a == 0 && b == 0))
    {cod_eroare = 1; return;}
  printf("    cmmmc(%d, %d) = %d\n", a, b, (a * b) / cmmdc(a, b));
  cod_eroare = 0;
}

 Intrucat biblioteca va fi accesata explicit printr-un nume de fisier
folosind 'dlopen()', nu indirect prin dynamic linker-ul 'ld-linux.so',
nu este nevoie sa inregistram in biblioteca vreun soname (asa cum, mai
devreme, nici la compilarea programului 'prog' nu am precizat vreo
biblioteca care sa fie inregistrata in sectiunea 'NEEDED' a
executabilului ELF). Atunci putem compila 'divizor.c' ca biblioteca
partajata fara soname ci doar cu realname-ul 'divizor.plugin':

$gcc -fPIC -shared -o divizor.plugin divizor.c

  Acum, fara a mai recompila programul 'prog.c', il lansam si observam ca
are un meniu cu trei comenzi:

$./prog
Comenzi:
  0. iesire
  1. cmmdc
  2. cmmmc
Introduceti comanda: 1
    a = 4
    b = 6
    cmmdc(4, 6) = 2
Comenzi:
  0. iesire
  1. cmmdc
  2. cmmmc
Introduceti comanda: 2
    a = 4
    b = 6
    cmmmc(4, 6) = 12
Comenzi:
  0. iesire
  1. cmmdc
  2. cmmmc
Introduceti comanda: 2
    a = 4
    b = -3
S-a produs eroarea nr. 1
Comenzi:
  0. iesire
  1. cmmdc
  2. cmmmc
Introduceti comanda: 0


1.4. Teme propuse:
------------------

1. Modificati programul din exemplul 9 a.i. gestionarea
  meniului sa se faca dintr-un plugin separat. Deci, sa existe
  plugin de meniu si pluginuri de comenzi.

2. Scrieti un program care afisaza graficele unor diverse functii
  reale de variabila reala. Dintr-un meniu se specifica numele
  functiei, capetele intervalului de definire, scara pe orizontala
  si verticala (lungimea segmentului orizontal / vertical care
  corespunde unui caracter pe ecran). Graficul va fi afisat text:
       **        **
      *  *      *
     *    *    *
           *  *
            **
   De exemplu, el se poate genera intr-o matrice de caractere
  80x25, care apoi se afisaza cu 'for' + 'printf()'.
   Programului i se pot adauga ulterior functii, sub forma unor
  plugin-uri; fiecare plugin aduce un nume de functie (care va aparea)
  in meniul programului) si o functie cu parametru double si valoare double.

3. ? (subiect deschis, folositi imaginatia !)


2. Compilarea pe baza unui makefile:
====================================

Referinte:
[1] https://www.gnu.org/software/make/manual/
[2] https://www.tutorialspoint.com/makefile/makefile_quick_guide.htm
[3] https://makefiletutorial.com/

Unele exemple au fost preluate sau adaptate, cu mici modificari, de la
site-urile de mai sus.


2.1. Tinte ('targets'), dependinte ('prerequisites'), retete ('recipes'):
-------------------------------------------------------------------------

 Putem gestiona mai eficient proiecte complexe folosind comanda 'make' si
un fisier 'Makefile'. Mai exact:
- intr-un director punem fisierele proiectului;
- in acelasi director cream un fisier text numit 'Makefile' care contine
 reguli scrise dupa o anumita sintaxa;
- din directorul respectiv ca director curent, executam comanda 'make'
 sau mai general 'make [options]... [targets]...'.
Atunci, utilitarul 'make' va procesa proiectul pe baza indicatiilor din
fisierul 'Makefile'.

 Un fisier 'Makefile' contine definitii si reguli. Definitiile le vom discuta
mai tarziu iar regulile (rule) pot fi de forma urmatoare:

targets ... : prerequisites ...
	recipes
	...

de exemplu:

t1 t2 t3 : p1 p2 p3 p4
	r1
	r2

- 'targets' si 'prerequisites' sunt liste de nume separate prin blank sau
 expresii care se pot interpreta ca asemenea liste (vom vedea); aceste
 nume semnifica fisiere dar nu este necesar sa fie fisiere existente
 (unele pot sa nici nu fie create vreodata); in loc de 'prerequisites'
 (preconditii) se mai spune 'dependencies' (dependinte);
- fiecare 'recipe' (reteta) este o comanda shell; ea trebuie indentata cu un
 caracter TAB (nu BLANK) (in caz contrar comanda 'make' esueaza); aceste
 comenzi se pot referi sau nu la numele din 'targets' si 'prerequisites';
 fiecare comanda este executata intr-un nou proces shell (cel putin in
 aparenta); putem specifica un alt caracter in loc de TAB pentru a indenta
 retetele (recipe prefix character), daca setam variabila '.RECIPEPREFIX'
 cu noul caracter (vom vedea);
- lista 'targets' nu poate fi vida dar lista 'prerequisites' poate fi vida.

 Sensul regulii este ca fiecare target (i.e. nume din lista 'targets') care
este expirat (out of date) va fi refacut/actualizat (re-made, updated) din
lista de dependinte ('prerequisites') executand lista de retete ('recipes')
 Un target este expirat daca:
- nu exista (ca fisier existent);
- exista (ca fisier existent) iar in lista 'prerequisites' exista macar o
 dependinta (un nume) care corespunde unui fisier existent si care are
 momentul ultimei actualizari mai recent decat al targetului.
 In particular, daca lista 'prerequisites' este vida:
- toate target-urile inexistente se actualizeaza;
- toate target-urile existente nu se actualizeaza.

 Numele care apar ca dependinte intr-o regula pot aparea ca targeturi in
alta regula, fiind astfel parte a unei ierarhii de dependenta. Atunci,
actualizarea unui target poate declansa actualizarea altor targeturi, a.i.
nici un target sa nu fie "mai vechi" decat dependintele sale.

 Procesarea poate incepe dand comanda 'make nume' (si avand ca director
curent directorul care contine fisierul 'Makefile'). Atunci, utilitarul
'make' va determina descendent arborescenta de targeturi care incepe cu
'nume', apoi o va parcurge ascendent (bottom-up) actualizand targeturile
expirate.
 Daca dam comanda 'make nume1 nume2 ...' (mai multe argumente) se vor trata,
in ordine, arborescentele tuturor acestor nume.
 Daca dam comanda 'make' (fara argumente), se va trata primul target din
prima regula a fisierului 'Makefile'.
 Putem folosi 'make' cu optiunea '-C dir' pentru a schimba directorul curent
in 'dir' inainte de a citi fisierul 'Makefile' si optiunea '-f file' pentru
a folosi fisierul 'file' ca 'Makefile'.
 Intr-o regula, putem plasa prima comanda (recipe) pe aceeasi linie in
continuarea dependintelor, separata cu ';':

targets: prerequisites ; recipe1
	recipe2
	recipe3
	...

In felul acesta, in cazul regulilor simple, care au o singura recipe,
putem evita indentarea cu TAB.

 La executare, utilitarul 'make' se termina daca vreuna dintre comenzile
shell (recipe) lansate furnizeaza un cod de return care inseamna esec
(failure status, in general, o valoare nenula), dar ignora codul de retur
al comenzilor care incep cu '-' (dash); daca vrem sa ignore codul de retur
al tuturor comenzilor, folosim 'make' cu optiunea '-i'; daca in timpul
executarii lui 'make' tastam Ctrl-c, rularea se termina si se vor sterge
toate target-urile noi care tocmai au fost facute.

  La sfarsitul liniilor din 'Makefile', ca si la sfarsitul comenzilor shell,
pot fi adaugate comentarii care incep cu '#' (similar ca intr-un script
shell).

Exemplul 1:
==========

$ls
Makefile
$cat Makefile
a1 a2:
	echo operatia 1
	echo operatia 2

$make
echo operatia 1
operatia 1
echo operatia 2
operatia 2
$make a1 a2
echo operatia 1
operatia 1
echo operatia 2
operatia 2
echo operatia 1
operatia 1
echo operatia 2
operatia 2
$ls
Makefile

Comentarii:
- in cazul 'make', cele doua comenzi 'echo' au fost executate pentru
 target-ul 'a1' (primul target din prima regula); in cazul 'make a1 a2',
 cele doua comenzi 'echo' au fost executate pentru ambele target-uri;
 intrucat ele nu existau si nu au fost create niciodata ca fisiere, de
 fiecare data cand am executat 'make' au fost executate toate aceste comenzi;
- implicit, 'make' afisaza comenzile inainte de a le executa; putem
 dezactiva afisarea unei anumite comenzi inainte de a fi executata
 daca o incepem cu '@' (de exemplu: '@echo operatia 1') - caracterul
 '@' va fi eliminat inainte de a fi trimisa comanda catre shell; daca
 vrem sa dezactivam afisarea pentru toate comenzile, putem lansa 'make'
 cu optiunea '-s' (silent):

$make -s
operatia 1
operatia 2

Daca un recipe contine doar un comentariu, el este o linie de comanda
valida shell (care insa nu executa nimic) si va fi afisata inainte de
a fi executata daca nu incepe cu '@' si nu am folosit '-s':

$cat Makefile
a:
	# comentariu; inainte de '#' este un TAB, el nu este trimis la shell
	   # inainte de '#' este 1 TAB si 3 blank; blank-urile se trimit la shell
	@# inainte de '@' este TAB; comanda nu se afisaza dar se trimite la shell

$make
# comentariu; inainte de '#' este un TAB, el nu este trimis la shell
# inainte de '#' este 1 TAB si 3 blank; blank-urile se trimit la shell
$make -s

Exemplul 2:
==========

$ls
Makefile
$cat Makefile
a:
	echo ceva > a

$make
echo ceva > a
$make
make: 'a' is up to date.
$ls
a  Makefile

Comentariu: primul 'make' a executat 'echo', deoarece 'a' nu exista
 (ca fisier); al doilea 'make' nu a executat nimic, deoarece 'a'
 exista si nu avea dependinte mai recente (de fapt, nu avea dependinte
 de loc).

Exemplul 3:
==========

$ls
Makefile
$cat Makefile
a: b c
	cat b c > a
b:
	echo ceva > b
c:
	touch c
clean:
	rm -f a b c

$make
echo ceva > b
touch c
cat b c > a
$make
make: 'a' is up to date.
$touch b
$make
cat b c > a
$ls
a  b  c  Makefile
$make clean
rm -f a b c
$ls
Makefile

Comentarii:
- cand am dat comanda 'make' s-a subanteles 'make a' ('a' este
 target-ul din prima regula scrisa in 'Makefile');
- ierarhia dependentelor lui 'a' este 'b' -> 'a' <- 'c';
  parcursa bottom-up este 'b', 'c', 'a';
- la primul 'make', nici unul din target-uri nu exista si atunci s-au
 executat toate comenzile; in total, au aparut fisierele 'b', 'c', 'a';
- la al doilea 'make', 'b' si 'c' nu aveau dependinte mai recente (de fapt,
 nu aveau dependinte deloc) iar 'a' era mai recent decat 'b', 'c' si astfel
 nu s-a executat nimic;
- cu 'touch b' am actualizat fisierul 'b' si atunci la al treilea 'make'
 a mai fost procesat doar targetul 'a' (nu si 'b', 'c');
- cu 'ls' vedem ca pe disc au aparut fisierele 'a', 'b', 'c';
- cu 'make clean' a fost procesat target-ul 'clean' care a condus la
 stergerea fisierelor nedorite; optiunea '-f' lui 'rm' face sa nu se afiseze
 eroare daca vreun fisier indicat pentru stergere nu exista.

Exemplul 4:
==========

$ls
Makefile  prog1.c  prog2.c
$cat Makefile
all: prog1 prog2
prog1: prog1.o
	gcc -o prog1 prog1.o
prog1.o: prog1.c
	gcc -c prog1.c
prog2: prog2.o
	gcc -o prog2 prog2.o
prog2.o: prog2.c
	gcc -c prog2.c
install:
	mv prog1 /bin
	mv prog2 /bin
clean:
	rm -f *.o

$make
gcc -c prog1.c
gcc -o prog1 prog1.o
gcc -c prog2.c
gcc -o prog2 prog2.o
$make install
mv prog1 /bin
mv prog2 /bin
$make clean
rm -f *.o

Comentarii:
- in acest proiect, avem doua ierarhii independente: cea care
 conduce la 'prog1' si cea care conduce la 'prog2'; putem trata
 doar unul dintre target-uri, de exemplu 'make prog1', dar daca
 le vrem pe toate, o cale eleganta este sa integram toate ierarhiile
 intr-una singura, 'all'; daca regula lui 'all' este pusa prima,
 target-ul 'all' este considerat implicit si este suficient sa dam
 comanda 'make' (nu 'make all');
-  este o practica uzuala sa avem target-urile 'all', care sa fie
 si prima regula, 'clean' pentru eliminat fisierele nedorite,
 'install' pentru instalarea in sistem a programelor create.

O scriere neatenta a regulilor ar putea face ca la 'make' un fisier
target sa nu se mai actualizeze atunci cand sunt actualizate fisierele
de care depinde logic in proiect.

Exemplul 5:
===========

$ls
header.h  Makefile  program.c
$cat header.h
int a = 1;

$cat program.c
#include "header.h"
int main(){return a;}

$cat Makefile
program: program.o
	gcc -o program program.o
program.o:
	gcc -c program.c

$make
gcc -c program.c
gcc -o program program.o
$touch program.c
$make
make: 'program' is up to date.
$touch header.h
$make
make: 'program' is up to date.
$

Comentariu: 'make' nu a sesizat actualizarea lui 'header.h' sau
 'program.c' (pe care le-am simulat cu 'touch') si nu a actualizat
 'program.o', deoarece 'header.h' si 'program.c' nu au fost trecute
 ca dependinta la 'program.o'; corect ar fi fost sa scriem:
   program.o: header.h program.c
 nu ar fi fost suficient nici sa scriem:
   program.o: program.c
 (pe considerentul ca incluziunea lui 'header.h' este scrisa in 'program.c'
 si astfel headerul va fi luat oricum in consideratie la compilare, deoarece
 daca 'header.h' nu este trecut si in lista de dependente a lui 'program.o'
 atunci 'make' nu va sesiza daca este actualizat 'header.h' si nu va lansa
 compilarea).

Exemplul 6:
==========

Presupunem ca avem in directorul curent fisierele:

patrat.h:
   #ifndef __PATRAT_H
   #define __PATRAT_H
   int patrat(int);
   #endif

patrat.c:
   #include"patrat.h"
   int patrat(int n){
     return n*n;
   }

sumapatrate.h:
   #ifndef __SUMAPATRATE_H
   #define __SUMAPATRATE_H
   int sumapatrate(int);
   #endif

sumapatrate.c:
   #include"patrat.h"
   #include"sumapatrate.h"
   int sumapatrate(int n){
     int i,s;
     s=0; for(i=1;i<=n;++i) s+=patrat(i);
     return s;
   }

dublu.h:
   #ifndef __DUBLU_H
   #define __DUBLU_H
   int dublu(int);
   #endif

dublu.c:
   #include"dublu.h"
   int dublu(int n){
     return 2*n;
   }

prog1.c:
   #include<stdio.h>
   #include "sumapatrate.h"
   #include "dublu.h"
   int a,b,c;
   int main(){
     printf("a = "); scanf("%d",&a);
     printf("b = "); scanf("%d",&b);
     c=dublu(sumapatrate(a)+sumapatrate(b));
     printf("rezultat = %d\n",c);
     return 0;
   }

prog2.c:
   #include<stdio.h>
   #include "sumapatrate.h"
   int a,c;
   int main(){
     printf("a = "); scanf("%d",&a);
     c=sumapatrate(a);
     printf("rezultat = %d\n",c);
     return 0;
   }

Aceste fisiere depind unele de altele dupa schema:

      patrat ---> sumapatrate ---> prog2
                       |
                       V
          dublu ---> prog1

 El poate fi organizat simplu ca proiect astfel:

$ls
dublu.c  Makefile  patrat.h  prog2.c        sumapatrate.h
dublu.h  patrat.c  prog1.c   sumapatrate.c
$cat Makefile
all:
	gcc -o prog1 patrat.c sumapatrate.c dublu.c prog1.c
	gcc -o prog2 patrat.c sumapatrate.c prog2.c

 Aceasta organizare dezavantajul ca la fiecare 'make' se compileaza
tot codul, chiar daca intre timp nu s-au modificat toate fisierele
sursa, poate chiar nici unul (intr-adevar, 'all' nu este creat niciodata
ca fisier si astfel este tot timpul un target expirat), sau chiar daca
avem nevoie doar de unul dintre cele doua programe din final, 'prog1'
sau 'prog2'; in cazul proiectelor mari, aceasta se poate dovedi ineficient.

 O variata care va compila doar fisierele relevante este:

$cat Makefile
all: prog1 prog2

prog1: patrat.o sumapatrate.o dublu.o prog1.o
	gcc -o prog1 patrat.o sumapatrate.o dublu.o prog1.o

prog2: patrat.o sumapatrate.o prog2.o
	gcc -o prog2 patrat.o sumapatrate.o prog2.o

prog1.o: sumapatrate.h dublu.h prog1.c
	gcc -c prog1.c

prog2.o: sumapatrate.h prog2.c
	gcc -c prog2.c

patrat.o: patrat.h patrat.c
	gcc -c patrat.c

sumapatrate.o: patrat.h sumapatrate.h sumapatrate.c
	gcc -c sumapatrate.c

dublu.o: dublu.h dublu.c
	gcc -c dublu.c

clean:
	rm -f *.o

Comentarii:
- daca dam 'make', va trata ambele programe, 'prog1' si 'prog2';
 daca dam 'make prog1' sau 'make prog2', va trata doar unul dintre
 ele; observam ca target-ul 'all' nu are lista de recipes - intr-adevar,
 'prog1' si 'prog2', odata procesate, nu trebuie combinate in vreun fel
 dar 'make' va urmari ierarhia all -> prog1, prog2 -> ...;
- comanda 'gcc -c patrat.c' nu necesita precizarea lui 'patrat.h'
 (deoarece in 'patrat.c' este mentionat '#include"patrat.h"') dar
 targetul 'patrat.o' din 'Makefile' necesita precizarea acestei dependente,
 altfel nu va lansa compilarea daca s-a modificat doar 'patrat.h';
 comentarii similare si in cazul targeturilor 'sumapatrate.o', 'dublu.o'.


2.2. Variabile:
---------------

 Intr-un 'Makefile' putem defini variabile (macro-uri), care sunt nume
asignate la valori sir (sirul poate contine si spatii) iar atunci cand
vor fi referite se va considera valoarea lor curenta (se vor expanda).

 Variabilele pot fi asignate la valori in mai multe feluri, de exemplu:

variabila=valoare
  Recursively Expanded Variable Assignment - variabilele referite de
  'valoare' sunt expandate de fiecare data cand 'variabila' e expandata
  (recursive expansion); astfel, 'valoare' poate contine variabile
  definite ulterior definitiei lui 'variabila' dar anterior expandarii
  acesteia;

variabila:=valoare
variabila::=valoare
  Simply Expanded Variable Assignment - variabilele referite de 'valoare'
  sunt expandate o sigura data, atunci cand 'variabila' este definita;
  variabilele referite de 'valoare' care nu au fost definite anterior
  definitiei lui 'variabila' sunt expandate la sirul vid; situatia
  seamana cu cea din programarea imperativa; varianta cu '::=' este POSIX;

 Variabila cu numele 'variabila' poate fi referita pentru expandare
(substituirea numelui cu valoarea) prin '$(variabila)' sau '${variabila}'.
De exemplu, daca avem 'abc=xyz' atunci 'ijk$(abc)lmn' se va expanda la
'ijkxyzlmn'.
 Daca numele 'variabila' are un singur caracter, se poate expanda si cu
'$variabila'; rezultatul insa poate fi confuz, de exemplu, daca avem 'x=a'
si 'xbc=d' atunci '$xbc' se va substitui cu 'abc' nu cu 'd'.
 Intr-o definitie de variabila, atat 'variabila' cat si 'valoare' pot contine
referinte cu '$' si atunci se fac expandari incuibate.
 Expandarea unei variabile nedefinite este sirul vid.

 Numele unei variabile nu poate contine ':', '#', '=', sau spatiu.
 Valoarea unei variabile este un string care poate contine si caractere
apostrof, ghilimele, backslash sau spatii - ele nu au o semnificatie
speciala pentru 'make' dar vor avea semnificatie pentru comenzile shell
lansate, atunci cand vom utiliza in ele aceste variabile expandate.

 La asignarea unei variabile, spatiile dintre '=',':=','::=' si 'valoare'
sunt ignorate, spatiile de dupa 'valoare' si pana la sfarsitul liniei sau
alt caracter ne-alb nu sunt ignorate.

 Daca dorim ca '$' sa apara ca atare intr-un nume sau valoare de variabila
(fara sa se faca vreo expandare), el trebuie dublat '$$'. Astfel putem
transmite shell-ului printr-un recipe un '$' pentru a expanda o variabila
de environment, de exemplu:
foo:
	echo $$PATH

 Intr-un 'Makefile' putem continua o linie logica pe o linie fizica noua
daca la sfarsitul liniei anterioare punem '\' (de fapt, este o secventa
escape: backslash newline).
 Daca linia impartita este un recipe, secventa escape backslash newline
este transmisa shell-ului (care, de exemplu, o poate interpreta ca fiind
continuarea aceleiasi linii de comanda pe randul urmator) dar recipe prefix
character-ul de la inceputul liniei urmatoare (de exemplu TAB) nu este
transmis shell-ului.
 Daca linia impartita nu este un recipe, secventa escape backslash newline
este inlocuita cu un singur blank; in fapt, toate spatiile din jurul unui
backslash newline sunt condensate intr-un singur blank, acestea incluzand
toate spatiile dinaintea lui backslash, toate spatiile de la inceputul
liniei de dupa backslash newline si toate combinatiile backslash newline
consecutive.

Exemplul 7:
===========

Ilustrarea diferentei dintre variabilele recursively expanded si
simply expanded (exemplu preluat de la [3]):

$cat Makefile
one = one ${later_variable}
two := two ${later_variable}
later_variable = later
all:
	echo $(one)
	echo $(two)

$make -s
one later
two

Ilustrarea modului cum sunt tratate spatiile de la stanga si dreapta lui
'valoare' si cum putem asigna o variabila cu un sir care contine un numar
bine definit de spatii (ghilimelele de la recipes sunt necesare deoarece
blankurile sunt caractere speciale shell si nu ar fi fost transmise corect
lui 'echo'):

$cat Makefile
a:=     xyz          # valoarea este 'xyz           '
nullstring:=         # valoarea este sirul vid
b:=$(nullstring)     # valoarea este '     ' (sir de 5 blankuri)
all:
	echo -"$(a)"-
	echo -"$(nullstring)"-
	echo -"$(b)"-

$make -s
-xyz          -
--
-     -

Ilustrarea modului cum putem trece la linie noua; dupa fiecare '\' se trece
imediat la linie noua, altfel nu ar fi secventa escape backslash newline,
fiecare recipe 'echo ...' incepe cu TAB, cand al doilea 'echo' trece pe
linie noua esta TAB urmat de 'y', cand al treilea 'echo' trece pe linie
noua este TAB, urmat de 5 blankuri, apoi de 'y'; observam cum shell-ul
interpreteaza blankurile transmise in liniile sale de comanda ca seperatori
si nu le transmite ca atare lui 'echo':

$cat Makefile
a:=x\
y
b:=   x   \
    y
c:=    x  \
   \
  \
y
all : unu doi trei patru
unu:
	echo unu:
	echo $(a)
	echo $(b)
	echo $(c)
doi:
	echo doi:
	echo -'$(a)'-
	echo -'$(b)'-
	echo -'$(c)'-
trei:
	echo trei:
	echo x\
y
	echo x\
	y
	echo x     \
	     y
patru:
	echo patru:
	echo -'x\
y'-
	echo -'x\
	y'-
	echo -'x     \
	     y'-
$make -s
unu:
x y
x y
x y
doi:
-x y-
-x y-
-x y-
trei:
xy
xy
x y
patru:
-x\
y-
-x\
y-
-x     \
     y-
$

(diferentele de la 'trei' si 'patru' sunt cauzate de faptul ca, in absenta
despecializarii cu '', shell-ul filtreaza backslash newline si blankurile
si le interpreteaza ca trecere pe linie noua, respectiv separator de cuvinte,
a.i. blankurile afisate sunt doar cele emise de 'echo').

Ilustrarea faptului ca o variabila nedefinita are, de fapt, ca valoare,
sirul vid:

$cat Makefile
all:
	echo -"$(nimic)"-

$make -s
--

Exemplul 8:
===========

Putem organiza proiectul din exemplul 6 astfel:

$ls
includeri  Makefile  surse
$ls includeri
dublu.h  patrat.h  sumapatrate.h
$ls surse
dublu.c  patrat.c  prog1.c  prog2.c  sumapatrate.c
$cat Makefile

header = includeri
source = surse

CC = gcc
CFLAGS = -Wall
INCLUDES = -I $(header)
LIBS = -lm -lncurses # in acest proiect, nu sunt necesare

prog = prog1 prog2
prog1 = patrat.o sumapatrate.o dublu.o prog1.o
prog2 = patrat.o sumapatrate.o prog2.o

all: $(prog)

prog1: $(prog1)
	$(CC) $(CFLAGS) $(INCLUDES) -o prog1 $(prog1) $(LIBS)

prog2: $(prog2)
	$(CC) $(CFLAGS) $(INCLUDES) -o prog2 $(prog2) $(LIBS)

prog1.o: $(header)/sumapatrate.h $(header)/dublu.h $(source)/prog1.c
	$(CC) $(CFLAGS) $(INCLUDES) -c $(source)/prog1.c $(LIBS)

prog2.o: $(header)/sumapatrate.h $(source)/prog2.c
	$(CC) $(CFLAGS) $(INCLUDES) -c $(source)/prog2.c $(LIBS)

patrat.o: $(header)/patrat.h $(source)/patrat.c
	$(CC) $(CFLAGS) $(INCLUDES) -c $(source)/patrat.c $(LIBS)

sumapatrate.o:\
$(header)/patrat.h $(header)/sumapatrate.h $(source)/sumapatrate.c
	$(CC) $(CFLAGS) $(INCLUDES) -c $(source)/sumapatrate.c $(LIBS)

dublu.o: $(header)/dublu.h $(source)/dublu.c
	$(CC) $(CFLAGS) $(INCLUDES) -c $(source)/dublu.c $(LIBS)

clean:
	rm -f *.o

Notam ca in comenzile shell dintr-un 'Makefile' putem
intalni constructii de forma '$nume' pentru a cere valori
atat ale variabilelor 'Makefile' cat si ale variabilelor de
environment. In cazul unui conflict de nume, variabilele
din 'Makefile' au precedenta, cu exceptia cazului cand folosim
'make' cu optiunea '-e':

Exemplul 9:
===========

$export x=10
$cat Makefile
x=abc
all:;echo $x

$make -s
abc
$make -se
10


 Putem concatena valori la o variabila deja definita, folosind '+=':

Exemplul 10:
===========

$cat Makefile
var-1 = a b c
var-2 = x y z
var-$(varenv) += p \
 q r
var = $(var-$(varenv))
all:
	echo var-1: $(var-1)
	echo var-2: $(var-2)
	echo var: $(var)

$export varenv=2
$make
echo var-1: a b c
var-1: a b c
echo var-2: x y z p q r
var-2: x y z p q r
echo var: x y z p q r
var: x y z p q r

Comentarii:
- am ales printr-o variabila de environment 'varenv'
 la care dintre cele doua variabile 'Makefile' 'var-1' si 'var-2'
 sa concatenam 'p q r'. Setarea lui 'var' ne arata ca putem folosi
 si mai multe referiri cu '$' incuibate;
- daca in loc sa folosim '+=':

var-$(varenv) += p \
 q r

 am fi incercat sa scriem cu '=':

var-$(varenv) = $(var-$(varenv)) p \
 q r

 ar fi dat eroare: 'Recursive variable 'var-2' references itself'.

 Expandarea simpla (cu ':=') permite apendarea la o variabila (alternativa
la folosirea lui '+='), in timp ce definitiile recursive (cu '=') genereaza
erori de bucla infinita (am vazut in exemplul 10).

Exemplul 11 (preluat de la [3]):
===========

$cat Makefile
one = hello
    # one gets defined as a simply expanded variable (:=)
    # and thus can handle appending
one := ${one} there
all:
	echo $(one)

$make -s
hello there


 Putem folosi '?=' pentru a seta doar variabilele care nu au fost
inca setate.

Exemplul 12 (preluat de la [3]):
===========

$cat Makefile
one = hello
one ?= will not be set
two ?= will be set
all:
	echo $(one)
	echo $(two)

$make -s
hello
will be set


 Putem defini variabile chiar in linia de comanda 'make'.

Exemplul 13:
============

$cat Makefile
all:
	echo $(a) $(b)

$make -s a='abc def ghi' b='$(a) jkl mno'
abc def ghi abc def ghi jkl mno

Comentariu: caracterele apostrof sunt pentru despecializarea
shell, deoarece caracterele dolar, paranteze rotunde, blank
sunt speciale pentru acesta.


 Putem face sa prevaleze o variabila definita in 'Makefile'
fata de una cu acelasi nume provenita din linia de comanda,
folosind in definitie 'override'.

Exemplul 14:
============

$cat Makefile
override var1 = val1vechi
var2 = val2vechi
all:
	echo $(var1)
	echo $(var2)
$make -s var1=val1nou var2=val2nou
val1vechi
val2nou


2.3. Variabile predefinite, variabile automatice:
-------------------------------------------------

 Exista variabile predefinite (build-in), care pot fi folosite ca
atare, pot fi redefinite (cu 'nume=valoare') sau modificate (cu
'nume+=valoare') sau se poate renunta la folosirea lor (comanda
'make' cu optiunea '-R');  in continuare, prezentam cateva dintre ele:

Variabile ce reprezinta nume de programe:
 AR
  utilitarul de arhivare; implicit este 'ar'
 AS
  asamblorul; implicit este 'as'
 CC
  compilatorul de C; implicit este 'cc'
 CXX
  compilatorul de C++; implicit este 'g++'
 CPP
  preprocesorul de C, cu iesire la standard output; implicit este '$(CC) -E'
 LEX
  generatorul de analizoare lexicale (transforma gramatici Lex in cod sursa);
  implicit este 'lex'
 YACC
  generatorul de analizoare sintactice / compilatoare (transforma
  gramatici Yacc in cod sursa); implicit este 'yacc'
 LINT
  programul pentru analiza statica a codului (detecteaza erori in cod
  fara a-l executa); implicit este 'lint'
 RM
  comanda de eliminat (remove) fisiere; implicit este 'rm -f'

Variabile ce reprezinta liste de argumente aditionale pentru programele
anterioare; in afara cazurilor mentionate, valorile lor implicite sunt
stringul vid:
 ARFLAGS
  optiuni pentru utilitarul de arhivare; implicit este 'rv' (adaugare la
  arhiva cu suprascriere 'r' si afisarea de informatii aditionale 'v'
  (verbose))
 ASFLAGS
  optiunui pentru assembler cand este invocat pentru un fisier '.s' sau '.S';
 CFLAGS
  optiuni pentru compilatorul de C;
 CXXFLAGS
  optiuni pentru compilatorul de C++;
 CPPFLAGS
  optiuni pentru preprocesorul de C si pentru programele care il folosesc;
 LDFLAGS
  optiuni pentru compilatoare, atunci cand se presupune ca vor invoca
  linkeditorul 'ld'
 LFLAGS
  optiuni pentru generatorul de analizoare lexicale;
 YFLAGS
  generatorul de analizoare sintactice / compilatoare;
 LINTFLAGS
  programul pentru analiza statica a codului.

 Exista variabile automatice (automatic variables), a caror
definitie este actualizata automat pentru fiecare regula
procesata ; prezentam cateva dintre ele:

 $@
  numele ca fisier al target-ului curent procesat; daca target-ul este
  un membru dintr-o arhiva (putem specifica in lista de target-uri un
  fisier arhiva '.a' si atunci se considera ca am inserat in lista de
  target-uri membrii arhivei) atunci '$@' este numele fisierului arhiva;
  intr-un tipar de regula (pattern rule) '$@' este numele oricarui tagret
  care a cauzat rularea comenzilor regulii (recipe);
  un tipar de regula este o regula care contine un caracter '%' in
  target - acesta specifica, de fapt, mai multe target-uri, de exemplu,
  un target '%.c' desemneaza ca target-uri toate fisierele terminate
  in '.c' si care au cel putin un caracter inainte de '.';

 $%
  numele de membru al target-ului, daca target-ul este un membru de arhiva;
  de exemplu, daca target-ul este arhiva 'foo.a' si aceasta contine membrul
  'bar.o' atunci '$%' este 'bar.o' iar '$@' este 'foo.a'; daca target-ul nu
  este membru de arhiva, '$%' este sirul vid;

 $<
  numele primei dependinte; daca target-ul si-a obtinut recipe-ul dintr-o
  regula implicita (vom discuta regulile implicite mai departe), va fi
  prima dependinta adaugata de regula implicita;

 $^
  lista numelor tuturor dependintelor, cu spatii intre ele; pentru
  dependintele care sunt membri in arhive, e folosit doar membrul numit;
  dependintele duplicat sunt specificate doar o data;

 $+
  ca la $^ dar cu pastrarea duplicatelor; este utila in comenzile de
  linkeditare unde are sens repetarea unei biblioteci; intr-adevar,
  numele cerute la linkeditare dintr-un fisier obiect sunt cautate doar
  in bibliotecile specificate in dreapta in linia de comanda si atunci,
  daca doua biblioteci se solicita reciproc, una trebuie repetata dupa
  celalalta;

 $?
  lista numelor dependintelor modificate mai recent decat target-ul
  curent procesat, cu spatii intre ele; daca target-ul nu exista, este
  lista tuturor dependintelor; pentru dependintele care sunt membri in arhive,
  e folosit doar membrul numit; '$?' este util daca vrem sa operam doar cu
  dependintele modificate, de exemplu:

lib: foo.o bar.o lose.o win.o
	ar r lib $?

  foloseste comanda de arhivare 'ar' pentru a copia (suprascrie)
  (comanda 'r') in arhiva de fisiere obiect 'lib.a' doar acele
  fisiere dintre 'foo.o', 'bar.o', 'lose.o', 'win.o' care au fost
  modificate;

 $*
  tulpina (stem) curenta cu care se potriveste un tipar de regula;
  de exemplu, daca tiparul de target este 'a.%.b', iar target-ul
  curent este 'dir/a.foo.b', atunci stem-ul este 'dir/foo' - el
  poate fi folosit pentru a construi nume de fisiere inrudite
  (de exemplu, fisiere cu acelasi nume '.i' din cele '.c');

Exemplul 15:
============

$cat Makefile
all: a1 a2
a1 a2: b1 b2 b3
	echo target: $@ dependences: $+ first one is: $<
b%:
	echo stem: $*

$make -s
stem: 1
stem: 2
stem: 3
target: a1 dependences: b1 b2 b3 first one is: b1
target: a2 dependences: b1 b2 b3 first one is: b1

Exemplul 16:
============

$ls
lib.a  Makefile
$cat Makefile
all: lib.a clean
lib.a: f1.c f2.c
	gcc -c $?
	ar r $@ $(?:.c=.o)
f1.c:
	@echo 'extern int x; int main(){return x;}' > f1.c
f2.c:
	@echo 'int x = 3;' > f2.c
clean:
	@rm -f f?.c f?.o
$make
gcc -c f1.c f2.c
ar r lib.a f1.o f2.o

Comentarii:
- expresia '$(?:.c=.o)' produce lista produsa de '$?', in care
 s-au inlocuit sufixele cuvintelor '.c' prin '.o' (a se vedea
 functia de inlocuire a sufixelor, replacing the suffix, mai departe);
- caracterul '?' din comanda 'rm' este tratat de shell
 (inseamna exact un caracter, oarecare).


2.4. Reguli implicite, tipare de reguli, reguli multiple:
---------------------------------------------------------

 Exista reguli implicite, care se aplica automat in cazul anumitor
target-uri, in functie de extensia lor, daca nu am precizat alte
reguli. De exemplu:

- compilarea unui program C:
  'n.o' este facut automat din 'n.c' cu o comanda de forma:
    $(CC) -c $(CPPFLAGS) $(CFLAGS) $^ -o $@

- compilarea unui program C++:
  'n.o' este facut automat din 'n.cc' sau 'n.cpp' cu o comanda de forma:
    $(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $^ -o $@

- linkeditarea unui fisier obiect:
  'n' este facut automat din 'n.o' cu o comanda de forma:
    $(CC) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS) -o $@

Exemplul 17 (preluat de la [3]):
===========

$ls
Makefile
$cat Makefile
CC = gcc    # Flag for implicit rules
CFLAGS = -g # Flag for implicit rules. Turn on debug info

# Implicit rule #1: blah is built via the C linker implicit rule
# Implicit rule #2: blah.o is built via the C compilation implicit rule,
#                   because blah.c exists
blah: blah.o

blah.c:
	echo "int main() { return 0; }" > blah.c

clean:
	rm -f blah*

$make
echo "int main() { return 0; }" > blah.c
gcc     -g    -c -o blah.o blah.c
gcc       blah.o   -o blah
$ls
blah  blah.c  blah.o  Makefile
$make clean
rm -f blah*
$ls
Makefile


 Se pot folosi tipare statice de reguli (static pattern rules), de forma:

targets...: target-pattern: prereq-patterns ...
   commands

Sensul este ca target-ul curent este potrivit (matched) cu tiparul de
target-uri (target-pattern) (via '%') si de fiecare data stem-ul rezultat
este substituit in tiparul de dependinte, pentru a obtine dependintele
corespunzatoare acestui target. O utilizare tipica este compilarea
fisierelor '.c' in fisiere '.o' cu acelasi nume.

Exemplul 18 (preluat de la [3]):
===========

$ls
Makefile
$cat Makefile
objects = foo.o bar.o all.o
all: $(objects)

# These files compile via implicit rules
# Syntax - targets ...: target-pattern: prereq-patterns ...
# In the case of the first target, foo.o, the target-pattern matches foo.o
#     and sets the "stem" to be "foo".
# It then replaces the '%' in prereq-patterns with that stem
$(objects): %.o: %.c

all.c:
	echo "int main() { return 0; }" > all.c

%.c:
	touch $@

clean:
	rm -f *.c *.o all

$make
echo "int main() { return 0; }" > all.c
cc    -c -o all.o all.c
touch foo.c
cc    -c -o foo.o foo.c
touch bar.c
cc    -c -o bar.o bar.c
cc   all.o foo.o bar.o   -o all
$ls
all  all.c  all.o  bar.c  bar.o  foo.c  foo.o  Makefile
$make clean
rm -f *.c *.o all
$ls
Makefile

Comentariu: folosind regula lui '%.c', fisierele 'foo.c' si 'bar.c'
sunt create cu 'touch' ca fisiere vide; in absenta regulii lui 'all.c',
la fel ar fi fost creat si 'all.c' iar aceasta ar fi produs o eroare la
linkeditarea 'cc   all.o foo.o bar.o   -o all' (facuta cu o regula
implicita), deoarece nici unul dintre fisierele obiect nu contine functia
'main()'; regula explicita separata pentru 'all.c' prevaleaza celei
pentru '%.c' in cazul lui 'all.c'.


 Se pot folosi reguli cu '::' (double-colon rules), care permit ca mai
multe reguli sa fie definite pentru un acelasi target.

Exemplul 19 (preluat de la [3]):
===========

$cat Makefile
all: blah

blah::
	echo "hello"

blah::
	echo "hello again"
$make
echo "hello"
hello
echo "hello again"
hello again

Comentariu: daca am fi scris 'blah:', se afisa un warning si doar
al doilea set de comenzi ar fi fost executat.


2.5. Stringuri ce contin '$', variabile de environment, variabile per target:
-----------------------------------------------------------------------------

 Daca dorim ca un string sa contina semnul dolar, putem folosi '$$';
in felul acesta putem folosi o variabila shell in 'bash' sau 'sh'.
Exemplul urmator ilustreaza diferentele intre variabilele 'Makefile'
si cele shell:

Exemplul 20 (preluat de la [3]):
===========

$cat Makefile
make_var = I am a make variable
all:
	# Same as running in the shell:
	#          "sh_var='I am a shell variable'; echo $sh_var"
	sh_var='I am a shell variable'; echo $$sh_var

	# Same as running in the shell:
	#          "echo I am a make variable"
	echo $(make_var)

$make -s
I am a shell variable
I am a make variable

Comentariu: am combinat 'sh_var='I am a shell variable'' si
'echo $$sh_var' in aceeasi linie de comanda cu ';' si nu le-am facut
linii de comanda separate, ca sa se execute in acelasi shell (altfel,
'echo $$sh_var' s-ar fi executat in alt proces shell, care nu ar fi
mostenit variabila shell 'sh_var').

 Putem adauga intr-un 'Makefile' linia 'export nume=sir' pentru a
crea variabile de environment (care se vor transmite in subcomenzi,
inclusiv sub-'make') din variabile 'Makefile'.

Exemplul 21 (preluat de la [3]):
===========

$cat Makefile
one=this will only work locally
export two=we can run subcommands with this

all:
	@echo $(one)
	@echo $$one
	@echo $(two)
	@echo $$two
$make
this will only work locally

we can run subcommands with this
we can run subcommands with this


Observatie: putem preveni ca o variabila sa fie exportata, folosind
'unexport variable'.


 Pot fi definite variabile specifice unui anumit target
sau tipar de target.

Exemplul 22:
============

$cat Makefile
all: unu fis.c doi
unu: var1 = aaa
%.c: var2 = bbb
unu:
	echo var1 este: $(var1)
	echo var2 este: $(var2)
fis.c:
	echo var1 este: $(var1)
	echo var2 este: $(var2)
doi:
	echo var1 este: $(var1)
	echo var2 este: $(var2)

$make -s
var1 este: aaa
var2 este:
var1 este:
var2 este: bbb
var1 este:
var2 este:


2.6. Apelarea make recursiv:
----------------------------

 Dintr-un 'Makefile' se poate apela recursiv 'make', dar e de preferat
sa scriem in loc '$(MAKE)', deoarece va transfera automat aceleasi
optiuni 'make', fara a fi afectat de ele.

Exemplul 23:
============

$cat Makefile
all: pregatire unu clean
pregatire:
	mkdir dirnou
	echo -e "doi:\n\techo 'nivelul doi'\n\ttouch fisier" > dirnou/Makefile
unu:
	echo 'nivelul unu'
	cd dirnou && $(MAKE)
clean:
	rm -rf dirnou
$make -s
nivelul unu
nivelul doi

Comentarii:
- am combinat 'cd dirnou' si '$(MAKE)' in aceeasi linie de
 comanda cu '&&' si nu le-am facut linii de comanda separate, ca sa
 se execute in acelasi shell (altfel, '$(MAKE)' s-ar fi executat in
 alt proces shell, care ar fi mostenit vechiul director curent, nu pe
'dirnou'); le puteam combina si cu ';';
- in loc de 'cd dirnou && $(MAKE)' puteam folosi '(MAKE) -C dirnou';
- optiunea '-e' face ca 'echo' sa interpreteze secventele cu backslash
 (in cazul nostru, '\n'=newline, '\t'=TAB).


2.7. Liste de comenzi conservate (canned recipe):
-------------------------------------------------

 Se pot defini liste de comenzi conservate (canned recipe), care sa
fie invocate ca un tot unitar in alte liste de comenzi - ele sunt
de fapt variabile, definite intre 'defun' ... 'endef':

define nume =
command1
 ...
commandn
endef

Comenzile din lista nu trebuie indentate cu TAB iar caracterele '$' continute
nu sunt substituie la acest moment (ci mai tarziu, cand invocam lista de
comenzi in alta lista).

Exemplul 24:
============

$cat Makefile
define reteta =
echo dependent: $^ target: $@
echo end
endef
a: x y z
	$(reteta)
	echo next
b: x y z
	@$(reteta)
	echo next
x:
y:
z:

$make a
echo dependent: x y z target: a
dependent: x y z target: a
echo end
end
echo next
next
$make b
dependent: x y z target: b
end
echo next
next

Comentarii:
- daca nu erau specificate target-urile 'x', 'y', 'z',
 ar fi semnalat eroare la procesarea lui 'a' sau 'b',
 de exemplu 'No rule to make target 'x', needed by 'a'';
- caracterul '@' pus in fata lui '$(reteta)' a dezactivat
 afisarea in ecou a tuturor comenzilor din 'reteta'.


2.8. Directive conditionale:
----------------------------

 In 'Makefile' putem folosi directive conditionale, care determina daca
o parte a 'Makefile' va fi respectata sau ignorata, in functie de valorile
unor expresii:

conditional-directive
text-if-true
endif

sau:

conditional-directive
text-if-true
else
text-if-false
endif

sau:

conditional-directive-one
text-if-one-is-true
else conditional-directive-two
text-if-two-is-true
else
text-if-one-and-two-are-false
endif

'conditional-directive' poate fi:

ifeq (arg1, arg2)
ifeq 'arg1' 'arg2'
ifeq "arg1" "arg2"
ifeq "arg1" 'arg2'
ifeq 'arg1' "arg2"

atunci, se evalueaza cele doua argumente, expandand variabilele continute,
apoi se testeaza egalitatea stringurilor; daca sunt egale, inseamna true;

De exemplu:

libs_for_gcc = -lgnu
normal_libs =

foo: $(objects)
ifeq ($(CC),gcc)
   $(CC) -o foo $(objects) $(libs_for_gcc)
else
   $(CC) -o foo $(objects) $(normal_libs)
endif

ifneq (arg1, arg2)
ifneq 'arg1' 'arg2'
ifneq "arg1" "arg2"
ifneq "arg1" 'arg2'
ifneq 'arg1' "arg2"

atunci, se evalueaza cele doua argumente, expandand variabilele continute,
apoi se testeaza egalitatea stringurilor; daca sunt diferite, inseamna true;

ifdef variable-name

atunci, daca variabila cu numele respectiv este definita, inseamna true;

ifndef variable-name

atunci, daca variabila cu numele respectiv nu este definita, inseamna true;

Obs: 'ifdef' si 'ifndef' nu expandeaza referintele la variabile prezente
 in argument.

Exemplul 25 (preluat de la [3]):
===========

$cat Makefile
# Conditional if/else
foo = ok
all:
ifeq ($(foo), ok)
	echo "foo equals ok"
else
	echo "nope"
endif
$make -s
foo equals ok

Exemplul 26 (preluat de la [3]):
===========

$cat Makefile
# Check if a variable is empty
nullstring =
foo = $(nullstring) # end of line; there is a space here
all:
ifeq ($(strip $(foo)),)
	echo "foo is empty after being stripped"
endif
ifeq ($(nullstring),)
	echo "nullstring doesn't even have spaces"
endif
$make -s
foo is empty after being stripped
nullstring doesn't even have spaces

Comentariu: 'strip' este o functie predefinita, care elimina
spatiile de la extremitatile stringului; despre functii, vom
discuta mai departe.

Exemplul 27 (preluat de la [3]):
===========

$cat Makefile
# Check if a variable is defined
bar =
foo = $(bar)
all:
ifdef foo
	echo "foo is defined"
endif
ifndef bar
	echo "but bar is not"
endif
$make -s
foo is defined
but bar is not

Comentariu: 'ifdef' nu expandeaza referintele la variabile;
la 'foo = $(bar)', nu s-a facut expandarea, si de aceea 'ifdef'
a detectat o variabila definita; daca am fi scris 'foo := $(bar)',
atunci la 'ifdef' variabila 'foo' ar fi fost si ea nedefinita.

Exemplul 28 (preluat de la [3]):
===========

$cat Makefile
# Using $(MAKEFLAGS)
all:
# Search for the "-i" flag.
# MAKEFLAGS is just a list of single characters, one per flag.
# So look for "i" in this case.
ifneq (,$(findstring i, $(MAKEFLAGS)))
	echo "i was passed to MAKEFLAGS"
endif
$make -s
$make -si
i was passed to MAKEFLAGS

Comentariu: 'MAKEFLAGS' este o variabila predefinita si exportata
in environment, prin care se pot transmite optiuni unui sub-'make';
'findstring' este o functie predefinita, care cauta un substring
intr-un string.


2.9. Functii:
-------------

Intr-un 'Makefile' putem folosi functii, si predefinite (built-in)
si definite de utilizator. In generel, functiile predefinite sunt
pentru procesarea de text. Functiile se pot apela sub forma:
  $(function_name arguments)
sau:
  ${function_name arguments}
Acolo unde apare, apelul va fi inlocuit cu stringul returnat,
asemeni expandarii variabilelor.


2.9.1. Functii pentru stringuri:
--------------------------------

Prezentam cateva functii predefinite pentru stringuri:

$(subst from,to,text)
  inlocuieste in 'text' toate ocurentele lui 'from' cu 'to';

Exemplul 29 (preluat de la [1]):
===========

$cat Makefile
all:
	@echo $(subst ee,EE,feet on the street)
$make
fEEt on the strEEt

Daca dorim sa inlocuim spatii sau virgule, folosim variabile.

Exemplul 30 (preluat de la [3]):
===========

$cat Makefile
comma := ,
empty:=
space := $(empty) $(empty)
foo := a b c
bar := $(subst $(space),$(comma),$(foo))
all:
	@echo $(bar)
$make
a,b,c

Daca includem spatii in argumentele de dupa primul, ele vor fi
considerate ca parte a stringului.

Exemplul 31 (adaptat de la [3]):
===========

$cat Makefile
comma := ,
empty:=
space := $(empty) $(empty)
foo := a b c
bar := $(subst $(space), $(comma) , $(foo))
all:
	# Output is "- , a , b , c-". Notice the spaces introduced
	@echo -'$(bar)'-
$make
# Output is "- , a , b , c-". Notice the spaces introduced
- , a , b , c-

Comentarii:
- spatiile au fost introduse deoarece am scris ', $(comma) ,';
  daca am fi scris ',$(comma),' s-ar fi afisat '-,a,b,c-';
- la rulare, a fost afisat si comentariul '# Output is ...';
  intr-adevar, pus ca recipe, el este o comanda shell, care se
 reduce la un comentariu, nu produce efecte la executie, dar este
 afisata inainte de a fie executata, daca nu este precedata cu
 '@' sau daca nu dam comanda 'make -s'.

$(patsubst pattern,replacement,text)
  gaseste cuvintele separate prin spatii din 'text' care se potrivesc
    tiparului 'pattern' si le inlocuieste cu 'replacement';
  'pattern' poate contine un '%', care se potriveste cu orice subsir
    dintr-un cuvant; daca 'replacement' contine de asemenea un '%',
    atunci '%' din 'replacement' este inlocuit cu textul care s-a
    potrivit cu '%' din pattern; doar primul '%' din 'pattern' si
    'replacement' este tratat astfel, restul '%' nu sunt modifiate;
    caracterele '%' pot fi despecializate cu '\';
  spatiile dintre cuvinte sunt comasate in cate un singur caracter
    spatiu iar spatiile de la inceput si sfarsit sunt eliminate;

Exemplul 32 (preluat de la [1]):
===========

$cat Makefile
all:
	@echo $(patsubst %.c,%.o,x.c.c bar.c)
$make
x.c.o bar.o

Doua variante prescurtate de folosire a functiei 'patsubst' sunt:

- substitution reference ('pattern' contine '%'):

$(var:pattern=replacement)

  este echivalent cu:

$(patsubst pattern,replacement,$(var))

-  replacing the suffix (nu sunt folosite '%' si se inlocuiesc sufixele
  de la sfarsitul cuvintelor):

$(var:suffix=replacement)

  este echivalent cu:

$(patsubst %suffix,%replacement,$(var))

Observatie: in acest caz, nu trebuie adaugate extra spatii, deoarece vor fi
considerate sir de cautare sau de inlocuire.

Exemplul 33 (preluat de la [3]):
===========

$cat Makefile
foo := a.o b.o l.a c.o
one := $(patsubst %.o,%.c,$(foo))
# This is a shorthand for the above
two := $(foo:%.o=%.c)
# This is the suffix-only shorthand, and is also equivalent to the above.
three := $(foo:.o=.c)
all:
	echo $(one)
	echo $(two)
	echo $(three)
$make -s
a.c b.c l.a c.c
a.c b.c l.a c.c
a.c b.c l.a c.c

Urmatoarele doua functii au fost exemplificate, a se vedea exemplele 26, 28:

$(strip string)
  elimina spatiile de la inceput si sfarsit din 'string' si inlocuieste
    orice succesiune interna de spatii cu cate un singur caracter spatiu;
  de exemplu, '$(strip a b c )' produce 'a b c';

$(findstring find,in)
  cauta o ocurenta a lui 'find' in 'in'; daca gaseste, valoarea produsa
    este 'find', altfel este sirul vid;

$(filter pattern...,text)
$(filter-out pattern...,text)
  produce lista tuturor cuvintelor, separate prin spatii, care apar in
    'text' si se potrivesc, respectiv nu se potrivesc, cu vreunul
    dintre tiparele 'pattern'...; aceste tipare sunt scrise cu '%', ca
    in cazul functiei 'patsubst';
  de exemplu:
    sources := foo.c bar.c baz.s ugh.h
    foo: $(sources)
         cc $(filter %.c %.s,$(sources)) -o foo
  spune ca 'foo' depinde de 'foo.c', 'bar.c', 'baz.s' si 'ugh.h' dar
    numai 'foo.c', 'bar.c' si 'baz.s' trebuie specificate in comanda de
    compilare;

$(sort list)
  sorteaza cuvintele din 'list' in ordine lexicografica, eliminand
    cuvintele duplicat si separand cuvintele prin cate un caracter spatiu;
  de exemplu, '$(sort foo bar lose)' produce 'bar foo lose';

$(word n,text)
  produce la n-lea cuvant din text, numarand de la 1; daca n > numarul
    cuvintelor din text, produce stringul vid; n este string de cifre
    zecimale;
  de exemplu, '$(word 2, foo bar baz)' produce 'bar';

$(wordlist s,e,text)
  produce lista cuvintelor din text de la cuvantul nr. s (>= 1)
    la cuvantul nr. e (>= 0); daca s > e sau s > numarul de cuvinte
    din text, valoarea este vida; daca e >  numarul de cuvinte din text,
    lista produsa se termina la sfarsitul textului;
  de exemplu, '$(wordlist 2, 3, foo bar baz)' produce 'bar baz';

$(words text)
  produce numarul de cuvinte din text (string de cifre zecimale);
  astfel, '$(word $(words text),text)' este ultimul cuvant din text;

$(firstword names...)
  produce primul nume din lista 'names' (lista de nume separata prin spatii);
  efectul este similar cu '$(word 1,text)';
  de exemplu, '$(firstword foo bar)' produce 'foo';

$(lastword names...)
 produce ultimul nume din lista 'names' (lista de nume separata prin spatii);
 efectul este similar cu '$(word $(words text),text)';
 de exemplu, '$(lastword foo bar)' produce 'bar';

O aplicatie utila a lui 'subst' si 'patsubst' este urmatoarea:
De obicei, 'Makefile' utilizeaza variabila 'VPATH' pentru a specifica lista
  directoarelor in care trebuie cautate fisierele-dependinta; este o lista de
  directoare separate prin ':', de exemplu 'src:../headers';
Daca dorim sa comunicam compilatorului de C sa caute fisierele header in
  aceeasi lista de directoare, mai intai folosim '$(subst :, ,$(VPATH))'
  pentru a inlocui caracterele ':' cu ' ' si obtinem 'src ../headers', apoi
  folosim '$(patsubst %,-I%,$(subst :, ,$(VPATH)))' pentru a inlocui fiecare
  director cu varianta sa prefixata cu '-I', apoi concatenam rezultatul
  la variabila 'CFLAGS', care este transmisa automat compilatrului de C:

override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))

  efectul este concatenarea la valoarea precedenta a lui 'CFLAGS' a textului
  '-Isrc -I../headers';
directiva 'override' face ca noua valoare sa fie asignata chiar daca vechea
  valoare a lui 'CFLAGS' a fost specificata printr-un argument al liniei de
  comanda.


2.9.2. Functii pentru fisiere:
------------------------------

  Prezentam cateva functii predefinite pentru nume de fisiere.
  Fiecare dintre functiile urmatoare are ca argument o lista de nume de
fisiere separate prin spatii (spatiile de la inceput si sfarsit sunt ignorate);
fiecare nume este transformat in acelasi mod iar rezultatele sunt concatenate
cu cate un caracter spatiu ca separator; prin nume de fisier intelegem, de
fapt, un specificator, care poate contine si cale (pathname).

$(dir names...)
  extrage partea-director din fiecare nume (pana la ultimul '/',
    incusiv); daca numele nu contine '/', partea-director este './';
  de exemplu, '$(dir src/foo.c hacks)' produce 'src/ ./';

$(notdir names...)
  extrage totul in afara de partea-director din fiecare nume; daca
    numele nu contine '/', este lasat neschimbat; un nume care se
    termina cu '/' devine stringul vid (ceea ce inseamca ca rezultatul
    va fi o lista cu mai putine cuvinte);
  de exemplu, '$(notdir src/foo.c hacks)' produce 'foo.c hacks';

$(suffix names...)
  extrage sufixul din fiecare nume (partea de la ultimul '.' la sfarsit);
    daca numele nu contine '.', este sirul vid (ceea ce inseamca ca
    rezultatul va fi o lista cu mai putine cuvinte);
  de exemplu, '$(suffix src/foo.c src-1.0/bar.c hacks)' produce '.c .c';

$(basename names...)
  extrage totul in afara de sufix din fiecare nume; caraterele '.' din
    partea-director sunt ignorate; daca nu exista '.', ramane tot numele;
  de exemplu, '$(basename src/foo.c src-1.0/bar hacks)' produce
    'src/foo src-1.0/bar hacks';

$(addsuffix suffix,names...)
  concateneaza 'suffix' la sfarsitul fiecarui nume din 'names';
  de exemplu, '$(addsuffix .c,foo bar)' produce 'foo.c bar.c';

$(addprefix prefix,names...)
  concateneaza 'prefix' la inceputul fiecarui nume din 'names';
  de exemplu, '$(addprefix src/,foo bar)' produce 'src/foo src/bar';

$(join list1,list2)
  concateneaza argumentele cuvant cu cuvant; daca un argument are mai multe
    cuvinte decat celalalt, cuvintele suplimentare sunt copiate fara
    modificare in rezultat;
  de exemplu, '$(join a b,.c .o)' produce 'a.c b.o';
  tot ca exemplu, putem imbina rezultatele functiilor 'dir' si 'notdir'
   pentru a produce lista originala de fisiere;

$(wildcard pattern)
  argumentul 'pattern' este un tipar de nume de fisier, de obicei continand
    caracter wildcard, ca in comenzile shell;
  functia produce lista numelor fisierelor existente si care se potrivesc
    cu tiparul, separate prin spatii;

$(realpath names...)
  pentru fiecare nume din 'names' produce calea absoluta canonica
    (un specificator canonic nu contine componente '.' sau '..', nu
    contine '/' repetate, nu contine legaturi simbolice); in cazul
    unui esec (de exemplu, fisier inexistent), este furnizat sirul vid;

$(abspath names...)
  pentru fiecare nume din 'names' produce o cale absoluta ce nu contine
    componente '.' sau '..' si nici '/' repetate; nu sunt rezolvate
    legaturile simbolice si nu este necesar ca fisierele sa existe.


2.9.3. Functii conditionale, functia 'foreach', functia 'shell':
----------------------------------------------------------------

  Prezentam cateva functii predefinite conditionale.
  Un aspect important in legatura cu aceste functii este ca nu toate
argumentele sunt expandate initial; vor fi expandate doar argumentele
necesare. Astfel, sunt evitate si efectele laterale (side-effects),
cum ar fi apelurile de functii shell, asociate cu argumentele neexpandate.

$(if condition,then-part[,else-part])
  argumentului 'condition' i se elimina spatiile de la inceput si sfarsit,
    apoi este expandat; daca este expandat la un string nevid, conditia
    este considerata true, altfel este considerata false;
  daca conditia este true, argumentul 'then-part' este evaluat iar
    rezultatul devine valoarea produsa de functie (nu se mai evalueaza
    'else-part');
  daca conditia este false, argumentul 'else-part' este evaluat iar
    rezultatul devine valoarea produsa de functie (nu se mai evalueaza
    'then-part'); in acest caz, daca nu este dat al treilea argument,
    valoarea produsa de functie este stringul vid;

$(and condition1[,condition2[,condition3...]])
  argumentele sunt expandate in ordine;
  daca un argument s-a expandat la stringul vid, procesarea se opreste
    (nu se mai expandeaza argumentele urmatoare) iar functia produce
    stringul vid;
  daca toate argumentele s-au expandat la stringuri nevide, functia
    produce stringul rezultat din expandarea ultimului argument;

$(or condition1[,condition2[,condition3...]])
  argumentele sunt expandate in ordine;
  daca un argument s-a expandat la un string nevid, procesarea se opreste
    (nu se mai expandeaza argumentele urmatoare) iar functia produce
    stringul rezultat din expandarea acestui argument;
  daca toate argumentele s-au expandat la stringuri vide, functia
    produce stringul vid;

$(intcmp lhs,rhs[,lt-part[,eq-part[,gt-part]]])
  argumentele 'lhs' si 'rhs' sunt expandate si interpretate ca numere
    intregi scrise in baza 10; expandarea argumentelor ramase depinde
    de rezultatul comparatiei aritmetice intre aceste numere;
  daca nu mai sunt argumente, functia produce fie stringul vid, daca
    numerele sunt diferite, fie valoarea comuna a numerelor (ca string
    zecimal), daca numerele sunt egale;
  altfel, dupa cum numerele sunt in relatia '<', '=', '>', este expandat
    si produs de functie ca valoare (doar) argumentul 'lt-part', 'eq-part',
    respectiv 'gt-part';
  daca lipseste 'gt-part', el este considerat implicit 'eq-part'; daca
    lipseste 'eq-part', el este considerat implicit stringul vid;
  de exemplu, atat '$(intcmp 9,7,hello)' cat si '$(intcmp 9,7,hello,world,)'
    se evalueaza la stringul vid, in timp ce '$(intcmp 9,7,hello,world)'
    (notam absenta virgulei dupa 'world') se evalueaza la 'world'.

Exemplul 34 (preluat de la [3]):
===========

$cat Makefile
foo := $(if this-is-not-empty,then!,else!)
empty :=
bar := $(if $(empty),then!,else!)

all:
	@echo $(foo)
	@echo $(bar)
$make
then!
else!


  O alta functie predefinita utila este cea care simuleaza 'for':

$(foreach var,list,text)
  argumentele 'var' si 'list' sunt expandate inainte de a se efectua
    altceva; argumentul 'text' nu este expandat in acest moment;
  atunci, pentru fiecare cuvant din valoarea expandata a lui 'list',
    variabila numita prin valoarea expandata a lui 'var' este asignata
    cu acel cuvant iar 'text' este expandat; daca 'text' continea
    referinte la acea variabila, expandarea lui va fi diferita de
    fiecare data;
  asadar, 'text' este expandat de atatea ori cate cuvinte separate
    prin spatii sunt in 'list'; toate aceste expandari sunt concatenate
    cu spatii intre ele, obtinand rezultatul produs de functia 'foreach';

  Exemplul urmator asigneaza variabila 'files' cu lista tuturor
fisierelor din directoarele prezente in 'list':

dirs := a b c d
files := $(foreach dir,$(dirs),$(wildcard $(dir)/*))

aici, 'text' este '$(wildcard $(dir)/*)'; prima repetitie  asigneaza lui
'dir' valoarea 'a' si produce un rezultat similar ca '$(wildcard a/*)’;
a doua repetitie produce un rezultat similar ca '$(wildcard b/*)' iar
a treia repetitie produce un rezultat similar ca '$(wildcard c/*)'.
  Puteam obtine aceesi valoare pentru 'files' scriind:

files := $(wildcard a/* b/* c/* d/*)

  Puteam creste lizibilitatea textului folosind o variabila suplimentara:

find_files = $(wildcard $(dir)/*)
dirs := a b c d
files := $(foreach dir,$(dirs),$(find_files))

notam ca a trebuit sa definim 'find_files' folosind '='
(recursively-expanding variable), nu ':=', deoarece valoarea sa
contine un apel de functie care trebuie re-expandat sub controlul lui
'foreach'; daca am fi folosit ':=' (simply-expanded variable), nu s-ar
fi intamplat asta, deoarece 'wilcard' ar fi fost apelata doar o data,
la momentul definirii variabilei 'find_files'.

Functia 'foreach' nu are efect permanent asupra variabilei 'var'; ea
ramane cum era si inainte de 'foreach' (nedefinita sau avand aceeasi
valoare). In timpul lui 'foreach', variabila 'var' este simply-expanded.

Exemplul 35 (preluat de la [3]):
===========

$cat Makefile
foo := who are you
# For each "word" in foo, output that same word with an exclamation after
bar := $(foreach wrd,$(foo),$(wrd)!)

all:
	# Output is "who! are! you!"
	@echo $(bar)
$make
# Output is "who! are! you!"
who! are! you!


  O alta functie predefinita utila este cea cu care putem invoca comenzi
shell si prelua outputul acestora:

$(shell command)
  lanseaza un proces shell care executa comanda 'commad', preia informatia
    afisata de aceasta pe stdout, construieste din ea un string, si il
    furnizeaza ca rezultat; in stringul respectiv, insa, fiecare newline
    este inlocuit cu cate un caracter spatiu iar daca este un newline la
    sfarsit, el este eliminat;
  comanda 'command' este executata de fiecare data cand apelurile functiei
    'shell' sunt expandate; avand in vedere ca de fiecare data se lanseaza
    un nou shell, aceasta poate afecta performanta daca folosim functia
    'shell' in variabile recursively expanded vs. simply expanded;
  in urma utilizarii functiei 'shell', este plasat un exit status in
    variabila predefinita '.SHELLSTATUS';
  de exemplu:
        files := $(shell echo $(wildcard *.txt))
    pune in variabila 'files' lista tuturor fisierelor cu extensia '.txt' din
    directorul curent;
  variabilele marcate cu 'export' sunt transmise si shell-ului lansat de
    functia 'shell'; de exemplu:
        export HI = $(shell echo hi)
        all: ; @echo $$HI
    afisaza 'hi'; aparent, este o recursie infinita, deoarece la executarea
    recipe-ului '@echo $$HI' intr-un nou proces shell trebuie adaugata
    variabila 'HI' la environmentul acelui shell, pentru aceasta 'HI'
    trebuie expandata, iar expandarea apeleaza functia 'shell' care
    va lansa un alt proces shell, pentru care, de asemenea, trebuie
    adaugata variabila 'HI' la environment, etc; intr-un asemenea caz insa,
    se va folosi valoarea variabilei din environmentul primit de 'make' la
    lansare (care poate fi stringul vid, daca nu exista o asemenea variabila);
    uneori, chiar asta se doreste, de exemplu:
        export PATH = $(shell echo /usr/local/bin:$$PATH)


2.9.4. Functii definite de utilizator:
--------------------------------------

  Putem defini functii utilizator cu parametri, astfel:

- se defineste o variabila care va fi numele functiei si in a carei descriere
 a valorii putem folosi de 0 sau mai multe ori constructii de forma '$(nr)',
 unde 'nr' este un numar 0, 1, 2, etc.;

- functia se apelaza dupa sintaxa:

$(call variable,param1,param2,...)

  unde 'variable' este numele functiei iar 'param1', ... argumente;
    se vor considera variabilele temporare '$(0)', '$(1)', '$(2)', ...
    si se vor asigna respectiv cu 'variable', 'param1', 'param2', ...;
    apoi, 'variable' este expandata in contextul acestor asignari temporare,
    deci orice referinta la '$(1)' in valoarea lui 'variable' se va rezolva
    prin 'param1', etc.; apelul produce rezultatul acestei expandari;
  daca 'variable' este numele unei functii predefinite, se invoca functia
    predefinita;
  argumentele 'param1', 'param2', ... sunt expandate inainte de a fi asignate
    variabilelor temporare.

  Un exemplu simplu de macro, care isi inverseaza argumentele, este urmatorul:

        reverse = $(2) $(1)
        foo = $(call reverse,a,b)

variabila 'foo' va contine 'b a'.


  Un exemplu mai interesant este un macro care cauta prima aparitie a unui
program in 'PATH':

        pathsearch = $(firstword $(wildcard $(addsuffix /$(1),$(subst :, ,$(PATH)))))
        LS := $(call pathsearch,ls)

variabila 'LS' va contine '/bin/ls' sau ceva similar; notam ca daca am fi definit
'pathsearch := ...', atunci s-ar fi facut expandarea la momentul definirii, cu
'$(1)' avand valoarea stringul vid iar rezultatul ar fi fost primul director din
'PATH' (fara legatura cu programul cautat 'ls').

  Notam ca, la fel ca si in cazul altor functii, spatiile continute in argumentul
al doilea si in cele urmatoare ale lui 'call' sunt pastrate.

Exemplul 36 (adaptat de la [3]):
===========

$cat Makefile
sweet_new_fn = Variable Name: $(0) First: $(1) Second: $(2) Empty Variable: $(3)
all:
	@echo -'$(call sweet_new_fn, go, tigers)'-
$make
-Variable Name: sweet_new_fn First:  go Second:  tigers Empty Variable: -


2.10. Alte facilitati: fisiere incluse ('include'), directoare de dependinte
----------------------------------------------------------------------------
('vpath'), tinte false ('.PHONY'), stergerea la eroare ('.DELETE_ON_ERROR'),
----------------------------------------------------------------------------
setarea caracterului prefix ('.RECIPEPREFIX'):
---------------------------------------------

 Prezentam alte cateva facilitati legate de utilitarul 'make' si fisierele
'Makefile':


 Putem folosi directiva 'include' pentru a include alte fisiere 'Makefile'.

include filenames...

Aceasta este utila atunci cand folosim 'gcc' cu optiunea '-M' pentru a
crea un fisier 'Makefile' pe baza sursei. Intr-adevar, cu aceasta optiune,
'gcc' in loc sa output-eze rezultatul preprocesarii, output-eaza o
regula 'Makefile' care descrie dependentele sursei principale; regula
contine numele fisierului sursa, apoi ':', apoi numele tuturor fisierelor
cerute de aceasta cu '#include', inclusiv cele provenind din optiunile
liniei de comanda 'gcc', ca '-include'.


  Putem folosi directiva 'vpath' pentru a specifica directoare unde trebuie
cautate anumite dependinte:

vpath <pattern> <directories, space/colon separated>

<pattern> poate contine un '%', care se potriveste cu orice sir de 0 sau mai
multe caractere.
 Putem realiza acest lucru global si folosind variabila 'VPATH'.

Exemplul 37 (preluat de la [3]):
===========

$cat Makefile
vpath %.h ../headers ../other-directory
# Note: vpath allows blah.h to be found even though
# blah.h is never in the current directory
some_binary: ../headers blah.h
	touch some_binary
../headers:
	mkdir ../headers
# We call the target blah.h instead of ../headers/blah.h,
# because that's the prereq that some_binary is looking for
# Typically, blah.h would already exist and you wouldn't need this.
blah.h:
	touch ../headers/blah.h
clean:
	rm -rf ../headers
	rm -f some_binary
$make
mkdir ../headers
touch ../headers/blah.h
touch some_binary
$make clean
rm -rf ../headers
rm -f some_binary


  Exista nume de target-uri predefinite speciale, ca '.PHONY' si
'.DELETE_ON_ERROR'.

  Uneori dorim sa specificam target-uri care sa nu corespunda unor
fisiere si care sa fie actualizate (sa se execute recipe-urile) de
fiecare data cand o cerem; actualizarea lor ar putea fi insa impiedicata
de existenta accidentala a unui fisier cu numele respectiv.
  De exemplu dorim sa avem target-ul pentru facut curat:

clean:
	rm -f *.o

si de fiecare data cand executam 'make clean' sa se execute 'rm -f *.o'.
Daca, intamplator, exista in directorul curent un fisier numit 'clean',
atunci la 'make clean' nu o sa se execute 'rm -f *.o', deoarece target-ul
exista si nu are dependinte mai noi decat el (de fapt, nu are dependinte
deloc) - deci, va fi considerat up to date.
  Pentru a preveni aceasta, putem declara 'clean' ca dependinta
pentru target-ul special '.PHONY' (i.e. il facem target fals):

.PHONY: clean
clean:
	rm -f *.o

Atunci, 'make clean' va actualiza 'clean' (va rula 'rm -f *.o') indiferent
daca exista sau nu un fisier 'clean'.
  Putem declara mai multe target-uri ca dependinte la '.PHONY' ('all',
'clean', 'install', etc.) iar acestea pot avea, la randul lor, dependinte.

  In general, daca o comanda recipe esueaza si se termina cu un exit status
nenul, 'make' se opreste; intre timp insa, target-ul regulii poate a apucat
sa se modifice, dar modificarea nu este completa sau cu sens, deoarece nu
s-au executat toate recipe-urile.
  Daca '.DELETE_ON_ERROR' este mentionat ca target oriunde in 'Makefile',
atunci 'make' va elimina (delete) target-ul unei reguli daca el s-a modificat
iar recipe-ul sau se termina cu un exit status nenul.

Exemplul 38 (preluat de la [3]):
===========

$ls
Makefile
$cat Makefile
.DELETE_ON_ERROR:
all: one two
one:
	touch one
	false
two:
	touch two
	false
$make
touch one
false
make: *** [Makefile:5: one] Error 1
make: *** Deleting file 'one'
$ls
Makefile

Comentariu: comanda shell 'false' nu face nimic, dar returneaza un exit
 code nenul (esec); observam (la 'ls') ca nu a fost pastrat fisierul 'one',
 care a apucat sa fie creat inainte de esecul 'false'.


 Putem asigna variabila speciala '.RECIPEPREFIX' cu o valoare a carei
prim caracter va fi folosit in continuare pentru a introduce liniile recipe.
Daca variabila e vida (asa cum este in mod implicit) acest caracter este
caracterul TAB. De exemplu:

.RECIPEPREFIX = >
all:
> @echo Hello, world

Valoarea lui '.RECIPEPREFIX' poate fi schimbata de mai multe ori; o data
setata, isi pastreaza efectul pentru toate regulile interpretate, pana cand
este modificata.

Exemplul 39:
============

$cat Makefile
all: a b c

a:
	@echo comanda prefixata cu TAB
	@echo alta comanda prefixata cu TAB

.RECIPEPREFIX=1
b:
1@echo comanda prefixata cu 1
1@echo alta comanda prefixata cu 1

.RECIPEPREFIX=
c:
	@echo comanda prefixata cu TAB

$make
comanda prefixata cu TAB
alta comanda prefixata cu TAB
comanda prefixata cu 1
alta comanda prefixata cu 1
comanda prefixata cu TAB

Notam ca daca am fi incercat sa setam ca prefix caracterul blank folosind
schema de mai sus, ar fi aparut probleme:

$cat Makefile
nimic:=
.RECIPEPREFIX=$(nimic) #
all:
 @echo comanda prefixata cu blank

$make
Makefile:4: *** missing separator.  Stop.

Intr-adevar, spatiul de la inceputul liniei recipe este eliminat de 'make',
a.i. ulterior nu mai este gasit la inceputul liniei caracterul prefix.


2.11. Optiuni in linia de comanda si coduri de retur ale lui 'make':
--------------------------------------------------------------------

 Prezentam cateva optiuni uzuale ale comenzii 'make':

 -B
  neconditionat, proceseaza toate target-urile;

 -C dir
  schimba directorul curent in 'dir' inainte de a citi fisierul 'Makefile'
  sau a efectua altceva; daca sunt prezente mai multe optiunhui '-C', fiecare
  este interpretata relativ la precedenta, de exemplu '-C / -C etc' este
  echivalent cu '-C /etc'; se foloseste de obicei la invocarea recursiva a
  lui 'make';

 -d
  in plus fata de procesarea normala, afisaza informatii suplimentare
  utile pentru depanare;

 -e
  variabilele de environment au precedenta fata de variabilele din
  'Makefile';

 -f file
  foloseste fisierul 'file' ca 'Makefile'

 -i
  ignora erorile din comenzile executate pentru a procesa fisierele

 -I dir
  specifica directorul 'dir' pentru a cauta fisierele 'Makefile' incluse;
  daca sunt prezente mai multe optiuni '-I', directoarele sunt scanate in
  ordinea specificarii; se poate scrie si '-Idir' (fara blank);

 -jnr
  specifica numarul maxim 'nr' de job-uri (recipe-uri) care se pot rula
  simultan; implicit, numarul este 1; daca sunt prezente mai multe optiuni
  '-j', este luata in considerare ultima; 'nr' poate lipsi si atunci 'make'
  nu va limita numarul de job-uri care se pot rula simultan; cand 'make'
  invoca un sub-'make', toate instantele lui 'make' se vor coordona pentru
  a rula numarul specificat de joburi la un moment dat; de exemplu, daca
  hard-ul are un procesor cu 4 core, putem adauga comenzilor 'make' optiunea
  '-j4' sau '-j' pentru a mari viteza de procesare;

 -n
  afisaza comenzile de executat, fara sa le execute (cu anumite exceptii);

 -o file
  nu este procesat fisierul 'file', chiar daca este mai vechi decat
  dependintele sale si nu proceseaza ceea ce depinde de 'file' (ideea este
  ca 'file' este tratat ca foarte vechi si regulile sale sunt ignorate);

 -p
  afisaza baza de date (reguli si valori de variabile) care rezulta din
  citirea fisierelor 'Makefile', apoi se executa; daca se doreste
  afisarea bazei de date fara a se procesa vreun fisier, se poate folosi
  'make -p -f/dev/null';

 -q
  nu ruleaza comenzi si nu afisaza nimic, doar furnizeaza ca cod de retur
  (exit status) 0 / non 0 dupa cum target-urile specificate sunt sau nu
  la zi (up to date);

 -r
  elimina folosirea regulilor implicite built-in si sterge lista implicita
  de sufixe pentru regulile referitoare la sufixe;

 -R
  nu defineste variabile built-in;

 -s
  nu afisaza comenzile inainte de a le executa (silent);

 -t
  touch files (actualizeaza momentul ultimei modificari a fisierelor, fara sa
  le modifice) in loc sa ruleze comenzile asociate; e un mod de a pretinde ca
  respectivele comenzi au fost executate, pentru a pacali viitoarele invocari
  ale lui 'make';

 --trace
  afisaza motivele pentru care un target este procesat si ce comenzi sunt
  folosite in acest scop;

 -v
  afisaza versiunea 'make';

 -W file
  pretinde ca 'file' tocmai a fost modificat; in combinatie cu '-n',
  aceasta ne va arata ce s-ar intampla daca s-ar modifica 'file';
  fara '-n', efectul este asemanator ca si cand am fi efectuat 'touch file'
  inainte de 'make', doar ca momentul ultimei modificari a fisierului nu
  este schimbat de fapt.

Comanda 'make' furnizeaza un cod de retur (exit status) care este:
 0, daca toate fisierele 'Makefile' au fost parsate cu succes si
    nici un target procesat nu  esuat;
 1, daca a fost folosita optiunea '-q' si 'make' determina ca un target
    necesita reconstruirea;
 2, in cazul intalnirii unei erori.


2.12. Teme propuse:
-------------------

1. Definiti o functie 'make' care sa adune o lista de numere intregi.
   Se poate folosi comanda shell 'expr', care permite evaluarea unor
  expresii simple.

2. Definiti o functie care sa numere cate obiecte ale sistemului de
  fisiere sunt intr-o arborescenta.

3. Implementati cateva dintre functiile pentru nume de fisiere ('dir',
  'suffix', etc.) prin functii pentru stringuri.

4. Scrieti un 'Makefile' pentru dezvoltarea iterativa a unui program:
  se lanseaza un editor pentru el, apoi se lanseaza gcc pentru compilare,
  daca a semnalat erori (cod de retur nenul, furnizat in variabila
  '.SHELLSTATUS') atunci se lanseaza iar editorul, altfel se lanseaza
  programul.

5. Scrieti un 'Makefile' care sa functioneze ca un meniu interactiv
  pentru executarea unor comenzi. Citirea interactiva a optiunior se
  poate face cu comanda shell 'read var...' (care citeste o linie,
  o imparte in cuvinte si asigneaza cuvintele variabilelor shell
  date ca argument). De exemplu, putem asigna o variabila 'Makefile'
  interactiv prin:
    y=$(shell read x ; echo $$x)
  Obs: daca vrem sa citim un text mai lung, inlocuind insa toate newline
  interioare cu blank si incheind introducerea cu Ctrl-D, putem folosi:
    y=$(shell cat)


3. Depanarea aplicatiilor cu gdb:
=================================

Referinte:
https://sourceware.org/gdb/current/onlinedocs/gdb


3.1. Comenzi uzuale, inspectarea stivei, consultarea/setarea variabilelor,
--------------------------------------------------------------------------
executarea continua automata (skip), argumente in linia de comanda,
-------------------------------------------------------------------
environment, directoare de cautare:
-----------------------------------

 Depanarea programelor in Linux se face cu gdb. Are o interfata in mod
linie de comanda, asemanatoare cu cea a unui shell.
 La compilarea cu gcc, daca vrem sa investigam ulterior executabilul
cu gdb, vom folosi optiunile '-g' sau '-ggdb' pentru a include in acesta
informatii auxiliare; '-ggdb' foloseste un format mai expresiv; in
absenta acestor optiuni, investigarea ramane posibila, dar mai sumar.

 Depanarea unui executabil 'fisier' se lanseaza cu:

gdb fisier

Depanatorul afisaza un prompter propriu:

(gdb)

pe care se pot da linii de comanda specifice. Sunt suportate anumite
facilitati de operare intalnite la programele shell, ca: autocompletarea
liniei de comanda cu TAB, istoricul comenzilor, accesibil sageti verticale.
Simpla apasarea a lui ENTER determina repetarea ultimei comenzi.

Cateva comenzi gdb (partea dintre '()' se poate omite din scriere):

h(elp)
h(elp) comanda
  ==> afisaza informatii generale/informatii despre comanda 'comanda';
      comanda se poate scrie si prescurtat;

q(uit)
  ==> iesire din gdb;

file fisier
  ==> incarca fisierul 'fisier' (in locul celui curent);
      gdb se poate lansa si fara a indica un fisier, iar acesta se poate
    incarca ulterior cu 'file';
      daca nu specificam un director si fisierul nu este gasit in directorul
    curent, gdb foloseste valoarea variabilei de environment 'PATH' ca lista
    de directoare pentru cautare (similar cu shell-ul); putem schimba
    valoarea acestei variabile, atat pentru gdb cat si pentru programul
    rulat, folosind comanda 'path';

file
 ==> descarca informatiile despre fisierul rulat;

l(ist)
  ==> afisaza inca 10 linii aflate dupa sau in jurul ceea ce a afisat
    anterior;

l(ist) -
  ==> afisaza 10 linii aflate inaintea unei afisari anterioare de 10 linii;

l(ist) nr
  ==> afisaza 10 linii in jurul liniei cu numarul 'nr';

l(ist) nr1,nr2
  ==> afisaza liniile cu numerele de la 'nr1' la 'nr2';

l(ist) functie
  ==> afisaza 10 linii in jurul inceputului functiei cu numele 'functie';

set args argument1 argument2 ... argumentn
  ==> specifica argumentele in linia de comanda (chiar si nici unul)
    cu care se va rula programul depanat atunci cand este pornit;

show args
  ==> afisaza argumentele in linia de comanda curent setate;

set environment variabila valoare
  ==> atribuie valoarea 'valoare' variabilei de environment 'variabila'
    a programul depanat; 'valoare' un string oarecare (poate fi vid);
      aceasta nu va afecta programul pana la urmatoarea comanda 'run';

unset environment variabila
  ==> elimina variabila 'variabila' din environment-ul curent setat;
      aceasta nu va afecta programul pana la urmatoarea comanda 'run';

r(un)
r(un) argumente
  ==> incepe rularea (continua a) programului depanat, de la inceput;
      'argumente', daca este prezent, este o lista de argumente in linia
    de comanda cu care se va rula programul (succesiune de stringuri
    separate prin blank-uri); lista poate contine inclusiv redirectari
    '>', '>>', '<';
      daca 'argumente' lipseste, se vor folosi ultimele argumente
    specificate anterior cu 'run' sau 'set args'; pentru anularea folosirii
    vechilor argumente se foloseste 'set args' fara argumente;

star(t)
  ==> ruleaza programul pana la inceputul lui 'main()' (dupa care intra in
    regim pas cu pas);
      se pot specifica argumente in linia de comanda ca la 'run';

s(tep)
  ==> executa instructiunile de pe linia curenta, pana la noua linie ce
    trebuie executata; daca se intalneste un apel de functie, ea este supusa
    aceleiasi detalieri pas cu pas (deci executia se poate opri la prima
    linie a functiei);

s(tep) nr
  ==> executa de 'nr' ori 'step' (sau pana cand programul se opreste din
    alte cauze);

stepi
  ==> executa step pentru exact o instructiune (deci, daca o linie contine
    mai multe instructiuni, parcurgerea ei necesita mai multe 'stepi');
      atentie: este vorba de o instructiune masina, nu instructiune C;
      'stepi' se poate prescurta 'si';

stepi nr
  ==> executa de 'nr' ori 'stepi' (sau pana cand programul se opreste din
    alte cauze); 'stepi' se poate prescurta 'si';

n(ext)
  ==> asemanator cu 'step', dar daca se intalneste un apel de functie ea nu
    este supus detalierii pas cu pas (functia se executa ca si cand ar fi o
    singura instructiune);

n(ext) nr
  ==> executa de 'nr' ori 'next' (sau pana cand programul se opreste din
    alte cauze);

nexti
  ==> executa 'next' pentru exact o instructiune (masina, nu C);
      'nexti' se poate prescurta "ni";

nexti nr
  ==> executa de 'nr' ori 'nexti' (sau pana cand programul se opreste din
    alte cauze); 'nexti' se poate prescurta 'ni';

fin(ish)
  ==> executa 'next' pana la sfarsitul functiei curente (iar atunci valoarea
    returnata este afisata si adaugata la istoricul valorilor);

c(ontinue)
  ==> continua executia normala (continua) a programului, pana ce programul
    se opreste din diverse cauze sau pana la intalnirea unui breakpoint;
      daca executia normala s-a reluat de la un breakpoint, se poate folosi
    un argument nr, care va determina setarea contorului de ignorare al
    breakpoint-ului la nr-1 (a.i. breakpoint-ul nu va intrerupe rularea
    decat a nr-a oara cand este intalnit);

j(ump) nr
  ==> sare pana la linia cu numarul 'nr' (fara a executa instructiunile
    intermediare si ruleaza (continuu) programul de acolo in continuare;

k(ill)
  ==> abandoneaza executia curenta a programului (se poate incepe alta
    cu 'run');

backtrace
backtrace full
backtrace -nr
backtrace full -nr
backtrace -nr full
  ==> afisaza cadrele de apel ale tuturor apelurilor de functii aflate in
    curs (incepute si inca neterminate) din stiva; ordinea este de la
    ultimul apel inceput (varful stivei) spre inapoi;
      ca terminologie: in stiva, "jos" inseamna spre varf iar "sus" spre
    baza; cu cat se merge in jos, sunt apeluri mai recente; ultimul apel
    inceput este jos de tot, in varful stivei; "dedesubt" inseamna mai jos,
    deci mai recent, "deasupra" inseamna mai sus, deci mai vechi;
      cu 'full' se afisaza si valorile variabilelor locale corespunzatoare
    apelurilor respective;
      cu '-nr' afisaza cel mult -nr cadre;
      'backtrace' se poate prescurta 'bt';

Cu urmatoarele comenzi putem selecta un cadru aflat in stiva; el devine
tinta implicita a anumitor comenzi, daca nu specificam altceva; acest
cadru va fi numit cadrul 'curent selectat':

do(wn)
do(wn) nr
  ==> selecteaza si afisaza cadrul pe care l-a apelat cadrul curent
    selectat (practic este cadrul aflat imediat dedesubtul celui curent
    selectat);
      cu 'nr' este vorba de cadrul aflat cu 'nr' niveluri mai jos de
    cel curent selectat;

up
up nr
  ==> selecteaza si afisaza cadrul care a apelat cadrul curent
    selectat (practic este cadrul aflat imediat deasupra celui curent
    selectat);
      cu 'nr' este vorba de cadrul aflat cu 'nr' niveluri mai sus de
    cel curent selectat;

sel(ect-frame) nr
  ==> selecteaza cadrul cu numarul 'nr' (in loc de numar se poate da si
    adresa cadrului) fara sa afiseze ceva;

f(rame)
f(rame) nr
  ==> fara argument, afisaza cadrul curent selectat; cu argument 'nr'
   selecteaza si afisaza cadrul cu numarul respectiv (in loc de numar se
   poate da si adresa cadrului);

ret(urn)
ret(urn) expresie
  ==> determina cadrul curent selectat sa execute return catre apelantul
   sau (executia ramane in regim pas cu pas, dar la urmatorul pas se va
   executa ceva din cadrul aflat deasupra celui curent selectat);
     daca este prezenta, expresia precizeaza valoarea returnata in apelant;

p(rint) expresie
  ==> afisaza valoarea expresiei la momentul curent;
      expresia poate sa nu apara ca atare in program, dar sa aibe sens
    in acel punct;
      expresia poate fi '$nr' si atunci este a nr-a valoare afisata deja;
      expresia poate fi '$' sau '$$' si atunci este ultima/penultima valoare
    afisata;

info r(egs)
  ==> afisaza valorile curente ale registrilor intregi;


x/format adresa
  ==> afisaza continutul memoriei, incepand de la adresa 'adresa';
      'format' este format din urmatoarele constructii (lipite intre ele):
          un numar de repetari;
          o litera care specifica formatul de afisare:
               o(octal), x(hex), d(decimal), u(unsigned decimal),
               t(binary), f(float), a(address), i(instruction),
               c(char) si s(string);
          o litera care specifica cantitatea repetata:
               b(byte), h(halfword), w(word), g(giant, 8 bytes);
   efectul este afisarea conform formatului specificat a numarului
   specificat de obiecte de dimensiunea specificata, incepand de la 'adresa';

Observatii: un program incarcat in gdb si aflat in rulare normala (continua)
  se poate intrerupe (si trece in rulare pas cu pas) cu Ctrl-C.


Exemplul 1:
===========

$ls
f1.c
$cat f1.c
#include<stdio.h>
int fct(int x){
  int y;
  y=x+1; y=x+2; y=x+3;
  y=x+4;
  y=x+5;
  return y;
}
int main(){
  int i;
  i=10; printf("%d\n",i);
  i=20; printf("%d\n",i);
  i=30; printf("%d\n",i);
  i=40; printf("%d\n",i);
  i=50; printf("%d\n",i);
  while(1){
    i=1; i=2; i=fct(100); i=3; i=4;
    i=10; i=20; i=fct(1000); i=30; i=40;
  }
  i=100; i=200; printf("%d\n",i); i=300; i=400;
  i=1000; i=2000; printf("%d\n",i); i=3000; i=4000;
  return 0;
}

$gcc -o p1 -ggdb f1.c
$gdb p1
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
 ...
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from p1...
(gdb) l
1	#include<stdio.h>
2	int fct(int x){
3	  int y;
4	  y=x+1; y=x+2; y=x+3;
5	  y=x+4;
6	  y=x+5;
7	  return y;
8	}
9	int main(){
10	  int i;
(gdb) l
11	  i=10; printf("%d\n",i);
12	  i=20; printf("%d\n",i);
13	  i=30; printf("%d\n",i);
14	  i=40; printf("%d\n",i);
15	  i=50; printf("%d\n",i);
16	  while(1){
17	    i=1; i=2; i=fct(100); i=3; i=4;
18	    i=10; i=20; i=fct(1000); i=30; i=40;
19	  }
20	  i=100; i=200; printf("%d\n",i); i=300; i=400;
(gdb) l
21	  i=1000; i=2000; printf("%d\n",i); i=3000; i=4000;
22	  return 0;
23	}
24
(gdb) l
Line number 25 out of range; f1.c has 24 lines.
(gdb) l 1,24
1	#include<stdio.h>
2	int fct(int x){
3	  int y;
4	  y=x+1; y=x+2; y=x+3;
5	  y=x+4;
6	  y=x+5;
7	  return y;
8	}
9	int main(){
10	  int i;
11	  i=10; printf("%d\n",i);
12	  i=20; printf("%d\n",i);
13	  i=30; printf("%d\n",i);
14	  i=40; printf("%d\n",i);
15	  i=50; printf("%d\n",i);
16	  while(1){
17	    i=1; i=2; i=fct(100); i=3; i=4;
18	    i=10; i=20; i=fct(1000); i=30; i=40;
19	  }
20	  i=100; i=200; printf("%d\n",i); i=300; i=400;
21	  i=1000; i=2000; printf("%d\n",i); i=3000; i=4000;
22	  return 0;
23	}
24
(gdb) s
The program is not being run.
(gdb) r
Starting program: /home/dragulici/Desktop/.../work/p1
10
20
30
40
50
^C
Program received signal SIGINT, Interrupt.   /* am tastat Ctrl-C */
0x0000555555555169 in fct (x=100) at f1.c:4
4	  y=x+1; y=x+2; y=x+3;
(gdb) s
5	  y=x+4;
(gdb) s
6	  y=x+5;
(gdb) s
7	  return y;
(gdb) s
8	}
(gdb) s
main () at f1.c:18
18	    i=10; i=20; i=fct(1000); i=30; i=40;
(gdb) s
fct (x=100) at f1.c:2
2	int fct(int x){
(gdb) s
4	  y=x+1; y=x+2; y=x+3;
(gdb) s
5	  y=x+4;
(gdb) finish
Run till exit from #0  fct (x=1000) at f1.c:5
0x0000555555555264 in main () at f1.c:18
18	    i=10; i=20; i=fct(1000); i=30; i=40;
Value returned is $1 = 1005
(gdb) s
17	    i=1; i=2; i=fct(100); i=3; i=4;
(gdb) n
18	    i=10; i=20; i=fct(1000); i=30; i=40;
(gdb) n
17	    i=1; i=2; i=fct(100); i=3; i=4;
(gdb) n
18	    i=10; i=20; i=fct(1000); i=30; i=40;
(gdb) continue
Continuing.
^C
Program received signal SIGINT, Interrupt.   /* am tastat Ctrl-C */
fct (x=1000) at f1.c:4
4	  y=x+1; y=x+2; y=x+3;
(gdb) s
5	  y=x+4;
(gdb) si     /* obs. ca cu si trebuie mai multi pasi pt. aceeasi instr. C */
0x0000555555555172	5	  y=x+4;
(gdb) si
0x0000555555555175	5	  y=x+4;
(gdb) si
6	  y=x+5;
(gdb) si
0x000055555555517b	6	  y=x+5;
(gdb) si
0x000055555555517e	6	  y=x+5;
(gdb) si
7	  return y;
(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/dragulici/Desktop/.../work/p1
10
20
30
40
50
^C
Program received signal SIGINT, Interrupt.
main () at f1.c:17
17	    i=1; i=2; i=fct(100); i=3; i=4;
(gdb) n
18	    i=10; i=20; i=fct(1000); i=30; i=40;
(gdb) n
17	    i=1; i=2; i=fct(100); i=3; i=4;
(gdb) n
18	    i=10; i=20; i=fct(1000); i=30; i=40;
(gdb) n
17	    i=1; i=2; i=fct(100); i=3; i=4;
(gdb) n
18	    i=10; i=20; i=fct(1000); i=30; i=40;
(gdb) n
17	    i=1; i=2; i=fct(100); i=3; i=4;
(gdb) kill
Kill the program being debugged? (y or n) y
[Inferior 1 (process 7126) killed]
(gdb) s
The program is not being run.
(gdb) start
Temporary breakpoint 1 at 0x555555555186: file f1.c, line 9.
Starting program: /home/dragulici/Desktop/.../work/p1

Temporary breakpoint 1, main () at f1.c:9
9	int main(){
(gdb) s
11	  i=10; printf("%d\n",i);
(gdb) s         /* intra in 'printf()', care nu e compilat cu '-ggdb' */
__printf (format=0x555555556004 "%d\n") at printf.c:28
28	printf.c: No such file or directory.
(gdb) finish    /* ruleaza 'printf()' pana la sfarsit */
Run till exit from #0  __printf (format=0x555555556004 "%d\n") at printf.c:28
10
main () at f1.c:12
12	  i=20; printf("%d\n",i);
Value returned is $2 = 3
(gdb) s
__printf (format=0x555555556004 "%d\n") at printf.c:28
28	printf.c: No such file or directory.
(gdb) finish
Run till exit from #0  __printf (format=0x555555556004 "%d\n") at printf.c:28
20
main () at f1.c:13
13	  i=30; printf("%d\n",i);
Value returned is $3 = 3
(gdb) j 15
Continuing at 0x555555555206.                /* obs. ca nu mai afisaza 40 */
50
^C
Program received signal SIGINT, Interrupt.   /* am tastat Ctrl-C */
fct (x=1000) at f1.c:7
7	  return y;
(gdb) start
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Temporary breakpoint 2 at 0x555555555186: file f1.c, line 9.
Starting program: /home/dragulici/Desktop/.../work/p1

Temporary breakpoint 2, main () at f1.c:9
9	int main(){
(gdb) n
11	  i=10; printf("%d\n",i);
(gdb) n
10
12	  i=20; printf("%d\n",i);
(gdb) n
20
13	  i=30; printf("%d\n",i);
(gdb) p i
$4 = 20           /* linia 13 nu s-a executat inca, deci i=20 */
(gdb) p 2*i+1
$5 = 41   /* se pot afisa si expr. ce nu apar ca atare in prog. dar au sens*/
(gdb) p 1000
$6 = 1000
(gdb) p $
$7 = 1000
(gdb) p $
$8 = 1000
(gdb) p $2
$9 = 3
(gdb) p $5
$10 = 41
(gdb) p $$
$11 = 3
(gdb) p &i
$12 = (int *) 0x7fffffffdcac
(gdb) x/3xw 0x7fffffffdcac
0x7fffffffdcac:	0x00000014	0x00000000	0x00000000
(gdb) help quit
Exit gdb.
Usage: quit [EXPR]
The optional expression EXPR, if present, is evaluated and the result
used as GDB's exit code.  The default is zero.
(gdb) h quit
Exit gdb.
Usage: quit [EXPR]
The optional expression EXPR, if present, is evaluated and the result
used as GDB's exit code.  The default is zero.
(gdb) help q
Exit gdb.
Usage: quit [EXPR]
The optional expression EXPR, if present, is evaluated and the result
used as GDB's exit code.  The default is zero.
(gdb) h q
Exit gdb.
Usage: quit [EXPR]
The optional expression EXPR, if present, is evaluated and the result
used as GDB's exit code.  The default is zero.
(gdb) q
A debugging session is active.

	Inferior 1 [process 7133] will be killed.

Quit anyway? (y or n) y
$

Obs: in final am afisat (cu comanda 'x') 3 word-uri (w) in format hexa (x)
  incepand de la adresa 0x7fffffffdcac, adica adresa lui 'i'; cum 'i' este
  un int, alocat ca word si continand 20, adica 14 hexa, primul word afisat
  este 0x00000014.

 Putem modifica continutul unei variabile in timpul rularii, prin comenzi ca:

set variable nume = valoare
set {int}adresa = valoare

unde 'nume' este numele variabilei, 'adresa' este adresa variabilei,
'valoare' este noua valoare.

Exemplul 2:
===========

$cat prog.c
int i;
int main() {
  i = 0;
  i = 1;
  i = 2;
  i = 3;
  i = 4;
  i = 5;
  return 0;
}
$gcc -Wall -o prog prog.c -ggdb
$gdb prog
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
 ...
Reading symbols from prog...
(gdb) start
Temporary breakpoint 1 at 0x1129: file prog.c, line 2.
Starting program: /home/dragulici/Desktop/work/prog

Temporary breakpoint 1, main () at prog.c:2
2	int main() {
(gdb) s
3	  i = 0;
(gdb) s
4	  i = 1;
(gdb) s
5	  i = 2;
(gdb) s
6	  i = 3;
(gdb) print i
$1 = 2
(gdb) set variable i = 10
(gdb) print i
$2 = 10
(gdb) print &i
$3 = (int *) 0x555555558014 <i>
(gdb) set {int}0x555555558014 = 20
(gdb) print i
$4 = 20
(gdb) s
7	  i = 4;
(gdb) print i
$5 = 3
(gdb) kill
Kill the program being debugged? (y or n) y
[Inferior 1 (process 17755) killed]
(gdb) quit
$

 Daca dorim sa evitam dificultatile legate de intalnirea unor functii care
nu au fost compilate pentru depanare, cum sunt cele din biblioteca standard
C (a se vedea 'printf()') din exemplul anterior, putem instala debug symbols
for libc:

  sudo apt-get install libc6-dbg

sau putem folosi comenzi de tip 'skip' pentru a cere lui gdb sa execute
continuu (nu pas cu pas) apelurile anumitor functii, daca sunt intalnite
cu ocazia comenzilor de tip 'step':

skip
skip -rfu[nction] regexp
  ==> functiile ale caror nume se potrivesc cu sablonul 'regexp' (de exemplu,
       'printf', 'pri*'), vor fi executate continuu (nu pas cu pas), daca vor
       fi intalnite cu ocazia comenzilor 'step' (skipped over when stepping);
      fara argumente, este vorba de functia curenta;
      fiecare skip nou adaugat este retinut intr-o lista interna, primind
       un numar de ordine (ulterior, poate fi referit prin acest numar
       pentru a fi dezactivat, activat, eliminat);

info skip
info skip domeniu
  ==> afisaza informatii despre skip-uri;
      fara argument, afisaza toate skip-urile;
      argumentul 'domeniu' poate fi 'nr', si atunci afisaza doar skip-ul
       cu numarul 'nr', sau 'nr1-nr2', si atunci afisaza skip-urile cu
       numere de la 'nr1' la 'nr2';

skip disable
skip disable domeniu
  ==> dezactiveaza skip-uri;
      fara argument, le dezactiveaza pe toate;
      argumentul 'domeniu' este ca la comanda 'info skip' si sunt
       dezactivate doar skip-urile respective;

skip enable
skip enable domeniu
  ==> activeaza skip-uri;
      fara argument, le activeaza pe toate;
      argumentul 'domeniu' este ca la comanda 'info skip' si sunt
       activate doar skip-urile respective;

skip delete
skip delete domeniu
  ==> elimina (delete) skip-uri;
      fara argument, le elimina pe toate;
      argumentul 'domeniu' este ca la comanda 'info skip' si sunt
       eliminate doar skip-urile respective.

Obs: unele apeluri din biblioteca standard C sunt de fapt macro-uri,
 care se rescriu prin functii cu alte nume, a.i. adaugarea numelui lor
 la lista 'skip' poate fi inselatoare; o cale de a afla numele functiilor
 reale este de a intra cu 'step' in ele, apoi a da 'skip' (fara argumente),
 apoi a inspecta lista cu 'info skip'. La urmatoarea rulare, se vor adauga
 cu 'skip' numele observate (sau vom relua rularea de la inceput, numele
 fiind deja in lista).

Exemplul 3:
===========

$ls
f2.c
$cat f2.c
#include<stdio.h>
#include<ctype.h>
void test(char *);
void mare(char *q){
  char k;
  k=*q;
  printf("%c mare\n",k);
  test(q+1);
}
void mica(char *r){
  char l;
  l=*r;
  printf("%c mica\n",l);
  test(r+1);
}
void test(char *p){
  char c;
  c=*p;
  if(!c) return;
  if(isupper(c)) mare(p);
  else if(islower(c)) mica(p);
}
int main(){
  char s[]="abAcBCDe";
  test(s);
  return 0;
}

$gcc -o p2 -ggdb f2.c
$gdb p2
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
 ...
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from p2...
(gdb) run
Starting program: /home/dragulici/Desktop/.../work/p2
a mica
b mica
A mare
c mica
B mare
C mare
D mare
e mica
[Inferior 1 (process 10525) exited normally]
(gdb) start
Temporary breakpoint 1 at 0x555555555294: file f2.c, line 23.
Starting program: /home/dragulici/Desktop/.../work/p2

Temporary breakpoint 1, main () at f2.c:23
23	int main(){
(gdb) s
24	  char s[]="abAcBCDe";
(gdb) s
25	  test(s);
(gdb) s
test (p=0x7fffffffdc87 "") at f2.c:16
16	void test(char *p){
(gdb) s
18	  c=*p;
(gdb) s
19	  if(!c) return;
(gdb) s
20	  if(isupper(c)) mare(p);
(gdb) s
__ctype_b_loc () at ../include/ctype.h:40
40	../include/ctype.h: No such file or directory.
(gdb) skip                  /* skip-am 'isupper()' */
Function __ctype_b_loc will be skipped when stepping.
(gdb) finish
Run till exit from #0  __ctype_b_loc () at ../include/ctype.h:40
0x0000555555555236 in test (p=0x7fffffffdc8f "abAcBCDe") at f2.c:20
20	  if(isupper(c)) mare(p);
Value returned is $1 = (const uint16_t **) 0x7ffff7faa4d8
(gdb) s
21	  else if(islower(c)) mica(p);
(gdb) s
mica (r=0x0) at f2.c:10
10	void mica(char *r){
(gdb) s                     /* obs. ca a skip-at si 'islower()' */
12	  l=*r;
(gdb) s
13	  printf("%c mica\n",l);
(gdb) s
__printf (format=0x55555555600d "%c mica\n") at printf.c:28
28	printf.c: No such file or directory.
(gdb) skip                  /* skip-am 'printf()' */
Function __printf will be skipped when stepping.
(gdb) kill
Kill the program being debugged? (y or n) y
[Inferior 1 (process 10529) killed]
(gdb) info skip             /* vedem ce am skip-at de fapt */
Num   Enb Glob File                 RE Function
1     y      n <none>                n __ctype_b_loc
2     y      n <none>                n __printf
(gdb) start
Temporary breakpoint 2 at 0x555555555294: file f2.c, line 23.
Starting program: /home/dragulici/Desktop/.../work/p2

Temporary breakpoint 2, main () at f2.c:23
23	int main(){
(gdb) s
24	  char s[]="abAcBCDe";
(gdb) s
25	  test(s);
(gdb) s
test (p=0x7fffffffdc87 "") at f2.c:16
16	void test(char *p){
(gdb) s
18	  c=*p;
(gdb) s
19	  if(!c) return;
(gdb) s
20	  if(isupper(c)) mare(p);
(gdb) s
21	  else if(islower(c)) mica(p);
(gdb) s
mica (r=0x0) at f2.c:10
10	void mica(char *r){
(gdb) s
12	  l=*r;
(gdb) s
13	  printf("%c mica\n",l);
(gdb) s
a mica
14	  test(r+1);
(gdb) s
test (p=0x0) at f2.c:16
16	void test(char *p){
(gdb) s
18	  c=*p;
(gdb) s
19	  if(!c) return;
(gdb) s
20	  if(isupper(c)) mare(p);
(gdb) s
21	  else if(islower(c)) mica(p);
(gdb) s
mica (r=0x0) at f2.c:10
10	void mica(char *r){
(gdb) s
12	  l=*r;
(gdb) s
13	  printf("%c mica\n",l);
(gdb) s
b mica
14	  test(r+1);
(gdb) bt
#0  mica (r=0x7fffffffdc90 "bAcBCDe") at f2.c:14
#1  0x000055555555528f in test (p=0x7fffffffdc90 "bAcBCDe") at f2.c:21
#2  0x000055555555520e in mica (r=0x7fffffffdc8f "abAcBCDe") at f2.c:14
#3  0x000055555555528f in test (p=0x7fffffffdc8f "abAcBCDe") at f2.c:21
#4  0x00005555555552cd in main () at f2.c:25
(gdb) bt full
#0  mica (r=0x7fffffffdc90 "bAcBCDe") at f2.c:14
        l = 98 'b'
#1  0x000055555555528f in test (p=0x7fffffffdc90 "bAcBCDe") at f2.c:21
        c = 98 'b'
#2  0x000055555555520e in mica (r=0x7fffffffdc8f "abAcBCDe") at f2.c:14
        l = 97 'a'
#3  0x000055555555528f in test (p=0x7fffffffdc8f "abAcBCDe") at f2.c:21
        c = 97 'a'
#4  0x00005555555552cd in main () at f2.c:25
        s = "abAcBCDe"
(gdb) bt -2
#3  0x000055555555528f in test (p=0x7fffffffdc8f "abAcBCDe") at f2.c:21
#4  0x00005555555552cd in main () at f2.c:25
(gdb) bt full -2
#3  0x000055555555528f in test (p=0x7fffffffdc8f "abAcBCDe") at f2.c:21
        c = 97 'a'
#4  0x00005555555552cd in main () at f2.c:25
        s = "abAcBCDe"
(gdb) kill
Kill the program being debugged? (y or n) y
[Inferior 1 (process 10532) killed]
(gdb) start
Temporary breakpoint 3 at 0x555555555294: file f2.c, line 23.
Starting program: /home/dragulici/Desktop/.../work/p2

Temporary breakpoint 3, main () at f2.c:23
23	int main(){
(gdb) s 53
a mica
b mica
A mare
c mica
B mare
C mare
8	  test(q+1);
(gdb) bt
#0  mare (q=0x7fffffffdc94 "CDe") at f2.c:8
#1  0x000055555555525f in test (p=0x7fffffffdc94 "CDe") at f2.c:20
#2  0x00005555555551ca in mare (q=0x7fffffffdc93 "BCDe") at f2.c:8
#3  0x000055555555525f in test (p=0x7fffffffdc93 "BCDe") at f2.c:20
#4  0x000055555555520e in mica (r=0x7fffffffdc92 "cBCDe") at f2.c:14
#5  0x000055555555528f in test (p=0x7fffffffdc92 "cBCDe") at f2.c:21
#6  0x00005555555551ca in mare (q=0x7fffffffdc91 "AcBCDe") at f2.c:8
#7  0x000055555555525f in test (p=0x7fffffffdc91 "AcBCDe") at f2.c:20
#8  0x000055555555520e in mica (r=0x7fffffffdc90 "bAcBCDe") at f2.c:14
#9  0x000055555555528f in test (p=0x7fffffffdc90 "bAcBCDe") at f2.c:21
#10 0x000055555555520e in mica (r=0x7fffffffdc8f "abAcBCDe") at f2.c:14
#11 0x000055555555528f in test (p=0x7fffffffdc8f "abAcBCDe") at f2.c:21
#12 0x00005555555552cd in main () at f2.c:25
(gdb) up
#1  0x000055555555525f in test (p=0x7fffffffdc94 "CDe") at f2.c:20
20	  if(isupper(c)) mare(p);
(gdb) up
#2  0x00005555555551ca in mare (q=0x7fffffffdc93 "BCDe") at f2.c:8
8	  test(q+1);
(gdb) up 2
#4  0x000055555555520e in mica (r=0x7fffffffdc92 "cBCDe") at f2.c:14
14	  test(r+1);
(gdb) do
#3  0x000055555555525f in test (p=0x7fffffffdc93 "BCDe") at f2.c:20
20	  if(isupper(c)) mare(p);
(gdb) sel 8
(gdb) f
#8  0x000055555555520e in mica (r=0x7fffffffdc90 "bAcBCDe") at f2.c:14
14	  test(r+1);
(gdb) ret
Make mica return now? (y or n) y
#0  0x000055555555528f in test (p=0x7fffffffdc90 "bAcBCDe") at f2.c:21
21	  else if(islower(c)) mica(p);
(gdb) c        /* obs. ca nu s-a mai terminat prelucrarea stringului */
Continuing.
[Inferior 1 (process 10537) exited normally]
(gdb) q
$

Exemplul 4: argumente in linia de comanda si environment
===========

$gdb /bin/echo
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
 ...
Reading symbols from /bin/echo...
(No debugging symbols found in /bin/echo)
(gdb) l
No symbol table is loaded.  Use the "file" command.
(gdb) set environment vvv abc
(gdb) set args 123 xyz $vvv
(gdb) r
Starting program: /usr/bin/echo 123 xyz $vvv
123 xyz abc
[Inferior 1 (process 3545) exited normally]
(gdb) set environment vvv ijk
(gdb) r
Starting program: /usr/bin/echo 123 xyz $vvv
123 xyz ijk
[Inferior 1 (process 3554) exited normally]
(gdb) quit
$

Comentariu: am rulat in depanare utilitarul din sistem '/bin/echo';
  i-am setat variabila de environment 'vvv' la diverse valori, apoi
  am executat 'echo 123 xyz $vvv' (a afisat '123', 'xyz' si valoarea
  curenta a lui 'vvv'); deoarece '/bin/echo' nu a fost compilat cu
  '-g', nu avem disponibile in el multe informatii pentru depanare,
  de exemplu nu este inclusa si referinta la sursa in executabil, de
  aceea nu a afisat nimic comanda 'l', dar anumite operatii de depanare
  au fost posibile.

 In general, programele compilate pentru depanare (cu '-g', '-ggdb')
contin numele iar uneori si directoarele fisierelor sursa din care sunt
compilate. Astfel, pot fi acceste pentru a fi afisate liniile sursa la
momentul depanarii. Intrucat intre compilare si depanare directoarele
se pot schimba, gdb are o lista de directoare in care cauta fisierele
sursa - aceasta s.n. calea sursa (source path); directoarele sunt scanate
in ordinea din lista.

 Calea sursa (source path) va include mereu doua intrari speciale:
 '$cdir'- directorul de compilare (daca este inregistrat vreunul in
   executabil, altfel este ignorat);
 '$cwd' - directorul curent al sesiunii gdb;

 De exemplu, daca executabilul refera fisierul '/usr/src/foo-1.0/lib/foo.c',
nu inregistreaza un director de compilare, iar source path este '/mnt/cross',
gdb va cauta fisierul sursa in locatiile:

    /usr/src/foo-1.0/lib/foo.c
    /mnt/cross/usr/src/foo-1.0/lib/foo.c
    /mnt/cross/foo.c

 Specificarile cu cale relativa nu sunt cautate literally. De exemplu,
daca source path este '/mnt/cross', fisierul sursa este inregistrat ca
'../lib/foo.c' si nu este inregistrat un director de compilare, atunci
gdb va cauta fisierul sursa in locatiile:

    /mnt/cross/../lib/foo.c
    /mnt/cross/foo.c

 Daca este inregistrat un director de compilare iar gdb nu a gasit
fisierul sursa cautat dupa prima parcurgere a source path, atunci gdb
combina directorul de compilare si numele fisierului, apoi reia cautarea
in source path.

 De exemplu, daca executabilul inregistreaza fisierul sursa ca
'/usr/src/foo-1.0/lib/foo.c', directorul de compilare ca '/project/build',
source path este '/mnt/cross:$cdir:$cwd' iar directorul curent al sesiunii
gdb este '/home/user', atunci gdb va cauta fisierul sursa in locatiile:

    /usr/src/foo-1.0/lib/foo.c
    /mnt/cross/usr/src/foo-1.0/lib/foo.c
    /project/build/usr/src/foo-1.0/lib/foo.c
    /home/user/usr/src/foo-1.0/lib/foo.c
    /mnt/cross/project/build/usr/src/foo-1.0/lib/foo.c
    /project/build/project/build/usr/src/foo-1.0/lib/foo.c
    /home/user/project/build/usr/src/foo-1.0/lib/foo.c
    /mnt/cross/foo.c
    /project/build/foo.c
    /home/user/foo.c

(daca specificarea fisierului sursa era cu cale relativa, prima cautare
nu s-ar fi efectuat).

 Cu urmatoarele comenzi gdb putem gestiona source path:

directory dirname ...
dir dirname ...
 ==> adauga directorul 'dirname' la inceputul source path; se pot da mai
      multe directoare, separate prin ':'; se poate specifica un director
      deja prezent in source path iar aceasta il va muta mai in fata, deci
      va fi scanat mai devreme;
     stringurile speciale '$cdir' (directorul de compilare, daca este
      inregistrat vreunul) si '$cwd' (directorul curent) pot fi si ele
      incluse in lista de directoare 'dirname' - desi ele vor fi deja in
      source path, vor fi mutate mai in fata;

directory
 ==> reseteaza source path la valoarea sa implicita ('$cdir:$cwd' in
      sistemele Unix); aceasta necesita confirmare;

set directories path-list
 ==> seteaza source path la 'path-list'; daca lipseste '$cdir:$cwd',
      este adaugat;

show directories
 ==> afisaza source path.

Exemplul 5:
===========

$ls
t  x  y  z
$ls x
f4.c
$ls y
$ls z
$ls t
$cat x/f4.c
int main(){
  int x;
  x = 1;
  x = 2;
  x = 3;
  x = 4;
  x = 5;
  return 0;
}

$cd x
$gcc -o p4 -ggdb f4.c
$mv f4.c ../y
$mv p4 ../z
$cd ../t
$gdb ../z/p4
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
 ...
Reading symbols from ../z/p4...
(gdb) l
1	f4.c: No such file or directory.
(gdb) start
Temporary breakpoint 1 at 0x1129: file f4.c, line 1.
Starting program: /home/dragulici/Desktop/.../work/z/p4

Temporary breakpoint 1, main () at f4.c:1
1	in f4.c
(gdb) l
1	in f4.c
(gdb) s
3	in f4.c
(gdb) s
4	in f4.c
(gdb) kill
Kill the program being debugged? (y or n) y
[Inferior 1 (process 4491) killed]
(gdb) show directories
Source directories searched: $cdir:$cwd
(gdb) dir ../y
Source directories searched: /home/dragulici/Desktop/.../work/t/../y:$cdir:$cwd
(gdb) show directories
Source directories searched: /home/dragulici/Desktop/.../work/t/../y:$cdir:$cwd
(gdb) l
1	int main(){
2	  int x;
3	  x = 1;
4	  x = 2;
5	  x = 3;
6	  x = 4;
7	  x = 5;
8	  return 0;
9	}
10
(gdb) start
Temporary breakpoint 2 at 0x555555555129: file f4.c, line 1.
Starting program: /home/dragulici/Desktop/.../work/z/p4

Temporary breakpoint 2, main () at f4.c:1
1	int main(){
(gdb) s
3	  x = 1;
(gdb) s
4	  x = 2;
(gdb) s
5	  x = 3;
(gdb) kill
Kill the program being debugged? (y or n) y
[Inferior 1 (process 4500) killed]
(gdb) q
$


3.2. Intrerupere (breakpoint) si supraveghere (watchpoint):
-----------------------------------------------------------

 Comenzi gdb pentru puncte de intrerupere (breakpoint) si supraveghere
expresii (watch):

wa(tch) expresie
  ==> seteaza un watchpoint pentru expresia respectiva;
      executia se intrerupe automat (si comuta in regim pas cu pas) de
    fiecare data cand valoarea expresiei se schimba;

b(reak)
b(reak) nr
b(reak) *adresa
b(reak) functie
  ==> seteaza un breakpoint respectiv la:
    - adresa unde s-a ajuns cu executia, in cadrul de apel din stiva aflat
       in acest moment in executie;
    - linia cu numarul 'nr';
    - adresa absoluta 'adresa';
    - prima linie a functiei cu numele 'functie';
    executia se intrerupe (si comuta in pasa cu pas) la intalnirea unui
    breakpoint; unui breakpoint i se poate atasa o conditie si atunci
    executia nu se intrerupe la intalnirea breakpoint-ului decat daca
    este indeplinita si conditia;

cl(ear)
cl(ear) nr
cl(ear) *adresa
cl(ear) functie
  ==> elimina toate breakpoint-urile de la respectiv:
    - adresa unde s-a ajuns cu executia in cadrul de apel curent selectat;
    - linia cu numarul 'nr';
    - adresa absoluta 'adresa';
    - inceputul functiei cu numele 'functie';

d(elete) b(reakpoints) nr1 ... nrn
  ==> elimina breakpoint-urile cu numerele 'nr1', ..., 'nrn';
   'nr1 ... nrn' poate lipsi si atunci se elimina toate breakpoint-urile
   (in acest caz comanda se poate abrevia si prin 'd(elete)');

comm(ands) nr
comanda1
...
comandan
end
  ==> seteaza comenzile gdb ce trebuie executate cand este intalnit
    breakpoint-ul cu numarul 'nr' (daca lipseste, este vorba de ultimul
    breakpoint setat); fiecare comanda se scrie pe cate o linie,
    ultima linie fiind 'end';
      daca prima comanda este 'silent', la intalnirea breakpoint-ului nu se
    afisaza nimic in afara de output-ul unor eventuale comenzi 'print';

cond(ition) nr conditie
  ==> seteaza conditia atasata breakpoint-ului cu numarul 'nr' sa fie
   'conditie' - la intalnirea breakpoint-ului executia va fi intrerupta
   (si comutata in regim pas cu pas) doar daca in acel moment si conditia
   este adevarata;
    'conditie' poate lipsi si atunci breakpoint-ul (re)devine neconditionat;

disab(le) b(reakpoints) nr1 ... nrn
  ==> dezactiveaza breakpoint-urile cu numerele 'nr1', ..., 'nrn';
   'nr1 ... nrn' poate lipsi si atunci se dezactiveaza toate
    breakpoint-urile (in acest caz comanda se poate abrevia si prin
    'disab(le)');
      breakpoint-urile nu sunt uitate, dar ele vor functiona doar dupa ce
    vor fi reactivate cu 'enable';

ena(ble) nr1 ... nrn
  ==> activeaza breakpoint-urile cu numerele 'nr1', ..., 'nrn';
   'nr1 ... nrn' poate lipsi si atunci se activeaza toate
   breakpoint-urile;

ig(nore) nr numar
  ==> seteaza contorul de ignorare al breakpoint-ului cu numarul 'nr'
   la 'numar'; breakpoint-ul nu va intrerupe executia (si comuta in regim
   pas cu pas) decat de la a 'numar'-a intalnire incolo;

inf(o) b(reakpoints) nr
  ==> afisaza informatii despre breakpoint-ul cu numarul 'nr'; 'nr' poate
    lipsi si atunci se afisaza informatii despre toate breakpoint-urile
    existente.

Exemplul 6:
===========

$ls
f5.c
$gcc -o p5 -ggdb f5.c
$gdb p5
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
 ...
Reading symbols from p5...
(gdb) l 1,1000
1	#include<stdio.h>
2	void fct(int x){
3	  printf("fct = %d",x);
4	}
5	int main(){
6	  int a,b,c,d;
7	  a=0;
8	  do{
9	    ++a;
10	    printf("a = %d\n",a);
11	  }while(a<10);
12	  b=0; c=0; d=0;
13	  do{
14	    b+=1;   printf("b = %d\n",b);
15	    c+=10;  printf("c = %d\n",c);
16	    d+=100; printf("d = %d\n",d);
17	  }while(b<10);
18	  fct(1);
19	  return 0;
20	}
21
(gdb) skip -rfu __printf        /* skip-am functia 'printf()' */
Function(s) __printf will be skipped when stepping.
(gdb) b 9
Breakpoint 1 at 0x1184: file f5.c, line 9.
(gdb) cond 1 a%4==0
(gdb) comm 1
Type commands for breakpoint(s) 1, one per line.
End with a line saying just "end".
>silent
>print a
>end
(gdb) b 12
Breakpoint 2 at 0x11a4: file f5.c, line 12.
(gdb) b 14
Breakpoint 3 at 0x11b9: file f5.c, line 14.
(gdb) ig 3 7
Will ignore next 7 crossings of breakpoint 3.
(gdb) comm 3
Type commands for breakpoint(s) 3, one per line.
End with a line saying just "end".
>print b
>end
(gdb) info b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000001184 in main at f5.c:9
	stop only if a%4==0
        silent
        print a
2       breakpoint     keep y   0x00000000000011a4 in main at f5.c:12
3       breakpoint     keep y   0x00000000000011b9 in main at f5.c:14
	ignore next 7 hits
        print b
(gdb) run
Starting program: /home/dragulici/Desktop/.../work/p5
$1 = 0
(gdb) c
Continuing.
a = 1
a = 2
a = 3
a = 4
$2 = 4
(gdb) c
Continuing.
a = 5
a = 6
a = 7
a = 8
$3 = 8
(gdb) c
Continuing.
a = 9
a = 10

Breakpoint 2, main () at f5.c:12
12	  b=0; c=0; d=0;
(gdb) c
Continuing.
b = 1
c = 10
d = 100
b = 2
c = 20
d = 200
b = 3
c = 30
d = 300
b = 4
c = 40
d = 400
b = 5
c = 50
d = 500
b = 6
c = 60
d = 600
b = 7
c = 70
d = 700

Breakpoint 3, main () at f5.c:14
14	    b+=1;   printf("b = %d\n",b);
$4 = 7
(gdb) c
Continuing.
b = 8
c = 80
d = 800

Breakpoint 3, main () at f5.c:14
14	    b+=1;   printf("b = %d\n",b);
$5 = 8
(gdb) quit
A debugging session is active.

	Inferior 1 [process 4653] will be killed.

Quit anyway? (y or n) y
$


3.3. Depanarea programelor multiproces si/sau multithread,
----------------------------------------------------------
atasate la un proces existent, depanarea fisierelor core:
---------------------------------------------------------

 Intr-o sesiune gdb, in functie si de particularitatile sistemului,
se pot depana mai multe procese pe rand sau simultan, procesele se
pot afla in acelasi sistem sau in sisteme distante, accesate prin
conexiuni, iar fiecare proces poate avea mai multe threaduri; gdb
are comenzi pentru a gestiona conexiuni, procese si threaduri.

 gdb isi reprezinta starea fiecarei executii a unui program printr-un
obiect numit un 'inferior'; de obicei, un inferior corespunde unui proces,
dar inferiorii pot fi creati si manevrati fara un proces asociat, li se
poate schimba procesul asociat (cu comanda 'file') sau conexiunea
asociata (cu comanda 'target remote').
Un inferior are, de obicei, propriul spatiu de adrese si poate avea mai
multe threaduri.

 Intotdeauna exista un inferior curent si un thread curent.

 Un inferior are asociat un identificator numeric unic la nivelul
sesiunii gdb (este altceva decat identificatorul procesului in sistemul de
operare - pid).

 Comenzile referitoare la inferiori permit specificarea acestora prin
liste de elemente separate prin spatii si care pot fi de forma 'nr'
(identificatorul unui inferior) sau 'nr1-nr2' (interval de identificatori),
de exemplu '1 2 4-7'.

 La nivelul sesiunii gdb, un thread are asociat un identificator numeric
per-inferior (thread ID) si un identificator numeric global (global thread
ID); identificatorul numeric per-inferior este unic intre threadurile
inferiorului respectiv dar nu este unic intre threadurile unor inferiori
diferiti; identificatorul numeric gobal este unic la nivelul sesiunuii gdb.

 Ne putem referi la un thread al unui inferior folosind calificarea
'inferior-num.thread-num' (qualified thread ID, de exemplu '2.3') sau
putem omite 'inferior-num' (de exemplu '3') si atunci este vorba de un
thread al inferiorului curent; 'thread-num' este identificatorul
per-inferior. Pana la crearea unui al doilea inferior, gdb nu va afisa
partea 'inferior-num', desi noi putem folosi in comenzi specificarea
completa 'inferior-num.thread-num' si pentru a ne referi la threadurile
inferiorului 1.

 Unele comenzi referitoare la threaduri permit specificarea acestora prin
liste de elemente separate prin spatii si care pot fi de forma 'inf.thr'
(thread al unui inferior), 'thr' (thread al inferiorului curent),
'inf.thr1-thr2' (interval de threaduri ale unui inferior), 'thr1-thr2'
(interval de threaduri ale inferiorui curent), 'inf.*' (toate threadurile
unui inferior), '*' (toate threadurile inferiorului curent), de exemplu
'1 2-3 4.5 6.7-9 7.*'.

 Din perspectiva gdb, un proces are mereu cel putin un thread, cu alte
cuvinte gdb asigneaza un numar de thread threadului principal al programului
(main thread), chiar daca programul nu este multi-threaded.

 Variabilele de facilizare (convenience variables) '$_inferior',
'$_thread' si '$_gthread' ale depanatorului contin, respectiv,
identificatorul inferiorului curent, identificatorul per-inferior
si cel global pentru threadul curent; ele sunt utile in scrierea
expresiilor conditionale ale breakpointurilor, scripturilor de comenzi,
etc. Variabila '$_inferior_thread_count' contine numarul threadurilor
active (live threads) din inferiorul curent.

 Putem afla informatii despre inferiorii si conexiunile existente cu
comenzile:

info connections
 ==> afisaza informatii depre conexiunile deschise curent gestionate de gdb;
     se afisaza identificatorul dgb al conexiunii, protocolul folosit de
    conexiune, o descriere textuala a protocolului folosit de conexiune;
     conexiunea inferiorului curent este indicata de un '*' in fata
    identificatorului dgb al conexiunii;


info inferiors
 ==> afisaza informatii despre inferiorii existenti;
     se afisaza identificatorul dgb, identificatorul sistem, conexiunea,
    numele executabilului rulat; inferiorul curent este indicat de un '*'
    in fata identificatorului dgb;

inferior
 ==> afisaza informatii despre inferiorul curent;

inferior infno
 ==> face curent inferiorul cu identificatorul gdb 'infno';

 Putem adauga inferiori cu comenzile 'add-inferior' si 'clone-inferior',
facand astfel posibila depanarea mai multor executabile intr-o sesiune gdb.
In unele sisteme, gdb poate adauga inferiori la sesiune si in mod automat,
urmarind apelurile 'fork()', 'exec()'. Pentru a elimina inferiori din
sesiunea de depanare, se foloseste comanda 'remove-inferiors'; in
descrierea comenzilor urmatoare, '[]' inseamna optional iar '...' inseamna
ca pot fi mai multe:

add-inferior [ -copies n ] [ -exec executable ] [-no-connection ]
 ==> adauga 'n' inferiori  (implicit 1) care sa ruleze executabilul
    'executable'; daca nu este specificat un executabil, inferiorii nu au
    un program asignat (empty); putem insa asigna sau schimba programul
    asignat unui inferior oricand, folosind comanda 'file executable';
     implicit, inferiorul incepe cu aceeasi conexiune ca inferiorul curent,
    dar daca folosim optiunea '-no-connection', inferiorul incepe fara
    conexiune; ulterior, putem folosi comanda 'target remote' pentru a asocia
    o alta conexiune sau comanda 'run' pentru a lansa o instanta a unui
    program local;

clone-inferior [ -copies n ] [ infno ]
 ==> adauga 'n' inferiori (implicit 1) gata sa execute acelasi program ca
    inferiorul cu identificatorul gdb 'infno' (implicit este inferiorul
    curent); sunt copiate valorile argumentelor in linia de comanda,
    terminalul de control, directorul curent si schimbarile facute in
    variabilele de environment cu comenzile 'set environment',
    'unset environment';
     acesta este un mod facil de a rula o alta instanta a inferiorului
    in curs de depanare;

remove-inferiors infno...
 ==> elimina inferiorii cu identificatorii gdb respectivi; cu aceasta
    comanda nu se poate elimina un inferior aflat in rulare - trebuie
    folosite mai intai comenzile 'kill' sau 'detach';

 Notam ca adaugarea unui inferior (comenzile 'add-inferior','clone-inferior')
sau (re)asignarea lui cu un program (comanda 'file executable') nu inseamna
ca se si incepe rularea programului asignat; pentru rulare trebuie date
separat comenzi de tip 'run', 'start', etc.

 Putem atasa un inferior unui proces existent (care ruleaza deja, in afara
lui gdb), cu comanda 'attach' (si atunci procesul este adaugat sesiunii de
depanare, putand fi urmarit cu gdb), putem detasa un inferior de la procesul
asociat, cu comanda 'detach' (si atunci procesul isi continua rularea
independent, in afara lui gdb), sau putem termina procesul asociat unui
inferior, cu comanda 'kill'; in toate cazurile, inferiorul ramane in sesiunea
gdb si poate fi refolosit - pentru eliminarea inferiorilor se foloseste
comanda 'remove-inferiors'.

attach process-id
 ==> atasaza inferiorului curent procesul (aflat in executie in afara gdb)
    identificat in sistem de 'process-id' (PID-ul procesului, care se poate
    afla cu comanda shell 'ps'); este necesar sa avem permisiunea de a-i
    transmite procesului semnale; executabilul rulat de proces este cautat
    in directorul curent si, daca nu este gasit aici, in directoarele din
    source path; gdb poate afisa warning daca acest executabil nu se
    potriveste cu cel deja asociat inferiorului (de exemplu, cu 'file');

detach
detach inferior infno...
 ==> detasaza de la sesiunea gdb procesele asociate inferiorilor cu
    identificatorii gdb respectivi (simplul 'detach' se refera la inferiorul
    curent) - din acest moment, procesele respective isi vor continua rularea
    independent de gdb; intrarile inferiorilor respectivi inca raman in lista
    afisata de comnada 'info inferiors' dar cu descrierea '<null>';
     notam ca la iesirea din gdb procesele atasate se detasaza;

kill
kill inferiors infno...
 ==> termina (kill) rularea proceselor asociate inferiorilor cu
    identificatorii gdb respectivi (simplul 'kill' se refera la inferiorul
    curent);
     intrarile inferiorilor respectivi inca raman in lista afisata de
    comnada 'info inferiors' dar cu descrierea '<null>';

Notam ca si la terminarea normala a procesului asociat unui inferior (exit),
inferiorul ramane valid si listat cu 'info inferiors', gata sa fie refolosit.

 Putem atasa o sesiune gdb unui proces existent si lansand gdb intr-unul din
modurile urmatoare:
  gdb -p pid
  gdb executabil pid
(unde 'executabil' este specificatorului fisierul executabil iar 'pid' este
identificatorul din sistem al procesului la care se doreste atasarea).

 Uneori (de exemplu, cand depanam gdb insusi) este util sa aflam mai multe
informatii despre relatia intre inferiori, programe si spatii de adrese,
intr-o sesiune de depanare. Pentru aceasta se foloseste comanda:

maint info program-spaces
 ==> afisaza lista spatiilor de program curent gestionate de gdb; sunt
    afisate: identificatorul gdb al spatiului (numeric), numele
    executabilului incarcat in acel spatiu (de exemplu, cu comanda 'file'),
    numele fisierului core incarcat in acel spatiu (de exemplu, cu comanda
    'core-file');
     spatiul curent este indicat de un '*' in fata identificatorului dgb;
     cu aceasta comanda se poate observa cand mai multi inferiori sunt
    legati de un acelasi spatiu de program - de exemplu, atunci se depaneaza
    atat procesul parinte cat si procesul copil rezultat printr-un apel
    'vfork()';

 De fiecare data cand gdb detecteaza un nou thread in program, afisaza
identificatorul de sistem al tintei (target system’s identification)
pentru acel thread, cun un mesaj de forma '[New systag]', unde 'systag' este
un identificator de thread a carui forma variaza in functie de sistem - de
exemplu, pe GNU/Linux poate fi '[New Thread 0x41e02940 (LWP 25582)]'.

 Putem afla informatii despre threaduri cu comenzile:

info threads [-gid] [thread-id-list]
 ==> afisaza informatii despre threaduri; fara argumente, este vorba despre
    toate threadurile; lista de threaduri poate fi specificata dupa sintaxa
    descrisa mai devreme; pentru fiecare thread sunt afisate: identificatorul
    numeric per inferior (un '*' in dreptul acestuia indica threadul curent),
    identificatorul numeric global (daca este prezenta optiunea '-gid'),
    identificatorul de sistem (systag), numele threadului (daca are),
    sumarul cadrului de stiva curent al threadului;

thread thread-id
 ==> face curent threadul indicat; 'thread-id' este identificatorul
    numeric per inferior, calificat sau nu cu identificatorul inferiorului
    (de exemplu, '2.1' sau '1'); gdb raspunde afisand identificatorul sistem
    al threadului si sumarul cadrului de stiva curent al sau;

thread apply [thread-id-list | all [-ascending]] [flag]... command
 ==> aplica comanda 'command' threadurilor indicate in lista, daca este
    specificat 'thread-id-list', sau tuturor, daca este specificat 'all';
    cand este sepcificat 'all', comanda este implicit aplicata threadurilor
    in ordine descendenta, dar daca am specificat '-acending', li se va
    aplica in ordine ascendenta;
     implicit, gdb afisaza unele informatii despre threaduri inaintea
    output-ului produs de 'command' iar o eroare intalnita in timpul
    executarii acesteia va determina abandonarea (abort) comenzii
    'thread apply'; argumentele 'flag' nuanteaza acest comportament; fiecare
    'flag' este de forma '-c', '-s', '-q'; pot fi date mai multe 'flag',
    dar individual, nu grupat:
    -c
       inseamna 'continue' si face erorile in 'command' sa fie afisate iar
       executia lui 'thread apply' sa continue;
    -s
       inseamna 'silent' si face erorile si outputul vid  produs de 'command'
       sa fie ignorate (i.e. nu se afisaza) iar executia lui 'thread apply'
       sa continue;
    -q
       inseamna 'quiet' si dezactiveaza afisarea informatiilor despre
       threaduri;
    flag-urile '-c' si '-s' nu pot fi folosite impreuna;

taas [option]... command
 ==> prescurtare pentru 'thread apply all -s [option]... command;
     aplica comanda tuturor threadurilor, ignorand erorile si output-ul vid;
     optiunile sunt ca la 'thread apply all command';

tfaas [option]... command
 ==> prescurtare pentru
       'thread apply all -s -- frame apply all -s [option]… command'
     aplica 'command' tuturor cadrelor tuturor threadurilor, ignorand erorile
     si output-ul vid; flag-ul '-s' este mentionat de 2 ori: primul '-s'
     asigura ca 'thread apply' afisaza doar informatiile threadurilor pentru
     care 'frame apply' produce vreun output; al doilea '-s' asigura ca
     'frame apply' afisaza informatiile unui cadru doar daca 'command' a
     produs cu succes vreun output;
      poate fi folosita, de exemplu, pentru a afisa o variabila locala sau
     argument de functie fara a sti threadul sau cadrul unde se afla aceasta
     variabila sau argument, folosind:
       tfaas p some_local_var_i_do_not_remember_where_it_is
      comanda 'tfaas' accepta aceleasi optiuni ca 'frame apply';

thread name [name]
 ==> asigneaza un nume threadului curent; fara argument, elimina orice nume
    specificat de utilizator existent; numele este afisat de 'info threads';
    in Linux, gdb poate determina numele threadului dat de sistemul de
    operare; in acest caz, numele specificat cu 'thread name' prevaleaza
    (override) numele dat de sistem, iar eliminarea numelul specficat de
    utilizator va determina gdb sa afiseze din nou numele dat de sistem;

thread find [regexp]
 ==> gaseste si afisaza identificatorii threadurilor al caror nume sau systag
    se potriveste cu expresia regulata data;


frame apply [all | count | -count | level level...] [option]... command
 ==> aplica 'command' unor threaduri;
    all
       comanda se aplica tuturor cadrelor;
    count
       comanda se aplica celor mai interioare (innermost) 'count'
       (numar pozitiv) cadre;
    -count
       comanda se aplica celor mai exterioare (outermost) 'count'
       (numar pozitiv) cadre;
    level
       comanda se aplica cadrelor indicate prin lista 'level' (poate fi un
       nivel de cadru sau un domeniu de niveluri de cadre ca level1-level2,
       de exemplu, '2-4 6-8 3'; nivelul cadrului este umarul afisat in primul
       camp afisat de comanda 'backtrace';
    optiuni suportate:
    -past-main [on|off]
      daca urmaririle backtrace ar trebui sa continue dupa 'main()';
    -past-entry [on|off]
      daca urmaririle backtrace ar trebui sa continue dupa punctul de intrare
      al unui program;
    -c -s -q
      similar ca la comanda 'thread apply';

  de exemplu, 'frame apply all p j' aplica comanda 'p j' (de afisare a
  variabilei 'j', daca unde exista) tuturor cadrelor;

faas command
 ==> prescurtare pentru 'frame apply all -s command'; aplica 'command'
    tuturor cadrelor, ignorand erorile si output-ul vid;
     de exemplu, poate fi folosita pentru a afisa o variabila locala sau
    argument de functie fara a sti cadrul unde se afla:
     faas p some_local_var_i_do_not_remember_where_it_is
    comanda 'faas' accepta aceleasi optiuni ca 'frame apply';

Exista doua moduri de a controla executia programului:
 - all-stop mode: atunci cand un thread se opreste (stops) (de exemplu, la
  un breakpoint sau atunci cand este urmarit cu 'step'), toate celelalte
  threaduri din program sunt oprite (stopped); este modul implicit;
 - non-stop mode (suportat pe anumite tinte): in timp ce examinam threadul
  stopat, alte threaduri pot continua sa ruleze liber.

In 'all-stop mode', in functie de setarile planificatorului din sistem,
la un 'step' in threadul curent se pot executa mai multe 'step' in alte
threaduri sau ele se pot opri in mijlocul unei instructiuni; se poate
modifca acest comportament, limitand planificatorul sa permita doar unui
singur thread sa ruleze; avem comenzile:

set scheduler-locking mode
 ==> seteaza limitarea planificatorului; 'mode' poate fi:
    off
      nu este nici o limitare, orice thread poate rula in orice moment;
    on
      doar threadul curent poate rula atunci cand interiorul este reluat;
    step
      cand se face 'step' este ca 'on', altfel (de exemplu, cand se face
      'continue', 'until', 'finish') este ca 'off';

show scheduler-locking
 ==> afisaza modul curent de limitare a planificatorului;

set schedule-multiple
 ==> seteaza modul in care se permite threadurilor din procese multiple sa
    fie reluate cand se da o comanda de executie (de exemplu, 'continue',
    'next' sau 'step'); cand este 'on', tuturor threadurilor ale tuturor
    proceselor li se permite sa ruleze; cand este 'off', doar threadurile
    procesului curent sunt reluate; implicit este 'off';
     'scheduler-locking mode' are precedenta daca este setat 'on' sau cand
    executam 'step' si este setat 'step';

show schedule-multiple
 ==> afisaza modul curent in care se permite threadurilor din procese
    multiple sa fie reluate.

 In cazul programelor multithreading, putem alege daca setam breakpoint-uri
in toate threadurile sau intr-un thread particular:

break linespec thread threadno
break linespec thread threadno if ...
 ==> seteaza un breakpoint la linia 'linespec' (se poate specifica in mai
    multe feluri) pentru threadul 'thread threadno' (gdb va opri programul
    doar cand acel thread ajunge la breakpoint-ul respectiv) ('threadno'
    este identificatorul numeric al threadului, afisat in prima coloana de
    comanda 'info threads'); daca nu specificam 'thread threadno',
    breakpoint-ul se aplica pentru toate threadurile programului;
    cu ocazia aceasta, breakpoint-ului i se poate asocia si o conditie
    (cu 'if ...');
      de exemplu:
    (gdb) break frik.c:13 thread 28 if bartab > lim

 Comentam anumite aspecte referitoare la comportamentul gdb atunci cand
programul depanat efectueaza 'fork()', 'vfork()', 'exec()':

 Pe majoritatea sistemelor, gdb nu ofera un suport special pentru depanarea
programelor care creaza procese aditionale folosind 'fork()', 'vfork()'.
 Cand programul se bifurca in doua procese parinte - copil, gdb va continua
sa depaneze parintele iar copilul va rula nestingherit; daca am setat un
breakpoint in codul executat de copil, copilul va primi semnalul SIGTRAP
(handlerul inplicit este de terminare).
 Daca dorim sa depanam (si) copilul, putem face un artificiu: punem un
'sleep()' in codul executat de copil dupa bifurcare (putem conditiona
apelarea 'sleep()' de setarea unei anumite variabile de environment sau de
existenta unui anumit fisier, a.i. intarzierea sa nu apara atunci cand nu
dorim sa urmarim copilul cu gdb); cat timp copilul doarme, aflam cu comanda
'ps' pid-ul lui, apoi atasam gdb la copil cu comanda 'attach' (sau pornim o
noua sesiune gdb).

 Pe anumite sisteme, gdb ofera suport pentru depanarea programelor care
creaza procese aditionale cu 'fork()' sau 'vfork()'. In Linux, aceasta
functionalitate este suportata incepand cu kernel version 2.5.46.
 Implicit, cand programul se bifurca in doua procese parinte - copil, gdb
va continua sa depaneze parintele iar copilul va rula nestingherit; daca
dorim sa urmarim copilul in clocul parintelui, putem folosi:

set follow-fork-mode mode
 ==> seteaza comportamentul gdb atunci cand programul apeleaza 'fork()' sau
    'vfork()', creand un proces copil; 'mode' poate fi:
      'parent' : dupa bifurcare, este depanat procesul original, copilul
                ruleaza nestingherit; este comportamentul implicit.
      'child' : dupa bifurcare, este depanat procesul copil; parintele
               ruleaza nestingherit.

show follow-fork-mode
 ==> afisaza comportamentul curent al gdb atunci cand programul apeleaza
    'fork()' sau 'vfork()'.

 In Linux, daca dorim sa depanam atat procesul parinte cat si cel copil,
putem folosi:

set detach-on-fork mode
 ==> comunica gdb sa detaseze (detach) unul dintre procese dupa o bifurcare
    sau sa pastreze controlul depanarii asupra ambelor; 'mode' poate fi:
      'on' : procesul copil sau parinte (depinzand de valoarea lui
            'follow-fork-mode') va fi detasat si i se va permite sa ruleze
            independent; este comportamentul implicit.
      'off' : ambele procese vor fi tinute sub controlul gdb; unul dintre
            procesele copil sau parinte (depinzand de valoarea lui
            'follow-fork-mode') este depanat ca de obicei, in timp ce
            celalalt este mentinut suspendat.

show detach-on-fork
 ==> afisaza daca 'detach-on-fork mode' este 'on'/'off'.

 Daca 'detach-on-fork mode' este 'off', gdb va mentine controlul asupra
tuturor proceselor rezultate prin bifurcare, inclusiv prin bifurcarile
incuibate. Putem lista procesele obtinute prin bifurcare si aflate sub
controlul gdb cu comanda 'info inferiors', putem comuta de la unul la
altul cu comanda 'inferior command', putem inceta depanarea unuia fie
prin detasare cu 'detach inferiors', fie prin terminare cu 'kill inferiors'.

 Daca cerem depanarea unui proces copil si un 'vfork()' este urmat de un
'exec()', gdb executa noul target pana la primul breakpoint din noul target.
Daca am pus un breakpoint asupra lui 'main()' in programul original, acel
breakpoint va fi, de asemenea, pus asupra lui 'main()' din procesul copil.
Pe anumite sisteme, cand un proces copil este creat prin 'vfork()', nu putem
depana copilul sau parintele pana cand nu se incheie un apel 'exec()'.
 Daca dam comanda gdb 'run' dupa executarea unui 'exec()', se restarteaza
noul target; ca sa restartam procesul parinte, folosim comanda 'file' cu
numele executabilului parinte ca argument.
 Implicit, dupa executarea unui 'exec()', gdb elimina (discards) simbolurile
imaginii executabile anterioare. Putem modifica acest comportament folosind:

set follow-exec-mode mode
 ==> seteaza comportamentul gdb atunci cand programul apeleaza 'exec()' (un
    apel 'exec()' inlocuieste imaginea de program a procesului); 'mode' poate
    fi:
      'new' : gdb creaza un nou inferior si reasociaza (rebinds) procesul cu
             acest nou inferior; programul pe care procesul il rula inainte
             de apelul 'exec()' poate fi restartat dupa aceea prin
             restartarea inferiorului original;
      'same' : gdb mentine procesul asociat (bound) cu acelasi inferior;
              noua imagine de executabil inlocuieste executabilul anterior
              incarcat in inferior; daca restartam inferiorul dupa apelul
              'exec()' (de execmplu, cu comanda 'run'), restarteaza
              executabilul pe care procesul il rula dupa apelul 'exec()';
              acesta este modul implicit.

 Putem folosi comanda 'catch' pentru a face gdb sa se opreasca de fiecare
data cand este efectuat un apel 'fork()', 'vfork()', sau 'exec()':

catch event
  ==> stop cand apare evenimentul 'event'; 'event' poate fi in mai multe
     feluri, prezentam cateva cazuri:
  fork
  vfork
  exec
   un apel 'fork()', 'vfork()', respectiv 'exec()';

  syscall
  syscall [name | number | group:groupname | g:groupname] ...
   un apel sau return dintr-un apel sistem, cerut de depanat;
   el poate fi indicat prin nume sau numar (valoarea transmisa catre syscall
     dispatcher-ul sistemului de operare pentru a identifica serviciul
     cerut);
   daca nu este dat nici un argument, este orice apel sistem;
   in Unix/Linux, lista numelor de apeluri sistem valide poate fi gasita in
     '/usr/include/asm/unistd.h'.

  signal [signal... | 'all']
   livrarea (delivery) unui semnal; fara argumente, este prins orice semnal
   care nu este folosit intern de gdb (i.e. cu exceptia 'SIGTRAP' si
   'SIGINT'); cu 'all', sunt prinse toate semnalele, inclusiv cele folosite
   de gdb - acest argument nu poate fi folosit impreuna cu alte nume de
   semnale.

 Prn comanda de mai sus se stabileste un punct de captare (catchpoint),
caruia i se pot asocia comenzi si conditii, asemanator breakpoint-urilor.
Pentru a lista catchpoint-urile curente, se foloseste comanda 'info break'.

tcatch event
 ==> seteaza un catchpoint care este activat doar pentru o singura oprire;
     catchpoint-ul este automat eliminat (deleted) dupa prima data cand este
     prins evenimentul.

Exemplul 7: Depanarea unei aplicatii multiproces:
===========

$gcc -Wall -o prog prog.c -ggdb
$gdb prog
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
 ...
Reading symbols from prog...
(gdb) l 1,100
1	#include <sys/types.h>
2	#include <unistd.h>
3
4	int i;
5
6	int main() {
7	  i = 0;
8	  if(fork()) {
9	    i = i + 1;
10	    i = i + 2;
11	    i = i + 3;
12	    i = i + 4;
13	    i = i + 5;
14	  } else {
15	    i = i + 10;
16	    i = i + 20;
17	    i = i + 30;
18	    i = i + 40;
19	    i = i + 50;
20	  }
21	  return 0;
22	}
(gdb) set detach-on-fork off
(gdb) start
Temporary breakpoint 1 at 0x1149: file prog.c, line 6.
Starting program: /home/dragulici/Desktop/work/prog

Temporary breakpoint 1, main () at prog.c:6
6	int main() {
(gdb) s
7	  i = 0;
(gdb) info inferiors
  Num  Description       Executable
* 1    process 12986     /home/dragulici/Desktop/work/prog
(gdb) s
8	  if(fork()) {
(gdb) n
[New inferior 2 (process 12990)]
9	    i = i + 1;
(gdb) info inferiors
  Num  Description       Executable
* 1    process 12986     /home/dragulici/Desktop/work/prog
  2    process 12990     /home/dragulici/Desktop/work/prog
(gdb) s
10	    i = i + 2;
(gdb) s
11	    i = i + 3;
(gdb) inferior 2
[Switching to inferior 2 [process 12990] (/home/dragulici/Desktop/work/prog)]
[Switching to thread 2.1 (process 12990)]
Reading symbols from /home/dragulici/Desktop/work/prog...
Reading symbols from /usr/.../78fe54a5d2c2092f8e47eb0b33105e380f7340.debug...
Reading symbols from /usr/.../90288cb132a32066848b987fe4bfeb82e54291.debug...
#0  arch_fork (ctid=0x7ffff7fb2810) at ../sysdeps/.../arch-fork.h:49
49	../sysdeps/unix/sysv/linux/arch-fork.h: No such file or directory.
(gdb) fin
Run till exit from #0  arch_fork (ctid=0x7ffff7fb2810) at .../arch-fork.h:49
__libc_fork () at ../sysdeps/nptl/fork.c:78
78	../sysdeps/nptl/fork.c: No such file or directory.
(gdb) fin
Run till exit from #0  __libc_fork () at ../sysdeps/nptl/fork.c:78
main () at prog.c:8
8	  if(fork()) {
Value returned is $1 = 0
(gdb) s
15	    i = i + 10;
(gdb) s
16	    i = i + 20;
(gdb) c
Continuing.
[Inferior 2 (process 12990) exited normally]
(gdb) info inferiors
  Num  Description       Executable
* 1    process 12986     /home/dragulici/Desktop/work/prog
(gdb) s
12	    i = i + 4;
(gdb) s
13	    i = i + 5;
(gdb) c
Continuing.
[Inferior 1 (process 12986) exited normally]
(gdb) info inferiors
  Num  Description       Executable
* 1    <null>            /home/dragulici/Desktop/work/prog
(gdb) quit
$

Comentarii:
- Cand am ajuns la 'fork()', am dat 'n' pentru a executa continuu
 (nu pas cu pas) apelul 'fork()'; cand am dat 'inferior 2', a
 continuat procesul copil din interiorul apelului 'fork()' si astfel
 nu am putut evita executarea pas cu pas a apelului 'fork()'; insa,
 pentru a iesi mai repede din apelul 'fork()' si al functiilor
 apelate de acesta, am folosit 'fin'.
- Dupa ce s-a terminat procesul copil (inferior 2), s-a continuat cu
 procesul parinte (inferior 1).

Exemplul 8: Depanarea unei aplicatii multithread:
===========

$gcc -Wall -o prog prog.c -pthread -ggdb
$gdb prog
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
 ...
Reading symbols from prog...
(gdb) l 1,1000
1	#include <pthread.h>
2
3	int i;
4
5	void *f1(void *arg) {
6	  i = i + 1;
7	  i = i + 2;
8	  i = i + 3;
9	  return NULL;
10	}
11	void *f2(void *arg) {
12	  i = i + 10;
13	  i = i + 20;
14	  i = i + 30;
15	  return NULL;
16	}
17
18	pthread_t t1, t2;
19
20	int main() {
21	  i = 1;
22	  pthread_create(&t1, NULL, f1, NULL);
23	  pthread_create(&t2, NULL, f2, NULL);
24	  i = 1000;
25	  pthread_join(t1, NULL);
26	  pthread_join(t2, NULL);
27	  return 0;
28	}
(gdb) break main
Breakpoint 1 at 0x11e9: file prog.c, line 20.
(gdb) commands 1
Type commands for breakpoint(s) 1, one per line.
End with a line saying just "end".
>set scheduler-locking on
>end
(gdb) break 6
Breakpoint 2 at 0x1175: file prog.c, line 6.
(gdb) break 12
Breakpoint 3 at 0x11b5: file prog.c, line 12.
(gdb) start
Temporary breakpoint 4 at 0x11e9: file prog.c, line 20.
Starting program: /home/dragulici/Desktop/work/prog
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Breakpoint 1, main () at prog.c:20
20	int main() {
(gdb) s
21	  i = 1;
(gdb) info threads
  Id   Target Id                                Frame
* 1    Thread 0x7ffff7d99740 (LWP 13943) "prog" main () at prog.c:21
(gdb) s
22	  pthread_create(&t1, NULL, f1, NULL);
(gdb) n
[New Thread 0x7ffff7d98700 (LWP 13947)]
23	  pthread_create(&t2, NULL, f2, NULL);
(gdb) info threads
  Id   Target Id                                Frame
* 1    Thread 0x7ffff7d99740 (LWP 13943) "prog" main () at prog.c:23
  2    Thread 0x7ffff7d98700 (LWP 13947) "prog" f1 (arg=0x0) at prog.c:6
(gdb) thread 2
[Switching to thread 2 (Thread 0x7ffff7d98700 (LWP 13947))]
#0  f1 (arg=0x0) at prog.c:6
6	  i = i + 1;
(gdb) s

Thread 2 "prog" hit Breakpoint 2, f1 (arg=0x0) at prog.c:6
6	  i = i + 1;
(gdb) s
7	  i = i + 2;
(gdb) thread 1
[Switching to thread 1 (Thread 0x7ffff7d99740 (LWP 13943))]
#0  main () at prog.c:23
23	  pthread_create(&t2, NULL, f2, NULL);
(gdb) n
[New Thread 0x7ffff7597700 (LWP 14456)]
24	  i = 1000;
(gdb) info threads
  Id   Target Id                                Frame
* 1    Thread 0x7ffff7d99740 (LWP 13943) "prog" main () at prog.c:24
  2    Thread 0x7ffff7d98700 (LWP 13947) "prog" f1 (arg=0x0) at prog.c:7
  3    Thread 0x7ffff7597700 (LWP 14456) "prog" clone () at .../clone.S:78
(gdb) s
25	  pthread_join(t1, NULL);
(gdb) thread 3
[Switching to thread 3 (Thread 0x7ffff7597700 (LWP 14456))]
#0  clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:78
78	../sysdeps/unix/sysv/linux/x86_64/clone.S: No such file or directory.
(gdb) fin
Run till exit from #0  clone () at .../clone.S:78

Thread 3 "prog" hit Breakpoint 3, f2 (arg=0x0) at prog.c:12
12	  i = i + 10;
(gdb) s
13	  i = i + 20;
(gdb) thread 1
[Switching to thread 1 (Thread 0x7ffff7d99740 (LWP 13943))]
#0  main () at prog.c:25
25	  pthread_join(t1, NULL);
(gdb) n
^C
Thread 1 "prog" received signal SIGINT, Interrupt.
__pthread_clockjoin_ex (threadid=140737351616256, ...
    ... at pthread_join_common.c:145
145	pthread_join_common.c: No such file or directory.
(gdb) thread 2
[Switching to thread 2 (Thread 0x7ffff7d98700 (LWP 13947))]
#0  f1 (arg=0x0) at prog.c:7
7	  i = i + 2;
(gdb) s
8	  i = i + 3;
(gdb) c
Continuing.
[Thread 0x7ffff7d98700 (LWP 13947) exited]
No unwaited-for children left.
(gdb) info threads
  Id   Target Id                                Frame
  1    Thread 0x7ffff7d99740 (LWP 13943) "prog" __pthread_clockjoin_ex ...
    ... at pthread_join_common.c:145
* 3    Thread 0x7ffff7597700 (LWP 14456) "prog" f2 (arg=0x0) at prog.c:13
(gdb) thread 1
[Switching to thread 1 (Thread 0x7ffff7d99740 (LWP 13943))]
#0  __pthread_clockjoin_ex (threadid=140737351616256, ...
    ... at pthread_join_common.c:145
145	pthread_join_common.c: No such file or directory.
(gdb) fin
Run till exit from #0  __pthread_clockjoin_ex ...
    ... at pthread_join_common.c:145
main () at prog.c:26
26	  pthread_join(t2, NULL);
Value returned is $1 = 0
(gdb) thread 3
[Switching to thread 3 (Thread 0x7ffff7597700 (LWP 14456))]
#0  f2 (arg=0x0) at prog.c:13
13	  i = i + 20;
(gdb) c
Continuing.
[Thread 0x7ffff7597700 (LWP 14456) exited]
No unwaited-for children left.
(gdb) info threads
  Id   Target Id                                Frame
* 1    Thread 0x7ffff7d99740 (LWP 13943) "prog" main () at prog.c:26
(gdb) n
27	  return 0;
(gdb) c
Continuing.
[Inferior 1 (process 13943) exited normally]
(gdb) quit
$

Comentarii:

- Pentru a urmari fiecare pas al fiecarui thread, trebuia data comanda
 'set scheduler-locking on', dar gdb ar fi afisat eroarea:
     Target 'exec' cannot support this command.
 Atunci am recurs la urmatorul artificiu: am pus un breakpoint la inceputul
 lui 'main()' si i-am asociat o lista care contine comanda de mai sus:

(gdb) break main
Breakpoint 1 at 0x11e9: file prog.c, line 20.
(gdb) commands 1
Type commands for breakpoint(s) 1, one per line.
End with a line saying just "end".
>set scheduler-locking on
>end

 De asemenea, am pus breakpoint-uri la inceputul celor doua threaduri
(liniile 6, 12), altfel ele s-ar fi executat continuu pana la final.

- Apoi, am comutat de mai multe ori intre threadurile 1 (cel principal),
 2 (care executa functia 'f1()') si 3 (care executa functia 'f2()').

- Cand am ajuns in threadul 1 la 'pthread_join(t1, NULL);', am comutat
 pe threadul 3, unde mai intai am iesit din 'clone()' cu 'fin'; inainte
 de a se termina 3, am comutat din nou pe 1, dar la 'n' s-a blocat in
 'pthread_join(t1, NULL);', asteptand threadul 2, care nu se terminase;
 atunci, am intrerupt asteptarea cu Ctrl-c, am primit prompterul gdb,
 am comutat pe threadul 2, apoi am rulat threadul 2 pana la terminare:

(gdb) thread 1
[Switching to thread 1 (Thread 0x7ffff7d99740 (LWP 13943))]
#0  main () at prog.c:25
25	  pthread_join(t1, NULL);
(gdb) n
^C
Thread 1 "prog" received signal SIGINT, Interrupt.
__pthread_clockjoin_ex (threadid=140737351616256, ...
    ... at pthread_join_common.c:145
145	pthread_join_common.c: No such file or directory.
(gdb) thread 2
[Switching to thread 2 (Thread 0x7ffff7d98700 (LWP 13947))]
#0  f1 (arg=0x0) at prog.c:7
7	  i = i + 2;
(gdb) s
8	  i = i + 3;
(gdb) c
Continuing.
[Thread 0x7ffff7d98700 (LWP 13947) exited]
No unwaited-for children left.

- Atunci, am revenit la threadul 1 si cu 'fin' am iesit din
 'pthread_join(t1, NULL);', ajungand la 'pthread_join(t2, NULL);'

- Apoi am comutat pe threadul 3 si l-am rulat pana la terminare,
 dupa care gdb a comutat automat pe threadul 1 si l-am rulat si pe
 el pana la terminare.

Exemplul 9: Atasarea la un proces existent si urmarirea acestuia:
===========

 Deschidem doua console shell avand acelasi directoru curent, le vom numi
1 si 2.
 In consola 1, dam comenzile:

$cat prog.c
#include <stdio.h>
#include <unistd.h>
void f() {
  static unsigned long i = 0;
  while(1) {
    ++i;
    printf("%ld\n", i);
    sleep(1);
  }
}
int main() {
  f();
  return 0;
}
$gcc -Wall -o prog prog.c -ggdb
$

 In consola 2, dam comenzile:

/dev/pts/1
$./prog
1
2
3
 ...

(va incepe sa afiseze numere consecutive la interval de 1 secunda).
 In consola 1, dam comenzile (comanda 'sudo' poate cere parola):

$ps -t /dev/pts/1
    PID TTY          TIME CMD
  11730 pts/1    00:00:00 bash
  17143 pts/1    00:00:00 prog
$sudo gdb prog 17143
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
 ...
Reading symbols from prog...
Attaching to program: /home/dragulici/Desktop/work/prog, process 17143
Reading symbols from /lib/x86_64-linux-gnu/libc.so.6...
Reading symbols from /usr/.../78fe54a5d2c2092f8e47eb0b33105e380f7340.debug...
Reading symbols from /lib64/ld-linux-x86-64.so.2...
Reading symbols from /usr/.../90288cb132a32066848b987fe4bfeb82e54291.debug...
0x00007ffbdd2df1b4 in __GI___clock_nanosleep ...
    ... at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:78
78	../sysdeps/unix/sysv/linux/clock_nanosleep.c: No such file or directory.
(gdb)

Atunci, vom observa ca in consola 1 s-a intrerupt afisarea numerelor
consecutive (deoarece procesul 17143 de acolo a fost interceptat de gdb
si nu va continua decat in urma unor comenzi gdb).
 In consola 1 dam comenzile:

(gdb) n
80	in ../sysdeps/unix/sysv/linux/clock_nanosleep.c
(gdb) fin
Run till exit from #0  __GI___clock_nanosleep ...
    ... at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:80
__GI___nanosleep ... at nanosleep.c:28
28	nanosleep.c: No such file or directory.
Value returned is $1 = 0
(gdb) n
__sleep (seconds=0) at ../sysdeps/posix/sleep.c:62
62	../sysdeps/posix/sleep.c: No such file or directory.
(gdb) fin
Run till exit from #0  __sleep (seconds=0) at ../sysdeps/posix/sleep.c:62
f () at prog.c:6
6	    ++i;
Value returned is $2 = 0
(gdb) n
7	    printf("%ld\n", i);
(gdb) n
8	    sleep(1);
(gdb) n
n
n6	    ++i;
(gdb) n
7	    printf("%ld\n", i);
(gdb) n
8	    sleep(1);
(gdb) n
n
6	    ++i;
(gdb) n
7	    printf("%ld\n", i);

(mai intai, cu 'n' si 'fin' am iesit din urmarirea pas cu pas a functiilor
predefinite, apoi cu 'n' am continuat urmarirea functiei 'f()'); observam ca
la fiecare 'printf()' executat, in consola 2 se mai afisaza un numar, apoi
iar se asteapta.
 Tot in consola 1, dam comanda:

(gdb) detach
Detaching from program: /home/dragulici/Desktop/work/prog, process 17143
[Inferior 1 (process 17143) detached]
(gdb)

(si atunci procesul de la consola 2 se detasaza de gdb si iar afisaza automat
numere consecutive).
 Tot in consola 1 dam comanda:

(gdb) attach 17143
Attaching to program: /home/dragulici/Desktop/work/prog, process 17143
Reading symbols from /lib/x86_64-linux-gnu/libc.so.6...
Reading symbols from /usr/.../78fe54a5d2c2092f8e47eb0b33105e380f7340.debug...
Reading symbols from /lib64/ld-linux-x86-64.so.2...
Reading symbols from /usr/.../90288cb132a32066848b987fe4bfeb82e54291.debug...
0x00007ffbdd2df1b4 in __GI___clock_nanosleep ...
    ... at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:78
78	../sysdeps/unix/sysv/linux/clock_nanosleep.c: No such file or directory.
(gdb)

(si atunci iar se atasaza la gdb procesul respectiv iar afisarea automata a
numerelor se blocheaza).
 Tot in consola 1 dam comanda:

(gdb) kill
Kill the program being debugged? (y or n) y
[Inferior 1 (process 17143) killed]
(gdb)

si atunci procesul urmarit se termina, iar la consola 2 primim prompterul
shell:

 ...
30
31
32
Killed
$

 In final, de la consola 1 incheiem sesiunea gdb:

(gdb) quit
$

 Depanatorul gdb permite investigarea unui fisier core dump (rezultat
in urma terminarii anormale a unui proces), pentru a determina cauza erorii.
Putem folosi comenzile:

core-file
core-file filename
core filename
 ==> specifica locatia unui fisier core dump file spre a fi folosit ca si
    continut al memoriei; un asemenea fisier este generat in unele cazuri de
    terminare anormala a unui program si contine anumite parti din spatiul
    sau de adrese (el poate fi investigat pentru a descoperi datele eronate
    care au cauzat esecul); pentru a accesa celelalte parti, gdb poate accesa
    fisierul executabil insusi;
     'core-file' fara argument specifica ca nu se va folosi nici un core file;
    notam ca fisierul core este ignorat atunci cand programul este in
    executie sub gdb; astfel, daca rulam programul si dorim sa depanam in
    schimb fisierul core (de exemplu, sa inspectam continutul anumitor
    locatii de memorie cu comanda 'x/format adresa'), trebuie sa terminam
    procesul care ruleaza programul, cu comanda 'kill';
     putem de la inceput sa lansam gdb cu indicarea unui executabil si a unui
    core, lansand comanda gdb astfel:
                      gdb <executable> <core-file>

 Observatie:
 Sistemul Linux poate fi setat sa trimita core dump-urile catre un alt
program (piping core dumps to a program) sau catre un fisier; pentru a
seta sistemul sa le trimita intr-un fisier numit 'core' din directorul
curent, vom da comanda:

sudo sysctl -w kernel.core_pattern=core

 Sistemul are o limita maxima pentru fisierele core, care se poate afla
cu comanda:

ulimit -c

Daca limita este 0, inseamna ca nu se pot genera fisiere core. Putem sa
setam aceasta limita la o valoare 'nr' (valoarea este in blocuri) cu
comanda:

ulimit -c nr

Pentru a creste limita, sunt necesare privilegii. Pentru a seta limita
infinita, vom folosi:

ulimit -c unlimited

Exemplul 10: Depanarea unui fisier core:
============

$cat prog.c
int f(int x, int y) {
  if (x <= y)
    return f(x, y % x);
  else
    return f(x % y, y);
}

int main() {
  int z = f(10, 6);
  return z;
}
$gcc -Wall -o prog prog.c -ggdb
$./prog
Floating point exception (core dumped)
$ls -l core
-rw------- 1 dragulici dragulici 245760 Jan 14 02:33 core
$gdb prog core
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
 ...
Reading symbols from prog...
[New LWP 16589]
Core was generated by `./prog'.
Program terminated with signal SIGFPE, Arithmetic exception.
#0  0x0000558954228147 in f (x=0, y=2) at prog.c:3
3	    return f(x, y % x);
(gdb) bt full
#0  0x0000558954228147 in f (x=0, y=2) at prog.c:3
No locals.
#1  0x000055895422816b in f (x=4, y=2) at prog.c:5
No locals.
#2  0x0000558954228156 in f (x=4, y=6) at prog.c:3
No locals.
#3  0x000055895422816b in f (x=10, y=6) at prog.c:5
No locals.
#4  0x0000558954228188 in main () at prog.c:9
        z = 0
(gdb) quit
$

Comentarii:
- Programul lansat cu './prog' a esuat (crash) iar sistemul a lasat
 un fisier 'core' cu imaginea procesului in momentul caderii, pe care
 l-am vazut cu 'ls -l core'.
  Am incarcat executabilul 'prog' si imaginea procesului esuat 'core'
 in gdb, cu 'gdb prog core'.
- Depanatorul gdb ne-a informat ca programul s-a terminat prin primirea
 semnalului 'SIGFPE', ca urmare a unei exceptii aritmetice; inspectand
 stiva de apeluri de functii asa cum era ea in momentul caderii (cu
 comanda 'bt full'), am observat ca, la al 4-lea apel recursiv,
 functia 'f()' a incercat sa calculeze 'y % x' cu 'x=0' si 'y=2',
 deci o impartire la 0.


3.4. Scripting gdb:
-------------------

 Depanatorul gdb poate procesa automat sisteme de comenzi incarcate din
fisiere script.
 Un script (command file) pentru gdb este un fisier text compus din linii de
comanda gdb. Pot fi incluse si comentarii (linii care incep cu '#'). O linie
goala intr-un script nu are nici un efect (nu inseamna repetarea ultimei
comenzi, ca in cazul operarii de la terminal).
 Putem cere executarea unui script cu comanda:

source [-s] [-v] filename
 ==>
 Executa scriptul 'filename'.
 Liniile din script sunt executate secvential, cu exceptia cazului cand
ordinea executarii lor este modificata prin comenzi de control al fluxului
(flow-control commands), a se vedea mai jos. Comenzile nu sunt afisate pe
masura ce sunt executate, daca nu este specificat '-v'. O eroare in
oricare comanda determina terminarea executarii scriptului iar controlul
este returnat consolei.
 Fisierul script invocat este cautat mai intai in directorul curent; daca
nu este gasit iar 'filename' nu specifica un director, scriptul este cautat
in "source search path" (specificat cu comanda 'directory'), cu exceptia ca
nu se cauta in '$cdir', deoarece directorul de compilare nu este relevant
in privinta scripturilor.
 Daca este specificat '-s', atunci 'filename' este cautat in
"search path" chiar daca 'filename' specifica un director; cautarea
este efectuata prin apendarea 'filename' la fiecare element din
"search path"; de exemplu, daca 'filename' este 'mylib/myscript'
iar "search path" contine '/home/user', atunci gdb va cauta scriptul
'/home/user/mylib/myscript'; cautarea este efectuata, de asemenea,
daca 'filename' este o cale absoluta; de exemplu, daca 'filename'
este '/tmp/myscript' iar "search path" contine '/home/user',
atunci gdb va cauta scriptul '/home/user/tmp/myscript'.
 Daca este specificat '-v' (verbose mode), atunci gdb afisaza
fiecare comanda pe masura ce este executata.
 Comenzile care ar cere confirmare atunci cand sunt folosite interactiv
nu o vor mai cere atunci cand sunt folosite intr-un script. Multe
comenzi care in mod normal afisaza mesaje pentru a ne informa despre ceea
ce fac vor omite mesajele cand sunt folosite dintr-un script.

 Depanatorul gdb accepta si scripturi furnizate prin standard input. In acest
mod, outputul normal este emis prin standard output iar outputul de eroare
(de exemplu, mesaje de eroare) este emis prin standard error; de asemenea,
o eroare intr-o comanda nu va termina executarea scriptului ci executia va
continua cu urmatoarea comanda. De exemplu:

gdb < cmds > log 2>&1

vor fi executate comenzile din scriptul 'cmds' iar outputul normal si de
eroare va fi redirectat catre 'log'.

 Intr-un script gdb putem folosi urmatoarele comenzi de control al fluxului
(flow-control commands) pentru a executa comenzi ciclic, conditional, etc.:

if
else
 ==> aceasta comanda permite sa includem in script comenzi executate
  conditional; comanda 'if' primeste un singur argument, care este o expresie
  ce trebuie evaluata; ea este urmata de o serie de comenzi care sunt
  executate doar daca expresia este adevarata (i.e. valoarea ei este
  nonzero); poate exista si o linie 'else' optionala, urmata de o serie de
  comenzi care sunt executate doar daca expresia a fost falsa; sfarsitul
  listei este marcat printr-o linie ce contine comanda 'end';

while
 ==> aceasta comnada permite sa scriem cicluri (loops); ca in cazul 'if',
  comanda primeste un singur argument, care este o expresie ce trebuie
  evaluata si trebuie urmata de lista comenzilor executate in ciclu (corpul
  ciclului), cate una pe linie, lista fiind terminata cu o linie 'end';
  comenzile din corpul ciclului sunt executate repetat cat timp expresia se
  evalueaza ca adevarata;

loop_break
 ==> aceasta comanda determina iesirea (exit) din ciclul 'while' in al
  carui corp a fost inclusa; executia scriptului continua dupa linia
  'end' a acelui ciclu 'while';

loop_continue
 ==> aceasta comanda determina omiterea (skip) executarii restului corpului
  ciclului 'while' in care a fost inclusa; executia trece (branches) la
  inceputul ciclului 'while', unde evalueaza expresia de control.

end
 ==> termina blocul de comenzi care formeaza corpul (body) unui 'if',
  'else', sau 'while'.

 La lansare, gdb executa automat, in ordine, scripturile urmatoare (fisiere
de initializare):
       /etc/gdbinit    (system-wide initialization file)
       ~/.gdbinit      (user initialization file)
       ./.gdbinit      (initialization file for current directory)
 Putem impiedica gdb sa ruleze aceste scripturi folosind optiunile in linia
de comanda '-nx' (nu se executa nici un fisier de initializare), '-nh' (nu se
executa fisierele de initializare din directorul home ci doar cele sistem-wide
si cele din directorul curent).

Exemplul 11:
============

$cat prog.c
int i;
int main() {
  i = 0;
  i = 1;
  i = 2;
  i = 3;
  i = 4;
  i = 5;
  i = 6;
  i = 7;
  i = 8;
  i = 9;
  return 0;
}
$gcc -Wall -o prog prog.c -ggdb
$cat script
l 1,1000
break 5
r
while i < 10
s
if i % 4 == 0
loop_break
end
end
print "valoare curenta"
print i
s
s
c
$gdb prog
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
 ...
Reading symbols from prog...
(gdb) source script
1	int i;
2	int main() {
3	  i = 0;
4	  i = 1;
5	  i = 2;
6	  i = 3;
7	  i = 4;
8	  i = 5;
9	  i = 6;
10	  i = 7;
11	  i = 8;
12	  i = 9;
13	  return 0;
14	}
Breakpoint 1 at 0x1145: file prog.c, line 5.

Breakpoint 1, main () at prog.c:5
5	  i = 2;
6	  i = 3;
7	  i = 4;
8	  i = 5;
$1 = "valoare curenta"
$2 = 4
9	  i = 6;
10	  i = 7;
[Inferior 1 (process 17530) exited normally]
(gdb) quit
$

Exemplul 12:
============

$cat prog.c
int main() {
  int i = 0;
  while(i < 1000)
   ++i;
  while(i < 10000)
   i += 2;
  i = 20000;
  i = 30000;
  i = 40000;
  return 0;
}
$gcc -Wall -o prog prog.c -ggdb
$cat script
l 1,1000
break 5
break 8
start
s
s
s
while i < 100
s
if i % 3 == 0
loop_break
end
end
print "intermediar"
print i
j 5
s
while i < 10
while i % 5 < 3
s
print "interior"
print i
end
s
print "exterior"
print i
end
j 8
s
kill
quit
$gdb prog
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
 ...
Reading symbols from prog...
(gdb) source script
1	int main() {
2	  int i = 0;
3	  while(i < 1000)
4	   ++i;
5	  while(i < 10000)
6	   i += 2;
7	  i = 20000;
8	  i = 30000;
9	  i = 40000;
10	  return 0;
11	}
Breakpoint 1 at 0x1147: file prog.c, line 5.
Breakpoint 2 at 0x115d: file prog.c, line 8.
Temporary breakpoint 3 at 0x1129: file prog.c, line 1.

Temporary breakpoint 3, main () at prog.c:1
1	int main() {
2	  int i = 0;
3	  while(i < 1000)
4	   ++i;
3	  while(i < 1000)
4	   ++i;
3	  while(i < 1000)
4	   ++i;
3	  while(i < 1000)
$1 = "intermediar"
$2 = 3

Breakpoint 1, main () at prog.c:5
5	  while(i < 10000)
6	   i += 2;
5	  while(i < 10000)
$3 = "exterior"
$4 = 5
6	   i += 2;
$5 = "interior"
$6 = 5
5	  while(i < 10000)
$7 = "interior"
$8 = 7
6	   i += 2;
$9 = "interior"
$10 = 7
5	  while(i < 10000)
$11 = "interior"
$12 = 9
6	   i += 2;
$13 = "exterior"
$14 = 9
5	  while(i < 10000)
$15 = "exterior"
$16 = 11

Breakpoint 2, main () at prog.c:8
8	  i = 30000;
9	  i = 40000;
Kill the program being debugged? (y or n) [answered Y; input not from terminal]
[Inferior 1 (process 10884) killed]
$

Comentariu: Observam ca putem avea comenzi de control al fluxului incuibate,
  inclusiv ciclu in ciclu.

TODO: Inregistrarea executarii unui inferior si reluarea ei (record/replay),
     atat inainte cat si inapoi.


4. Taskuri, procese, threaduri:
===============================

Referinte:
[1] Michael Kerrisk:
    The Linux Programming Interface,
    No Starch Press, 2010
[2] Ciprian Oprisa, Adrian Colesa:
    SISTEME DE OPERARE indrumator de laborator,
    Editura UTPRESS, Cluj-Napoca, 2021
    (https://biblioteca.utcluj.ro/files/carti-online-cu-coperta/512-1.pdf)

 Unele exemple au fost preluate sau adaptate, cu anumite modificari, din
 sursele de mai sus.


4.1. Taskuri, apelul 'clone():
------------------------------

 Sistemul de operare Linux implementeaza threadurile in nucleu, in mod
unitar cu procesele, folosind conceptul de 'task'.
 Un task este in acelasi timp o grupare de resurse si un fir de executie.
 Un task este gestionat cu ajutorul unui bloc de control, care este o
structura de tip 'struct task_struct', definit in 'sched.h' si are un
identificator numeric unic la nivelul instantei Linux, pe care il vom
numi TID (task ID) si care este de tip 'pid_t'.
 In memorie este mentinuta in permanenta tabela taskurilor existente,
sub forma unei liste dublu inlantuite de blocuri 'task_struct'.
 Taskurile pot genera taskuri copil care executa acelasi progrm,
folosind apeluri de tip 'fork()', 'vfork()', 'clone()', sau isi pot
schimba programul executat, folosind apeluri din familia 'exec()';
pe baza paternitatii, taskurile se organizeaza intr-o arborescenta,
unica la nivelul instantei Linux.
 Toata discutia de la cursul de 'Utilizarea sistemelor de operare'
privitoare la procese se referea, de fapt, la taskuri.

 Conceptele de proces si thread sunt emulate prin taskuri: in linii mari,
daca doua taskuri au spatii de memorie disjuncte, este emulat conceptul
de proces; daca partajaza un acelasi spatiu de memorie, este emulat
conceptul de thread. Pentru a emula si celelalte elemente care dau
specificitate proceselor si threadurilor, in blocul de control sunt
retinute informatii suplimentare. De exemplu, daca un proces P are un
thread T1 care genereaza alt thread T2, threadul T2 trebuie sa apartina
lui P, nu lui T1 (in calitate de proces). De aceea, nu este suficient sa
se retina intre taskuri doar relatia parinte-copil.
 In blocul de control de tip 'task_struct' al unui task intalnim urmatorii
membri:

struct task_struct {
   ...
 pid_t pid;
 pid_t tgid;
 struct task_struct __rcu * real_parent;
 struct task_struct __rcu * parent;
   ...
 struct task_struct * group_leader;
   ...
}

'pid' este TID-ul taskului considerat; denumirea 'pid' este
  prescurtare de la 'process ID', dar este inselatoare, deoarece
  nu are a face doar cu taskurile de tip proces;
'tgid' este TID-ul taskului caruia ii apartine taskul considerat
  in calitate de thread; taskul 'tgid' modeleaza procesul, taskul
  'pid' modeleaza threadul; taskul 'tgid' s.n. liderul grupului
  de threaduri din care face parte taskul 'pid'; taskul 'tgid'
  este el insusi membru al acestui grup (deci orice proces este si
  un thread al sau); denumirea 'tgid' este prescurtare de la
  'thread group lider';

Atunci cand un task modeleaza un proces, el are 'pid' == 'tid', iar
atunci cand modeleaza un thread care nu este si proces, el are
'pid' != 'tid'. Acest lucru ne permite ca din orice thread al unui
proces sa identificam acelasi proces ca gazda; mai exact, avem
apelurile sistem:

 #include <sys/types.h>
 #include <unistd.h>
 pid_t getpid(void);
   ==> returneaza membrul 'tgid' al taskului curent;
 pid_t getppid(void);
   ==> returneaza membrul 'tgid' al parintelui taskului 'tgid';

 #define _GNU_SOURCE
 #include <unistd.h>
 pid_t gettid(void);
  ==> returneaza membrul 'pid' al taskului curent;
      este Linux specific (non POSIX);
      'man' specifica headerul 'sys/types.h', dar nu este suficient si
       nici necesar (inainte de glibc v2.30 ar fi fost necesar pentru tipul
       'pid_t', dar in momentul de fata acesta este inclus si in 'unistd.h');

Versiunile mai vechi de glibc nu ofera un wrapper pentru apelul sistem real
(raw system call) 'gettid()', asa ca daca dorim sa-l apelam, il putem
invoca indirect cu 'syscall()':

  #include <unistd.h>
  #include <sys/syscall.h>   /* For SYS_xxx definitions */
  long syscall(long number, ...);
    ==> apeleaza apelul sistem real cu numarul 'number', transmitandu-i
         restul argumentelor; e util pentru a invoca apeluri sistem care
         nu au wrapper; pentru numerele apelurilor sistem exista constante
         simbolice definite in 'sys/syscall.h', de forma 'SYS_xxx'; in caz
         de succes, functia returneaza valoarea returnata de apelul sistem,
         in caz de esec, returneaza -1 si seteaza 'errno'.

De exemplu, putem apela:

  syscall(SYS_gettid);

 Asadar, pentru toate taskurile unui grup de threaduri, 'getpid()'
si 'getppid()' returneaza aceeasi valoare, iar pentru fiecare task
din sistem, 'gettid()' returneaza o valoare distincta (anume TID).

'real_parent' este pointer la blocul de control al taskului care a generat
  taskul curent cu 'fork()', 'vfork()', 'clone()');
'parent' este pointer la blocul de control al taskului care va primi
  semnalul SIGCHLD si va primi raport prin 'wait4()' (sau inrudite)
  la terminarea taskului curent; de exemplu, poate fi parintele liderului
  grupului de threaduri din care face parte taskul;
'group_leader' este pointer la blocul de control al liderul grupului de
  threaduri din care face parte taskul;
'__rcu' este un macro definit in 'compiler.h' care permite instrumentelor
  de analiza a codului sa avertizeze in cazul unor deferentieri riscante;
  denumirea este prescurtare de la 'Read-copy-update', care este un algoritm
  ce permite citirea concurenta a unei structuri de date fara a fi nevoie
  sa o blocam (lock).

De exemplu, in urma unei succesiuni de apeluri 'clone()' (care creaza
taskuri copil ce pot fi de tip proces sau thread) si 'fork()' (care creaza
doar taskuri copil de tip proces, putem obtine urmatorul lant de procese (P)
si threaduri (T):
   __________________________________________________________________
  |______________________________________________________            |
  |__________________________________________            |           |
  |         ________    ________    ________ |  ________ |  ________ |
  | _______|    ____|__|    ____|__|    ____||_|    ____||_|        ||
  ||           |    |      |    |      |    ||     |    ||          ||
  VV           V    |      V    |      V    ||     V    ||          ||
rparent     rparent-'   rparent-'   rparent-'|  rparent-'|  rparent-'|
parent      parent      parent      parent---'  parent---'  parent---'
tgid=a      tgid=a      tgid=a      tgid=d      tgid=d      tgid=d
pid=a       pid=b       pid=c       pid=d       pid=e       pid=f
P1 -------> T2 -------> T3 -------> P4 -------> T5 -------> T6
   clone()     clone()     fork()      clone()     clone()

Asadar, instrumentele care vizeaza procese, de exemplu 'getpid()',
'getppid()', 'kill()', etc., vor avea acelasi efect indiferent din ce
thread al procesului sunt apelate.

Avem urmatoarele apeluri sistem:

 #include <linux/unistd.h>
 void exit_group(int status);
   ==> termina toate threadurile procesului din care face parte taskul
        curent (deci, inclusiv taskul curent si liderul grupului de
        threaduri din care face parte); parintele primeste SIGCHLD si
        valoarea 'status  &  0xFF' ca si cod de retur (exit status),
        putand fi colectat cu un apel din familia 'wait()'; este Linux
        specific.

 #include <unistd.h>
 void _exit(int status);
   ==> wrapperul glibc '_exit()' termina procesul curent, inchizand fisierele
        deschise de acesta dar fara a flush-a bufferele stream-urilor stdio;
        parintele primeste SIGCHLD si valoarea 'status  &  0xFF' ca si cod de
        retur (exit status), putand fi colectat cu un apel din familia
        'wait()'; efectul este similar cu cel al lui 'exit()', dar nu sunt
        apelate functiile inregistrate cu 'atexit()' sau 'on_exit(3)';
        incepand cu versiunea glibc 2.3, wrapperul invoca 'exit_group()';
       inainte de versiunea glibc 2.3, wrapperul '_exit()' invoca apelul
        sistem real (raw system call) '_exit()', care  termina doar threadul
        curent.

 Incepand cu versiunea glibc 2.3, daca dorim apelul sistem real '_exit()',
 il putem invoca indirect cu 'syscall()':

  syscall(SYS_exit, error_code);

 Taskurile pot fi asteptate sa-si schimbe starea (terminat, suspendat,
reluat, etc.) cu apelurile sistem 'wait4()', 'waitid()', 'waitpid()' si
functia de biblioteca 'wait()' (echivalenta cu 'waitpid(-1, &wstatus, 0)');
acestea au fost partial prezentate si in cursul de USO. Prezentam pe scurt
'waitid()':

  #include <sys/types.h>
  #include <sys/wait.h>
  int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
    ==>
  asteapta ca taskul copil indicat de 'id' sa-si schimbe starea (daca deja
    si-a schimbat-o, nu asteapta); in caz de succes sau daca a fost
    specificat 'WNOHANG' si nici un copil specificat de 'id' nu si-a schimbat
    starea, returneaza 0, in caz de eroare, returneaza -1 si seteaza 'errno';
  pot fi asteptati copii ai taskului apelant sau ai taskurilor din acelasi
    grup de threaduri (a se vedea '__WNOTHREAD');
  'idtype' poate fi 'P_PID' (se asteapta taskul cu TID-ul 'id') sau 'P_ALL'
     (se asteapta orice copil, 'id' este ignorat);
  in '*infop' vom obtine informatii despre copil/copii asteptati;
     membrul 'si_pid' va contine TID-ul copilului; in Linux (non POSIX), daca
     'infop' = 'NULL', 'waitid()' returneaza TID-ul copilului;
  'options' este o disjunctie pe biti '|' de de urmatoarele constante, avand
     semnificatiile:
  'WEXITED': astepata copii terminati;
  'WSTOPPED': asteapta copii stopati prin semnal;
  'WCONTINUED': asteapta copii stopati prealabil si treziti prin 'SIGCONT';
  'WNOHANG': returneaza imediat (nu asteapta);
  'WNOWAIT': lasa copilul intr-o stare asteptabila (un 'wait()' ulterior
    poate recupera status-ul copilului);
  urmatoarele constante sunt Linux specific:
  '__WCLONE': asteapta doar copii "clone" (i.e. care la terminare nu trimit
    semnale sau trimit alt semnal decat 'SIGCHLD'; daca este omis, asteapta
    doar copii "non-clone"; este ignorat daca folosim si '__WALL';
  '__WALL': asteapta orice copil, indiferent daca este "clone" sau
    "non-clone"; este implicit daca copilul este urmarit ptraced (de exemplu,
    pentru depanare);
  '__WNOTHREAD': nu asteapta copiii altor threaduri din acelasi grup; era
    implicit inainte de Linux 2.4.

 Taskurile pot genera taskuri copil care executa acelasi program, folosind
apeluri sistem 'fork()', 'vfork()' sau 'clone()' (mai flexibil). Apelul
'fork()' a fost prezentat in cursul de USO. Detaliem in continuare apelul
'clone()'. Exista un apel sistem real 'clone()' (raw system call) (se poate
apela cu 'syscall()' si 'SYS_clone') si o functie wrapper glibc 'clone()'
deasupra lui. In continuare, prezentam wrapperul glibc:

  #define _GNU_SOURCE
  #include <sched.h>
  int clone(int (*fn)(void *), void *stack, int flags, void *arg, ...
                 /* pid_t *parent_tid, void *tls, pid_t *child_tid */ );

    ==>

  Creaza un task copil.

  Copilul isi incepe executia apeland functia pointata de 'fn' si cu
 argumentul 'arg' (spre deosebire de 'fork()', unde executia continua in
 copil de la punctul de iesire din 'fork()'); cand 'fn(arg)' returneaza,
 copilul se termina iar intregul returnat de 'fn' devine codul de retur
 (exit status) al copilului; copilul se poate termina, de asemenea, in mod
 explicit apeland 'exit()' sau dupa primirea unui semnal fatal.

   Argumentul 'stack' specifica locatia stivei utilizate de copil. Daca
 parintele si copilul au memorii separate (ca in cazul 'fork()'), nu este
 o problema daca copilul foloseste aceasi zona de spatiu virtual pentru
 stiva ca si parintele (practic, continua secventa de apeluri de functii
 inceputa de parinte, dar operand pe copia stivei acestuia). Daca, insa,
 parintele si copilul partajaza memoria (ceea ce se poate specifica la
 'clone()'), atunci copilului trebuie sa i se ofere o alta zona de spatiu
 virtual pentru stiva, altfel secventele de apeluri de functii executate
 in paralel in parinte si copil isi vor suprascrie datele intr-o aceeasi
 zona de spatiu fizic. De aceea, apelantul lui 'clone()' trebuie sa
 pregateasca o zona de memorie pentru stiva copilului si transmita un
 pointer catre aceasta lui 'clone()', ca argument 'stack'. In majoritatea
 arhitecturilor unde este folosit Linux (inclusiv x86), stiva creste in
 jos, de aceea 'stack' indica adresa limita superioara a zonei rezervate.
 Notam ca 'clone()' nu ofera un mijloc prin care apelantul sa poata
 informa kernelul cu privire la dimensiunea zonei stiva (lucru remediat
 de 'clone3()', care este mai nou).

   Ultimele argumente (corespunzatoare lui '...') sunt optionale si au
 relevanta in functie de valorile argumentlui 'flags'.

   Octetul low al argumentului 'flags', adica 'flags & 0xff', specifica
 semnalul care va fi trimis parintelui la terminarea copilului. Daca valoarea
 este 0, nu va fi transmis nici un semnal. Daca valoarea este diferita de
 SIGCHLD (inclusiv daca este 0), se spune ca este un copil "clone", altfel
 este un copil "non clone". Copii "clone" pot fi asteptati de functiile din
 familia 'wait()' doar daca sunt folosite si optiunile '__WALL' (atunci sunt
 asteptati toti copii, "clone" sau "non clone") sau '__WCLONE' (atunci sunt
 asteptati doar copii "clone").

  Partea hi a argumentului 'flags', adica 'flags & ~0xff', contine o
 masca pe biti care specifica o modificare a comportamentului si precizeaza
 ce este partajat intre parinte si copil. Aceasta masca pe biti se poate
 construi ca o disjunctie pe biti de 0 sau mai multe constante simbolice
 predefinite. Prezentam cateva dintre acestea:

 CLONE_VFORK (incepand cu Linux 2.2)
 cu 'CLONE_VFORK ', executia apelantului este suspendata pana ce copilul
  elibereaza resursele sale referitoare la memoria virtuala, via un
  apel 'execve()' sau '_exit()' (ca in cazul lui 'vfork()');
 fara 'CLONE_VFORK ', atata apelantul cat si copilul sunt planificabile
  la executie dupa apel (i.e. isi continua executia in paralel), iar o
  aplicatie nu ar trebui sa se bazeze pe o anumita ordine a executarii lor;

 CLONE_VM (incepand cu Linux 2.0)
 cu 'CLONE_VM', apelantul si copilul ruleaza in acelasi spatiu de memorie;
  in particular, scrierile in memorie efectuate de unul din ele sunt vizibile
  in celalalt; mai mult, maparile/demaparile de memorie efectuate cu
  'mmap()'/'munmap()' de unul dintre ele il afecteaza si pe celalalt;
 fara 'CLONE_VM', copilul ruleaza intr-o copie separata a spatiului de
  memorie al apelantului de la momentul apelarii lui 'clone()'; scrierile in
  memorie sau maparile/demaparile de fisiere efectuate de unul dintre ele
  nu-l afecteaza pe celalalt (ca la 'fork()').

 CLONE_FILES (incepand cu Linux 2.0)
 cu 'CLONE_FILES', apelantul si copilul partajaza aceeasi tabela de
  descriptori de fisiere (deci, nu se face o copie - orice descriptor
  deschis/inchis/setat cu 'fcntl()' si 'F_SETFD' de unul dintre taskuri are
  aceleasi caracteristici si in celalalt); daca ulterior unuil dintre taskuri
  apeleaza 'execve()', tabela sa de descriptori de fisiere este duplicata
  (deci, ne-partajata);
 fara 'CLONE_FILES', copilul mosteneste o copie a tabelei de descriptori de
  fisiere a apelantului, asa cum erau ei la momentul apelarii lui 'clone()';
  operatiile ulterioare de deschidere/inchidere/setare efectuate de unul
  dintre taskuri nu il mai afecteaza pe celalalt; notam, totusi, ca
  descriptorii de fisiere duplicati refera respectiv aceleasi intrari in
  tabela deschiderilor de fisiere de la nivelul sistemului (TDF) si de aceea
  opereaza cu respectiv aceleasi offseturi in fisier, moduri de acces
  (citire, scriere) si file status flags ('O_APPEND', etc.);

 CLONE_FS (incepand cu Linux 2.0)
 cu 'CLONE_FS', apelantul si copilul partajaza informatiile despre sistemul
  de fisiere (filesystem information): directorul radacina al sistemului de
  fisiere, directorul curent, masca de drepturi 'umask', etc.; apelurile
  'chroot()' (schimba directorul radacina luat in considerare la parcurgerea
  cailor ce incep cu '/'), 'chdir()' (schimba directorul curent), 'umask()'
  (schimba masca de drepturi) efectuate de unul din taskuri il afecetaza si
  pe celalalt; fara 'CLONE_FS', copilul primeste o copie a informatiilor
  despre sistemul de fisiere ale apelantului de la momentul apelarii lui
  'clone()';

 CLONE_SIGHAND (since Linux 2.0)
 cu 'CLONE_SIGHAND', apelantul si copilul partajaza aceeasi tabela de
  handlere de semnal; daca unul din ei apeleaza 'sigaction()' pentru a
  schimba comportamentul asociat unui semnal, schimbarea afecteaza
  si pe celalalt; totusi, apelantul si copilul au seturi distincte de
  semnale aflate in pending si de semnale blocate - deci, unul dintre
  ei poate bloca sau debloca semnale folosind 'sigprocmask()' fara
  a-l afecta pe celalalt;
 fara 'CLONE_SIGHAND', copilul mosteneste o copie a handlerelor de semnal
  ale apelantului de la momentul apelarii lui 'clone()' iar apelurile
  ulterioare ale lui 'sigaction()' efectuate de unul dintre ei nu il
  afecteaza pe celalalt;
 incepand cu Linux 2.6.0, daca 'flags' include 'CLONE_SIGHAND', ea
  trebuie sa includa si 'CLONE_VM';

 CLONE_CLEAR_SIGHAND (incepand cu Linux 5.5)
 fara 'CLONE_CLEAR_SIGHAND', handlerele de semnal (signal dispositions)
   din copil sunt aceleasi ca in parinte;
 cu 'CLONE_CLEAR_SIGHAND', in copil handlerele sunt resetate la cele
   implicite (SIG_DFL);
 nu are sens si nu este permisa specificrea acestui flag impreuna cu
   'CLONE_SIGHAND';

 CLONE_PARENT (incepand cu Linux 2.3.12)
 cu 'CLONE_PARENT', parintele copilului creat (asa cum este returnat de
  'getppid()') va fi acelasi ca al apelantului.
 fara 'CLONE_PARENT' (ca la 'fork()'), parintele copilului creat (asa cum
  este returnat de 'getppid()') este procesul apelant (asa cum este
  returnat de 'getpid()' apelat in taskul apelant - asadar, este 'tgid'-ul
  apelantului);

 CLONE_THREAD (incepand cu Linux 2.4.0;
               incepand cu Linux 2.5.35, trebuie adaugat cu el si
               'CLONE_SIGHAND', iar acesta, de la Linux 2.6.0,
               necesita si adaugarea lui CLONE_VM)
 cu 'CLONE_THREAD', copilul este plasat in acelasi grup de threaduri ca
  si apelantul (va avea alt TID, adica 'pid', dar acelasi 'tgid'); functia
  returneaza apelantului TID-ul copilului; noul task va avea acelasi parinte
  ca si apelantul (ca in cazul 'CLONE_PARENT'), deci 'getppid()' returneaza
  aceeasi valoare pentru toate taskurile dintr-un grup de threaduri;
  la terminarea noului task, apelantul nu va primi SIGCHLD sau alt semnal
  de terminare; de asemenea, la terminarea noului task, nu se poate
  obtine status-ul lui cu 'wait()' - spunem ca threadul este  detasat
  (detached);
 fara 'CLONE_THREAD', noul task este plasat intr-un nou grup de threaduri,
  unde este si lider (va avea 'tgid' == 'pid');
 dupa ce toate taskurile dintr-un grup de threaduri se termina, parintele
  liderului primeste un SIGCHLD (sau alt semnal de terminare);
 daca vreunul dintre taskurile dintr-un grup de threaduri efectueaza un
  'execve()', atunci toate taskurile din grup in afara de lider se termina
  iar noul program este executat in lider (ia locul liderului);
 daca vreunul dintre taskurile dintr-un grup de threaduri creaza un copil
  cu 'fork()', atunci orice task din grup poate astepta copilul cu 'wait()';
 daca un task primeste un semnal fara handler asociat (unhandled), atunci
  toate taskurile din acelasi grup de threaduri vor fi afectate (terminate,
  stop, continue, be ignored in);
 fiecare task are propria masca de semnale blocate, setabila cu 'sigprocmask()';
 un semnal poate fi directionat catre un proces (process-directed) sau catre
  un thread (thread-directed);
 un semnal process-directed tinteste un grup de threaduri (i.e. un 'tgid') si
  este livrat unui task selectat arbitrar dintre taskurile din grup care nu
  blocheaza semnalul; un semnal este process-directed atunci cand este
  generat de kernel pentru alte motive decat exceptii hardware, sau deoarece
  a fost trimis folosind 'kill()' sau 'sigqueue()'
 un semnal thread-directed tinteste un task specific si este asa atunci cand
  a fost trimis folosind 'tgkill()' sau 'pthread_sigqueue()', sau deoarece
  taskul a executat o instructiune masina care a declansat o exceptie hardware
  (de exemplu, invalid memory access, care declansaza SIGSEGV sau floating-point
  exception, care declansaza SIGFPE);
 un apel 'sigpending()' furnizeaza o multime de semnale care este totalitatea
  semnalelor process-directed aflate in pending si a semnalelor thread-directed
  aflate in pending pentru taskul apelant;
 daca un semnal process-directed este livrat unui grup de threaduri iar grupul
  de threaduri a instalat un handler pentru acel semnal, atunci handlerul va fi
  invocat in exact unul, selectat arbitrar, dintre taskurile membru care nu a
  blocat semnalul; daca mai multe taskuri dintr-un grup asteapta sa accepte
  acelasi semnal folosind 'sigwaitinfo()', kernelul va selecta unul dintre ele
  arbitrar ca sa primeasca semnalul;

 CLONE_PTRACE (incepand cu Linux 2.2)
 daca apelantul este urmarit (traced), atunci va fi urmarit si copilul
  (a se vedea apelul 'ptrace()');

 CLONE_UNTRACED (incepand cu  Linux 2.5.46)
 cu 'CLONE_UNTRACED', un proces urmaritor (tracing process) nu poate forta
  'CLONE_PTRACE' pe acest copil;

  Apelul sistem 'clone()' (raw clone() system call) are un prototip dependent
de arhitectura, de exemplu, pentru x86-64, avem:

  long clone(unsigned long flags, void *stack,
             int *parent_tid, int *child_tid, unsigned long tls);

Efectul acestuia corespunde mai mult lui 'fork()', in sensul ca executia in
copil continua de la punctul de iesire din apel; de aceea, argumentele 'fn'
si 'arg' lipsesc. De asemenea, spre deosebire de wrapperul glibc, raw clone()
system call accepta NULL ca argumet 'stack', caz in care copilul foloseste
stiva parintelui; in acest caz, nu ar trebui specificat 'CLONE_VM', deoarece
parintele si copilul si-ar suprascrie datele in aceeasi memorie folosita ca
stiva; fara 'CLONE_VM', copilul ar primi un duplicat al stivei parintelui
(in semantica Copy-on-write - o pagina se va duplica doar atunci cand unul
dintre cele doua procese sa modifice ceva in ea).

Notam ca in arhitectura x86-64, instructiunea masina de apel de functie
'call' salveaza adresa de retur pe stiva, inainte de a trece executia
catre codul functiei, iar instructiunea masina de revenire din apel 'ret'
extrage de pe stiva adresa unde se va reveni. De aceea, daca folosim
raw clone() system call, de exemplu:

  #include <unistd.h>
  #include <sys/syscall.h>   /* For SYS_xxx definitions */
  ret = syscall(SYS_clone, flags, stack, parent_tid, child_tid, tls);

atunci, in copil, la revenirea din 'clone()' se va executa returul
din 'syscall()', stiva curenta ramanand cea indicata de 'stack' iar
instructiunea 'ret' va trebui sa gaseasca pe aceasta stiva adresa corecta
de retur - cea a instructiunii de dupa 'ret = ...'; de aceea, daca nu
folosim stack == NULL, trebuie sa indicam o stiva corect initializata cu
aceasta adresa: alocam stiva, scriem la sfarsit adresa de retur, apoi
transmitem ca argument 'stack' adresa de sfarsit a zonei alocate minus
sizeof-ul adresei scrise (reamintim ca stiva creaste in jos).

In 'man 2 clone' se mentioneaza ca wrapperul glibc 'clone()' modifica
memoria pointata de 'stack' inainte de a invoca raw clone() system call.
De aceea, in cazul cand 'clone()' este folosit pentru a crea copii recursiv,
nu trebuie folosit bufferul indicat ca stiva pentru parinte pentru a indica
stiva copilului. Se recomanda, de asemenea, ca stiva pentru copil sa se
aloce cu 'mmap()' in loc de 'malloc()', deoarece:
- 'mmap()' aloca un bloc de memorie care incepe de la un inceput de pagina
 si are un numar intreg de pagini; aceasta este util daca vrem sa stabilim
 la sfarsitul blocului o pagina de garda (i.e. cu protectie 'PROT_NONE',
 folosind 'mprotect()') -  atunci, incercarea copilului de a depasi aceasta
 limita il va termina cu segmentation fault si nu va risca sa altereze
 alta zona de memorie, pe care o partajaza cu alte threaduri;
- putem specifica la 'mmap()' flagul 'MAP_STACK' pentru a solicita o mapare
 potrivita pentru stiva; deocamdata, acest flag nu este operational in Linux
 dar exista si are efect in alte sisteme; de aceea, ar trebui inclus pentru
 portabilitate.

Valoarea returnata de wrapperul 'clone()' are sens doar in apelant,
deoarece in copil se apeleaza 'fn' si apoi copilul se termina. In
caz de succes, valoarea returnata in apelant este TID-ul copilului,
iar in caz de esec, nu se creaza copii, valoarea returnata in apelant
este -1 si se seteaza 'errno'.

Urmatoare descriere pseudocod ilustreaza modul in care wrapperele 'clone()'
si 'fork()' sunt scrise deasupra raw clone() system call (preluat de la:
https://stackoverflow.com/questions
/18904292/is-it-true-that-fork-calls-clone-internally#18904917
):

Wrapperul 'clone()':

clone(void (*fn)(void *), void *stack_pointer)
{
    push fn onto stack_pointer
    syscall_clone()
    if (child) {
        pop fn off of stack
        fn();
        exit(); /* in sensul lui '_exit()' raw system call */
    }
}

Wrapperul 'fork()':

fork()
{
    ...
    syscall_clone();
    ...
}

 Taskurile se pot substitui cu functiile din familia 'exec()'; pentru
detalii, a se revedea cursul de USO si detaliile de la 'CLONE_THREAD'
mai sus.

 Putem atrimite semnale process-directed cu 'kill()' (a se revedea cursul
de USO) sau 'sigqueue()' (care pe langa semnal permite si trimiterea unui
item de date) si putem trimite semnale thread-directed cu:

 int tkill(int tid, int sig);
 int tgkill(int tgid, int tid, int sig);
  ==>
 'tgkill()' trimite semnalul 'sig' threadului cu TID-ul 'tid' din grupul de
   threaduri 'tgid'; prin contrast, 'kill()' trimite un semnal unui proces,
   i.e. unui 'tgid', ca un intreg, semnalul va fi furnizat unui thread
   arbitrar al procesului;
 'tkill()' este o varianta invechita (de evitat), care permite doar
   specificarea TID-ului tintei, ceea ce poate face ca sa fie semnalizat un
   thread gresit, daca threadul dorit s-a terminat iar TID-ul sau a fost
   reciclat;
 in caz de succes, functiile returneaza 0, in caz de esec, ele returneaza -1
   si seteaza 'errno';
 nu exista wrappere glibc pentru aceste apeluri sistem, trebuie folosit
   'syscall()'.

Exemplul 1:
===========

#define _GNU_SOURCE
#include <unistd.h>
#include <sched.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

int i;

void print(char *arg) {
  printf("%s: TID: %d PID: %d PPID: %d i: %d\n",
         (char *)arg, (int)gettid(), (int)getpid(), (int)getppid(), i);
}

int f(void *arg) { i = i * 10; print(arg); return i; }

void h(int n) {
  signal(n, h);
  printf("Taskul TID: %d a primit semnalul: %d\n", (int)gettid(), n);
}

int main() {
  char *stack;    /* adresa inferioara a bufferului stiva */
  char *stackTop; /* adresa superioara abufferului stiva */
  pid_t id;
  long page_size = sysconf(_SC_PAGE_SIZE);
  int stack_size = 100;
  int status;

  for(i = 1; i < NSIG; ++i) signal(i, h);

  stack = mmap(NULL, stack_size * page_size, PROT_READ | PROT_WRITE,
                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);
  if (stack == MAP_FAILED) {perror("mmap()"); exit(1);}
  mprotect(stack, page_size, PROT_NONE);      /* pagina de garda */
  stackTop = stack + stack_size * page_size;  /* presupunem ca stiva creste in jos */

  /* Cream un proces copil */
  i = 1;
  print("Apelant");
  id = clone(f, stackTop,
             SIGCHLD,
             "Proces nou");
  if (id == -1) {perror("clone()"); exit(1);}
  sleep(1);
  print("Revenire in apelant");
  waitpid(id, &status, 0);
  if(WIFEXITED(status)) printf("Cod retur proces nou: %d\n\n", WEXITSTATUS(status));

  /* Cream un thread copil */
  i = 2;
  print("Apelant");
  id = clone(f, stackTop,
             CLONE_THREAD | CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND,
             "Thread nou");
  if (id == -1) {perror("clone()"); exit(1);}
  sleep(1);
  print("Revenire in apelant");
  waitpid(id, NULL, __WALL);
    /* deoarece am folosit 'CLONE_THREAD', copilul nu va fi asteptat decat
       daca folosim '__WALL', parintele nu va primi semnal la terminare si nu
       poate culege cod de retur */
  printf("\n");

  /* Cream un proces copil care partajaza memoria cu parintele */
  i = 3;
  print("Apelant");
  id = clone(f, stackTop,
             CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | SIGCHLD,
             "Proces - thread nou");
  if (id == -1) {perror("clone()"); exit(1);}
  sleep(1);
  print("Revenire in apelant");
  waitpid(id, &status, 0);
  if(WIFEXITED(status)) printf("Cod retur proces nou: %d\n\n", WEXITSTATUS(status));

  return 0;
}

La executare, se obtine:

Apelant: TID: 4174 PID: 4174 PPID: 3542 i: 1
Proces nou: TID: 4175 PID: 4175 PPID: 4174 i: 10
Taskul TID: 4174 a primit semnalul: 17
Revenire in apelant: TID: 4174 PID: 4174 PPID: 3542 i: 1
Cod retur proces nou: 10

Apelant: TID: 4174 PID: 4174 PPID: 3542 i: 2
Thread nou: TID: 4176 PID: 4174 PPID: 3542 i: 20
Revenire in apelant: TID: 4174 PID: 4174 PPID: 3542 i: 20

Apelant: TID: 4174 PID: 4174 PPID: 3542 i: 3
Proces - thread nou: TID: 4177 PID: 4177 PPID: 4174 i: 30
Taskul TID: 4174 a primit semnalul: 17
Revenire in apelant: TID: 4174 PID: 4174 PPID: 3542 i: 30
Cod retur proces nou: 30

Comentarii:
- In cazul 'proces':
  taskul creat are 'pid' = 'tgid' (este proces);
  'getppid()' in noul task = 'getpid()' in apelant, adica noul task este
    copilul apelantului in sensul proceselor;
  modificarea lui 'i' in noul task nu a afectat apelantul (au memorii
    diferite, duplicate copy-on-write);
  la terminarea noului task, apelantul a primit semnalul SIGCHLD (17) si
    codul sau de retur 10.
- In cazul 'thread':
  taskul creat are 'pid' != 'tgid' (este thread);
  'getpid()' in noul task = 'getpid()' in apelant, adica noul task este
     thread intr-un acelasi proces, altfel spus, cele doua taskuri au
     aceeasi identitate ca proces;
  'getppid()' in noul task = 'getppid()' in apelant, adica cele doua taskuri
     au acelasi proces parinte;
   modificarea lui 'i' in noul task a afectat apelantul (partajaza aceeasi
     memorie);
   la terminarea noului task, apelantul nu a primit vreun semnal si nici
     codul de retur (de fapt, nici nu am incercat sa-l recuperam).
- In cazul 'proces - thread':
  taskul creat are 'pid' = 'tgid' (este proces);
  'getppid()' in noul task = 'getpid()' in apelant, adica noul task este
    copilul apelantului in sensul proceselor;
   modificarea lui 'i' in noul task a afectat apelantul (partajaza aceeasi
     memorie);
  la terminarea noului task, apelantul a primit semnalul SIGCHLD (17) si
    codul sau de retur 30.
- folosirea lui 'clone()' fara 'CLONE_THREAD' dar cu 'CLONE_VM' este un
     compromis intre procese si threaduri, care ne permite sa cream taskuri
     ce partajaza memoria (comportament specific threadurilor) dar care
     trimit semnal la terminare si sunt asteptabile ('waitpid()');
  ele au 'pid' == 'tgid', deci sunt procese.
- apelurile 'sleep(1)' au incercat sa forteze o anumita ordine la executie,
    anume noul task si apoi continuarea apelantului, pentru a vedea daca
    modificarea lui 'i' in noul task afecteaza pe 'i' din apelant;
  folosirea lui 'sleep()' nu este, insa, o cale sigura, deoarece din program
    nu putem face presupuneri asupra ordinii la executie sau a duratelor
    fizice.

Exemplul 2:
===========

Vom studia mai atent stabilirea relatiilor de paternitate si setarea
valorilor 'pid', 'tgid', creand urmatoarea arborescenta de procese (P) si
threaduri (T):

     / T1 -- T2 -- P3 -- T4 -- T5
P0 --
     \ T6 -- T7

#define _GNU_SOURCE
#include <sched.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

void print(int n) {
  int k;
  for(k = 0; k < n; ++k) printf(" ");
  printf("task %d: PPID: %d  PID: %d  TID: %d\n",
    n, (int)getppid(), (int) getpid(), (int)gettid());
}

void *baza, *varf; long page_size;
#define proces(I)\
clone(f, baza - ((I[8] - '0') * page_size), SIGCHLD, I)
#define thread(I)\
clone(f, baza - ((I[8] - '0') * page_size),\
CLONE_THREAD | CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, I)

int f(void *arg) {
  pid_t p; char *str, buffer[100]; int n, k, s;
  str = arg; n = str[0] - '0'; ++str;
  for(k = 0; k < n; ++k) buffer[k] = ' ';
  sprintf(buffer + n, "%s: PPID: %d  PID: %d  TID: %d\n",
    str, (int)getppid(), (int) getpid(), (int)gettid());
  write(1, buffer, strlen(buffer));
  n = str[7] - '0';
  switch(n) {
    case 0: thread("2Thread 1");
            thread("2Thread 6");
            sleep(3);
            return 0;
    case 1: thread("4Thread 2");
            sleep(1);
            while((p = wait(&s)) != -1) {
              sprintf(buffer, "TID: %d  PID: %d a interceptat ID: %d cu exit code: %d\n",
                     (int)gettid(), (int) getpid(), (int)p, WEXITSTATUS(s));
              write(1, buffer, strlen(buffer));
            }
            return 1;
    case 2: proces("6Proces 3"); return 2;
    case 3: thread("8Thread 4"); return 3;
    case 4: thread(";Thread 5"); return 4;
    case 6: thread("4Thread 7"); return 6;
    case 7: return 7;
  }
  return 0; // unreachable
}

int main() {
  page_size = sysconf(_SC_PAGE_SIZE);
  if((varf = valloc(10 * page_size)) == NULL) {perror("valloc"); return 1;}
  baza = varf + 10 * page_size;
  f("0Proces 0");
  return 0;
}

La executare, se poate obtine:

Proces 0: PPID: 3542  PID: 4250  TID: 4250
  Thread 1: PPID: 3542  PID: 4250  TID: 4251
    Thread 2: PPID: 3542  PID: 4250  TID: 4253
  Thread 6: PPID: 3542  PID: 4250  TID: 4252
      Proces 3: PPID: 4250  PID: 4254  TID: 4254
    Thread 7: PPID: 3542  PID: 4250  TID: 4255
        Thread 4: PPID: 4250  PID: 4254  TID: 4256
           Thread 5: PPID: 4250  PID: 4254  TID: 4257
TID: 4251  PID: 4250 a interceptat ID: 4254 cu exit code: 3

Comentarii:
- Observam ca taskurile 0, 1, 2, 6, 7 sunt threaduri ale lui 0 (au valoarea
 'getpid()' 4250 si TID-uri diferite) iar taskurile 3, 4, 5 sunt threaduri
 ale lui 3 (au valoarea 'getpid()' 4254 si TID-uri diferite).
- Desi 'wait()' a fost apelat in 1, s-a considerat ca procesul 0 asteapta
 procesul copil 3 - acesta a fost singurul task asteptabil; blocat in
 'wait()'a fost insa 1.
- Procesul 0 apeleaza 'sleep()' pentru a permite tuturor threadurilor
 sale 1, 2, 6, 7 sa se termine normal; reamintim ca terminarea normala
 (return din 'main()' sau 'exit()') a unui proces determina automat
 terminarea fortata a tuturor threadurilor sale ('exit_group()') dar nu si
 a proceselor copil (ele sunt adoptate de 'init'); in cazul procesului 3 nu
 a fost nevoie de 'sleep()' pentru a permite terminarea threadurilor sale
 4 si 5 sa se termine, deoarece 3 a fost creat cu 'clone()' a.i. la sfarsitul
 lui 'f()' sa se termine doar el ca thread ('_exit()' raw system call).
  Terminarea lui 2 nu ar determina nici terminarea lui 3 nici adoptarea
 lui 3 de catre 'init', daca 0 nu s-a terminat.
  Daca 0 se termina prematur, 2 se poate termina inainte de a-l crea pe 3;
 de asemenea, daca 1 ajunge in 'wait()' inainte ca 2 sa creeze 3, nu va
 astepta; de aceea, 1 a apelat 'sleep(1)' iar 0 a apelat 'sleep(3)'.
- Sirurile afisate de fiecare task nu au fost scrise pe standard output
 direct cu 'printf()' ci au fost construite pe stiva proprie si scrise cu
 'write(1)' deoarece bufferul 'FILE' al lui 'stdout' este in zona partajata
 cu alte taskuri si ar fi putut aparea conditii de cursa.

Exemplul 3:
===========

Vom studia modul cum sunt asteptate procesele copil in threadurile procesului
parinte si cum sunt transmise semnalele catre procese si threaduri, creand
arborescenta:

     / T1 -- T2 -- P3 -- T4 (trimite semnale lui P0 si T1)
P0 --
     \ T5 (asteapta P3)

#define _GNU_SOURCE
#include <sched.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

void *baza, *varf; long page_size;
#define proces(I)\
clone(f, baza - ((I[0] - '0') * page_size), SIGCHLD, I)
#define thread(I)\
clone(f, baza - ((I[0] - '0') * page_size),\
CLONE_THREAD | CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, I)

#define print(S) {\
  char buffer[1024];\
  sprintf(buffer, "PPID: %d  PID: %d  TID: %d ( %s )\n",\
    (int)getppid(), (int) getpid(), (int)gettid(), (char *)(S));\
  write(1, buffer, strlen(buffer));\
}

#define scrie(...) {\
  char buffer[2048];\
  sprintf(buffer, __VA_ARGS__);\
  write(1, buffer, strlen(buffer));\
}

void h(int n) {
  signal(n, h);
  scrie("Taskul TID: %d a primit semnalul: %d\n", (int)gettid(), n);
}

pid_t p0, t1, p3;
int f(void *arg) {
  print(arg);
  switch(((char *)arg)[0] - '0') {
    case 0: p0 = gettid(); t1 = thread("1"); thread("5"); sleep(1); sleep(1); sleep(2); break;
    case 1: thread("2");  while(1) pause(); break;
    case 2: p3 = proces("3"); while(1) pause(); break;
    case 3: thread("4"); break;
    case 4: sleep(1);
            kill(p0, SIGUSR1); tgkill(p0, t1, SIGUSR2);
            break;
    case 5: {int status; pid_t tid;
             sleep(1);
             tid = waitpid(p3, &status, 0);
             if(WIFEXITED(status))
               scrie("Taskul TID = %d"
                     " a detectat terminarea taskului TID = %d"
                     " cu codul de retur = %d\n\n",
                     (int)gettid(), (int)tid, WEXITSTATUS(status));
            } while(1) pause(); break;
  }
   return 0;
}

int main() {
  page_size = sysconf(_SC_PAGE_SIZE);
  if((varf = valloc(10 * page_size)) == NULL) {perror("valloc"); return 1;}
  baza = varf + 10 * page_size;
  signal(SIGUSR1, h); signal(SIGUSR2, h); signal(SIGCHLD, h);   signal(SIGSEGV, h);
  f("0");
  return 0;
}

La executare, se poate obtine:

PPID: 3542  PID: 10964  TID: 10964 ( 0 )
PPID: 3542  PID: 10964  TID: 10966 ( 5 )
PPID: 3542  PID: 10964  TID: 10965 ( 1 )
PPID: 3542  PID: 10964  TID: 10967 ( 2 )
PPID: 10964  PID: 10968  TID: 10968 ( 3 )
PPID: 10964  PID: 10968  TID: 10969 ( 4 )
Taskul TID: 10965 a primit semnalul: 10
Taskul TID: 10965 a primit semnalul: 12
Taskul TID: 10967 a primit semnalul: 17
Taskul TID = 10966 a detectat terminarea taskului TID = 10968 cu codul de retur = 0

Comentarii:
- Am refolosit macro-urile 'proces()' si 'thread()' din exemplul anterior;
 am adaugat un macro variadic 'scrie()' pentru a afisa informatie formatata
 ocolind bufferele 'FILE'.
- Taskurile sunt lansate aproape simultan iar ele incep prin a-si afisa
 identitatea; eventualele asteptari se consuma ulterior.
- T5 asteapta 'sleep(1)' ca T2 sa creeze P3 (daca P3 nu s-a creat in timp
 util, T5 nu va astepta in 'waitpid()');
- Am adaugat la sfarsitul taskurilor T1, T2, T5 'while(1) pause();' pentru a
 astepta sa primeasca eventuale semnale (fiecare semnal primit va intrerupe
 un 'pause()', apoi vor astepta in continuare la iteratia urmatoare); P3 si
 T4 nu este de asteptat sa primeasca semnale si atunci nu le-am facut sa
 astepte (daca P3 ar fi efectuat 'while(1) pause();', T5 ar fi asteptat la
 infinit terminarea lui).
  P0 poate primi semnale dar in acelasi timp trebuie sa nu se termine inainte
 ca T1, T2, T5 sa primeasca toate semnalele pe care le-ar putea primi, altfel
 acestea vor fi terminate fortat; deoarece P3 (de la care vine SIGCHLD) se
 termina aproape imediat iar T4 (care trimite ISGUSR1 si SIGUSR2) se termina
 dupa cca. 1 secunda, este suficient ca P0 sa astepte > 1 secunda; intrucat
 P0 poate primi atat SIGCHLD cat si SIGUSR1 (sunt process-directed) este
 suficient sa efectueze 'sleep(1); sleep(1); sleep(2);' - eventualele semnale
 primite vor intrerupe cate un 'sleep(1)' iar asteptarea va dura cca. 2 - 4
 secunde; puteam folosi si 'while(1) pause();' dar atunci ar fi trebuit sa-l
 terminam fortat (Ctrl-c). Notam ca P3 si T4 se termina aproape imediat iar
 terminarea lui P0 va termina si T1, t2, T5 (care asteaptau in continuare in
 'while(1) pause();').
- Din testarea efectuata observam ca semnalele process-oriented SIGCHLD cat
 si SIGUSR1, desi au fost destinate lui P0, au fost tratate in alte threaduri
 ale sale, T1, T2; semnalul thread-oriented SIGUSR2 trimis catre T1 a fost
 tratat de T1.

Exemplul 4:
===========

Vom vedea cum I/O in threaduri utilizand functiile 'stdio' poate conduce
la conditii de cursa legate de bufferele 'FILE':

#define _GNU_SOURCE
#include <sched.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

void *baza, *varf; long page_size;
#define thread(I)\
clone(f, baza - ((I[0] - '0') * page_size),\
CLONE_THREAD | CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, I)

int f(void *arg) {
  switch(((char *)arg)[0] - '0') {
    case 1: printf("abc\n"); break;
    case 2: printf("123\n"); break;
  }
   return 0;
}

int main() {
  page_size = sysconf(_SC_PAGE_SIZE);
  if((varf = valloc(10 * page_size)) == NULL) {perror("valloc"); return 1;}
  baza = varf + 10 * page_size;
  thread("1"); thread("2"); sleep(1);
  return 0;
}


La testare, am obtinut:

abc
abc
123

Exemplul 5:
===========

Dam un exemplu de apelare a lui 'clone()' raw system call; intrucat
trebuie sa incarcam adresa de retur pe stiva apelatului iar aceasta
nu este facil in C, vom folosi inline assembler:

TODO


4.2. Sincronizarea taskurilor, semaforare POSIX:
------------------------------------------------

  Pentru a sincroniza taskuri, putem folosi instrumente IPC System V,
inclusiv vectori de semafoare Sistem V (a se vedea cursul de SO) sau
semafoare POSIX (mai simple):

  In esenta, un semafor POSIX este o variabila intreaga cu valori >= 0.
Asupra sa pot fi efectuate operatiile:
'sem_post()': incrementeaza semaforul cu 1;
'sem_wait()': decrementeaza semaforul cu 1, dar daca are deja valoarea 0,
  apelantul va fi blocat mai intai pana cand devine > 0.

  Programele care folosesc semafoare POSIX trebuie compilate cu optiunea
'-pthread', pentru a fi linkeditate cu biblioteca real-time 'librt'.

  Semafoarele POSIX pot fi cu nume (named) sau fara nume (unnamed).

  Semafoarele cu nume au un nume de forma '/somename' (null-terminated
string de pana la NAME_MAX-4 (i.e., 251) caractere, primul fiind '/',
urmat de >= 1 caractere ce nu pot fi '/'). Doua taskuri pot opera asupra
unui acelasi semafor cu nume pasand acelasi nume lui 'sem_open()'.
  In Linux, semafoarele cu nume sunt create intr-un sistem de fisiere
virtual, montat in mod normal sub '/dev/shm', cu nume de forma
'sem.somename' (de aceea numele trebuie sa aiba maxim NAME_MAX-4 si nu
NAME_MAX caractere).
  Semafoarele cu nume au kernel persistence: daca nu sunt eliminate cu
'sem_unlink()', persista pana cand sistemul este oprit (shut down).

  Asupra semafoarelor cu nume se pot efectua operatiile:

#include <fcntl.h>     /* For O_* constants */
#include <sys/stat.h>  /* For mode constants */
#include <semaphore.h>
sem_t *sem_open(const char *name, int oflag);
sem_t *sem_open(const char *name, int oflag,
                mode_t mode, unsigned int value);

Link with '-pthread'.

   ==>

 Creaza un nou semafor si il deschide pentru operatii sau deschide pentru
operatii un semafor existent; semaforul are numele 'name'.
 'oflag' se poate specifica prin disjunctie pe biti '|' de urmatoarele
valori:
 'O_CREAT' : daca semaforul nu exista, va fi creat; el va avea ca proprietar
            si grup pe cele efective al apelantului;
 'O_EXCL' : daca este folosit impreuna cu 'O_CREAT' iar semaforul 'nume'
            exista, apelul va esua;
daca semaforul este creat, el va avea permisiunile 'mode' (se pot specifica
ca la 'open()', vor fi mascate de 'umask'-ul apelantului, si trebuie sa
specificam si read si write pentru utilizatorii care vor accesa semaforul)
si valoarea initiala 'value'; daca semaforul exista, 'mode' si 'value'
sunt ignorate.
 In caz de succes, 'sem_open()' returneaza adresa unui obiect de tip 'sem_t'
alocat in spatiul utilizatorului, care poate fi folosit ulterior in celelalte
functii referitoare la semafoare; el va fi eliminat de 'sem_close()'; in caz
de esec, 'sem_open()' returneaza 'SEM_FAILED' si seteaza 'errno'.
 Obs: In fapt, 'sem_open' deschide fisierul din '/dev/shm' unde este stocat
semaforul, il mapeaza in spatiul utilizatorului ('mmap(NULL, sizeof (sem_t),
PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0)' unde 'fd' este descriptorul
fisierului deschis)  si returneaza adresa obiectului de tip 'sem_t' mapat in
memorie din fisierul subiacent. Intrucat obiectul de tip 'sem_t' ajunge in
spatiul utilizator, el poate fi operat si cu instrumente specifice dar si cu
instructiuni obisnuite de accesare a memoriei, insa aceast lucru nu este
recomandabil, deoarece nu se poate garanta atomicitatea gruparii unor
operatii.

#include <semaphore.h>
int sem_close(sem_t *sem);

Link with -pthread.

   ==>

 Inchide semaforul 'sem', eliberand resursele alocate in spatiul utilizator
al apelantului pentru gestiunea lui. In caz de succes, returneaza 0, in caz
de esec, returneaza -1 si seteaza 'errno'.

#include <semaphore.h>
int sem_unlink(const char *name);

Link with -pthread.

   ==>

 Elimina din sistem (removes) semaforul numit de 'nume'. Numele este eliminat
imediat (nu mai este vizibil la 'sem_open()') dar semaforul este distrus doar
dupa ce toate procesele care il aveau deschis l-au inchis. In caz de succes,
functia returneaza 0, in caz de esec, returneaza -1 si seteaza 'errno'.

#include <semaphore.h>
int sem_getvalue(sem_t *sem, int *sval);

Link with -pthread.

   ==>
 Furnizeaza un '*sval' valoarea curenta a semaforului 'sem'; daca exista
taskuri blocate la semafor in 'sem_wait()', furnizeaza 0. In caz de succes,
functia returneaza 0, in caz de esec, returneaza -1 si seteaza 'errno'.

#include <semaphore.h>
int sem_post(sem_t *sem);

Link with -pthread.

   ==>
 Incrementeaza (unlock) semaforul 'sem'; odata ce valoarea semaforului a
devenit > 0, un alt task care era blocat la semafor in 'sem_wait()' poate
fi trezit si va decrementa (lock) semaforul. In caz de succes, functia
returneaza 0, in caz de esec, valoarea semaforului ramane neschimbata iar
functia returneaza -1 si seteaza 'errno'.

#include <semaphore.h>
int sem_wait(sem_t *sem);
int sem_trywait(sem_t *sem);
int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);

Link with -pthread.

   ==>

 Functia 'sem_wait()' decrementeaza (lock) semaforul 'sem'; daca valoarea
initiala era > 0, decrementarea are loc iar functia returneaza imediat; daca
valoarea initiala era 0, apelantul este blocat pana cand este posibila
efectuarea decrementarii (i.e. valoarea semaforului devine > 0) sau un
handler de semnal intrerupe apelul.
 Functia 'sem_trywait()' este similara cu 'sem_wait()', cu exceptia faptului
ca daca decrementarea nu se poate efectua imediat, apelul returneaza imediat
o eroare (nu blocheaza apelantul).
 Functia 'sem_timedwait()' este similara cu 'sem_wait()', cu exceptia
faptului ca blocarea apelantului se face cel mult pana la momentulul
'abs_timeout', exprimat in secunde si nanosecunde fata de referinta
Epoch, 1970-01-01 00:00:00 +0000  (UTC); tipul 'struct timespec' este
urmatorul (a se vedea si cursul de USO):

           struct timespec {
               time_t tv_sec;      /* Seconds */
               long   tv_nsec;     /* Nanoseconds [0 .. 999999999] */
           };


daca 'abs_timeout' este expirat la momentul apelului iar semaforul nu poate
fi locked imediat, functia 'sem_timedwait()' esueaza cu timeout error
(seteaza 'errno' cu 'ETIMEDOUT'); daca operatia se poate efectua imediat,
'sem_timedwait()' nu verifica validitatea lui 'abs_timeout' si astfel nu
poate esua cu timeout error (poate esua, insa, din alte motive, de exemplu,
'sem' invalid).
 In cazu de succes, toate functiile 'sem_wait()', 'sem_trywait()',
'sem_timedwait()' returneaza 0, iar in caz de esec, valoarea semaforului
ramane neschimbata iar functiile returneaza -1 si seteaza 'errno'.

 Semafoarele anonime (memory-based semaphores) nu au nume, in schimb
sunt plasate in zone de memorie partajate intre mai multe threaduri
(thread-shared semaphore) sau procese (process-shared semaphore); un
semafor thread-shared trebuie plasat intr-o zona de memorie partajata
intre threadurile unui proces, de exemplu, o variabila globala sau in heap;
un semafor process-shared trebuie plasat intr-o zona de memorie partajata
intre procese, de exemplu, un segment de memorie partjata System V obtinut
cu 'shmget()' si 'shmat()', sau un obiect de memorie partajata POSIX obtinut
cu 'shm_open()' si mapat cu 'mmap()', sau un fisier mapat cu 'mmap()'.
 In orice caz, semaforul anonim se afla in spatiul utilizator al taskurilor
care il acceseaza, trebuie definit de utilizator, de exemplu 'sem_t sem;',
si poate fi operat cu instrumente specifice dar si cu instructiuni obisnuite
de accesare a memoriei, insa, ca si in cazul semafoarelor cu nume, nu este
recomandabil, deoarece nu se poate garanta atomicitatea gruparii unor
operatii.
 Inainte de folosire, un semafor anonim trebuie initializat cu 'sem_init()';
apoi, poate fi operat cu 'sem_post()', sem_wait()', 'sem_getvalue()' (a se
vedea mai sus), iar in final poate fi distrus 'sem_destroy()' (dar inainte de
a dezaloca memoria in care este alocat). Prezentam noile functii mentionate:

#include <semaphore.h>
int sem_init(sem_t *sem, int pshared, unsigned int value);

Link with -pthread.

   ==>
 Initializeaza semaforul anonim de la adresa 'sem' (care trebuie definit
explicit de utilizator intr-o zona de momorie partajata de toate taskurile
care urmeaza sa-l acceseze) cu valoarea 'value'; 'pshared' indica daca
semaforul va fi partajat intre threadurile unui proces (0) sau intre
procese (!= 0). Initializarea unui semafor anonim deja initializat are
efect imprevizibil. In caz de succes, 'sem_init()' returneaza 0, in caz
de esec, returneaza -1 si seteaza 'errno'.
 Observatie: In Linux/glibc, semafoarele POSIX sunt implementate folosind
mutex-uri pthread, care la randul lor sunt bazate pe apeluri sistem 'futex()'
("fast userspace mutex", sunt Linux specific); parametrul 'pshared' are
legatura cu atributele mutex transmise lui 'pthread_mutexattr_setpshared()'
(valorile posibile fiind: 'PTHREAD_PROCESS_PRIVATE' = mutex intern
procesului, este valoarea implicita, 'PTHREAD_PROCESS_SHARED' = mutex
partajat intre procese). In cele din urma, 'pshared' indica daca pagina
in care este alocat semaforul anonim este mapata 'mmap()' in spatiul
utilizator cu 'MAP_PRIVATE' (si atunci va fi partajata intre threadurile
procesului dar va fi mostenita copy-on-write de procesele copil, care
isi vor face duplicate in cazul cand o vor modifica) sau 'MAP_SHARED'
(si atunci va fi mostenita partajat de procesele copil, care vor modifica
acelasi exemplar al paginii). Semafoarele cu nume, deoarece se dorea a
fi vizibile sistem-wide, erau mapate implicit cu 'MAP_SHARED' si nu era
nevoie de 'pshared'.

#include <semaphore.h>
int sem_destroy(sem_t *sem);

Link with -pthread.

   ==>
 Distruge semaforul fara nume 'sem'; doar un semafor initializat cu
'sem_init()' ar trebui distrus cu 'sem_destroy'. Distrugerea unui semafor
la care sunt blocate taskuri la momentul curent (cu 'sem_wait()') are
efect nedefinit. Utilizarea ulterioara a unui semafor distrus are efect
nedefinit, pana cand semaforul este reinitializat cu 'sem_init()'.
 Un semafor anonim trebuie distrus cu 'sem_destroy()' inainte de a dezaloca
memoria in care este alocat, altfel, in anumite implelentari, poate conduce
la resource leaks.
 In caz de succes, functia 'sem_setroy()' returneaza 0, in caz de esec
returneaza -1 si seteaza 'errno'.

 Despre unele zone unde poate fi alocat un semafor anonim am discutat in
alte cursuri/capitole de cures, de exemplu, despre segmentele de memorie
partjata System V am discutat in cursul 6 SO iar despre fisiere mapate in
memorie cu 'mmap()' am discutat in cursul de USO.

 Discutam in continuare despre obiectele de memorie partajata POSIX obtinute
cu 'shm_open()' si mapate cu 'mmap()'. In Linux, ele sunt implementate
intr-un sistem de fisiere virtuale montat uzual in '/dev/shm'. Asemeni
fisierelor obisnuite, au nume, proprietar, permisiuni, pot fi accesate de
taskuri prin descriptori numerici si pot fi mapate in memorie cu 'mmap()'
(pentru comunicare intre procese, alocare semafoare anonime, etc). Ele au
persistenta kernel, i.e. un obiect memorie partajata exista pana sistemul
este shut down, sau pana cand toate procesele l-au de-mapat iar numele
i-a fost eliminat cu 'shm_unlink()'.
 Programele care folosesc API-ul pentru memorii partajate POSIX trebuie
compilate cu optiunea '-lrt' pentru a linkedita de biblioteca real-time
'librt'. Prezentam cateva functii specifice:

#include <sys/mman.h>
#include <sys/stat.h>        /* For mode constants */
#include <fcntl.h>           /* For O_* constants */
int shm_open(const char *name, int oflag, mode_t mode);
int shm_unlink(const char *name);

Link with -lrt.

   ==>
 Functia 'shm_open()' creaza si deschide un nou obiect, sau deschide un
obiect existent, similar cu 'open()' pentru fisiere. In caz de succes,
'shm_open()' returneaza un descriptor de fisier catre obiect, despre care
se garanteaza ca este cel mai mic descriptor liber. Descriptorul are setat
flagul 'FD_CLOEXEC', i.e. se va inchide automat la 'exec()'. In caz de esec,
'shm_open()' returneaza -1 si seteaza 'errno'.
 Argumentul 'name' specifica numele obiectului de memorie partajata iar
pentru portabilitate el trebuie sa fie de forma '/somename', i.e. un
null-terminated string de maxim 'NAME_MAX' (i.e., 255) caractere constand
dintr-un slash initial, urmat de >= 1 caractere, toate diferite de slash.
 Argumentul 'oflag' este o masca obtinuta prin disjunctia pe biti '|'
intre exact unul dintre 'O_RDONLY' sau 'O_RDWR' si >= 0 dintre
'O_CREAT', 'O_EXCL', 'O_TRUNC'; argumentul 'mode' este o disjunctie pe
biti '|' de constantele pentru permisiuni folosite de 'open()'; efectul este
similar ca in cazul 'open()'.
 Dimensiunea initiala a unui obiect de memorie partajata nou creat este 0,
dar poate fi redimensionat ulterior cu 'ftruncate()' iar noii octeti alocati
vor fi initializati automat cu 0.
 Dupa ce obiectul de memorie partajata a fost mapat cu 'mmap()', descriptorul
de fisier poate fi inchis ('close()') fara a afecta maparea.
 Functia 'shm_unlink()' elimina numele obiectului indicat de 'name', similar
cu 'unlink()' pentru fisiere; atunci, in momentul cand toate procesele au
de-mapat obiectul, continutul zonei de memorie asociate este dezalocat si
distrus. Dupa 'shm_unlink()', apelurile 'shm_open()' pentru acelasi 'name'
vor esua, cu exceptia cazului cand am folosi 'O_CREAT' (si atunci se creaza
un obiect nou).
 In caz de succes, 'shm_unlink()' returneaza 0, in caz de esec, returneaza -1
si seteaza 'errno'.

 In legatura cu obiectele de memorie partajata POSIX se pot folosi si
functiile pentru fisiere 'ftruncate()', 'mmap()', 'munmap()', 'close()',
'fstat()', 'fchown()', 'fchmod()', cu efect similar (a se vedea cursul de
USO).

Exemplul 6:
===========

Problema producator - consumator, implementata cu obiecte de memorie
partajata si semafoare POSIX (anonime); algoritmul este cel din cursul 6 SO.

Varianta cu doua procese:

$cat prog.c
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <semaphore.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>

#define N 10

int main() {
  int shmid, length; void *adr; int *buf; sem_t *psem; pid_t pid;
  if((shmid = shm_open("/buffer", O_RDWR | O_CREAT | O_TRUNC,
                       S_IRUSR | S_IWUSR)) == -1) {
    perror("/buffer"); exit(EXIT_FAILURE);
  }
  length = (N + 2) * sizeof(int) + 3 * sizeof(sem_t);
  if((ftruncate(shmid, length)) == -1) {
    perror("ftruncate"); shm_unlink("/buffer"); exit(EXIT_FAILURE);
  }
  if((adr = mmap(NULL, length, PROT_READ | PROT_WRITE,
                 MAP_SHARED, shmid, 0)) == MAP_FAILED) {
    perror("mmap"); shm_unlink("/buffer"); exit(EXIT_FAILURE);
  }
  close(shmid);

  buf = adr;
  buf[N] = buf[N + 1] = 0;
  psem = (sem_t *)(buf + (N + 2) * sizeof(int));
  sem_init(&psem[0], 1, 1);
  sem_init(&psem[1], 1, N);
  sem_init(&psem[2], 1, 0);

  /*
     buf[0] ... buf[N - 1] = buffer coada circulara;
     buf[N] = baza cozii;
     buf[N + 1] = varful cozii;
     psem[0] = semaforul mutex;
     psem[1] = semaforul empty;
     psem[2] = semaforul full;
  */
  if(! (pid = fork())) { /* consumator */
    int item;
    while(1) {
      sem_wait(&psem[2]);                            /* down(&full) */
      sem_wait(&psem[0]);                            /* down(&mutex) */
      item = buf[buf[N+1]]; buf[N+1] = (buf[N+1]+1)%N;/*item=remove_item()*/
      sem_post(&psem[0]);                             /* up(&mutex) */
      sem_post(&psem[1]);                             /* up(&empty) */
      printf("%d\n", item);                          /* consume_item(item) */
    }
    exit(EXIT_SUCCESS);
  }
  if(! fork()) { /* producator */
    int item, i;
    item=0;
    for(i = 0; i < 20; ++i) {
      ++item;                                     /* item = produce_item() */
      sem_wait(&psem[1]);                             /* down(&empty) */
      sem_wait(&psem[0]);                             /* down(&mutex) */
      buf[buf[N]] = item; buf[N] = (buf[N] + 1) % N;  /* insert_item(item) */
      sem_post(&psem[0]);                             /* up(&mutex) */
      sem_post(&psem[2]);                             /* up(&full) */
    }
    sleep(1); kill(pid, SIGTERM);
    exit(EXIT_SUCCESS);
  }
  while(wait(NULL) != -1);
  sem_destroy(psem); sem_destroy(psem + 1); sem_destroy(psem + 2);
  munmap(adr, length);
  shm_unlink("/buffer");
  return EXIT_SUCCESS;
}
$gcc -Wall -o prog prog.c -lrt -pthread
$./prog
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
$

Varianta cu doua threaduri (de fapt, procese ce partajaza memoria):

$cat prog.c
#define _GNU_SOURCE
#include <sched.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <semaphore.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>

#define N 10
pid_t prod, cons;
int b, v, buf[N]; sem_t mutex, empty, full;
/*
   buf[0] ... buf[N - 1] = buffer coada circulara;
   b = baza cozii;
   v = varful cozii;
   mutex = semaforul mutex;
   empty = semaforul empty;
   full = semaforul full;
*/

int consumator(void *arg) {
  int item;
  while(1) {
    sem_wait(&full);                        /* down(&full) */
    sem_wait(&mutex);                       /* down(&mutex) */
    item = buf[v]; v = (v + 1) % N;         /* item=remove_item() */
    sem_post(&mutex);                       /* up(&mutex) */
    sem_post(&empty);                       /* up(&empty) */
    printf("%d\n", item);                   /* consume_item(item) */
  }
  return 0; // unreachable
}

int producator(void *arg) {
  int item, i;
  item = 0;
  for(i = 0; i < 20; ++i) {
    ++item;                                 /* item = produce_item() */
    sem_wait(&empty);                       /* down(&empty) */
    sem_wait(&mutex);                       /* down(&mutex) */
    buf[b] = item; b = (b + 1) % N;         /* insert_item(item) */
    sem_post(&mutex);                       /* up(&mutex) */
    sem_post(&full);                        /* up(&full) */
  }
  sleep(1); kill(cons, SIGTERM);
  return EXIT_SUCCESS;
}

int main() {
  void *baza, *varf; long page_size;
  page_size = sysconf(_SC_PAGE_SIZE);
  if((varf = valloc(2 * page_size)) == NULL) {perror("valloc"); return 1;}
  baza = varf + 2 * page_size;
  b = v = 0;
  sem_init(&mutex, 0, 1); sem_init(&empty, 0, N); sem_init(&full, 0, 0);
  cons =  clone(consumator, baza, CLONE_VM, NULL);    /* consumator */
  if(cons == -1) {
    perror("consumator");
    sem_destroy(&mutex); sem_destroy(&empty); sem_destroy(&full); free(varf);
    exit(EXIT_FAILURE);
  }
  prod =  clone(producator, baza - page_size, CLONE_VM, NULL);    /* producator */
  if(prod == -1) {
    perror("producator");
    kill(cons, SIGTERM);
    sem_destroy(&mutex); sem_destroy(&empty); sem_destroy(&full); free(varf);
    exit(EXIT_FAILURE);
  }
  while(wait(NULL) != -1);
  sem_destroy(&mutex); sem_destroy(&empty); sem_destroy(&full); free(varf);
  return EXIT_SUCCESS;
}
$gcc -Wall -o prog prog.c -pthread
$./prog
$1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20


4.3. Biblioteca pthreads:
-------------------------

 Biblioteca 'pthreads' ("POSIX Threads") este un layer API adaugat la
compilare in spatiul utilizator care abstractizeaza conceptele si
mecanismele referitoare la threaduri din sistemul de operare gazda,
oferind un mod de lucru cu acestea facil si portabil. Biblioteca 'pthreads'
este standardizata POSIX, deci este utilizabila in toate sistemele
UNIX/UNIX-like. Varianta Linux este implementata deasupra conceptului
de task si apelului 'clone()', care sunt Linux specific.
 Programele care folosesc biblioteca 'pthreads' trebuie compilate cu
optiunea '-pthread' sau (in mod traditional) '–lpthread', care le
linkediteaza de biblioteca 'libpthread'.

 Implementarea Linux a NPTL (Native POSIX Threads Library) este o
implementare 1:1, insemnand ca orice thread este mapat intr-o entitate
planificabila la executie de catre kernel, practic, un task; crearea
threadurilor este implementata folosind apelul 'clone()' iar primitivele
de sincronizare a threadurilor (mutex-uri, thread joining, etc.) sunt
implementate folosind apelul 'futex()'; de asemenea, biblioteca foloseste
intern primele doua semnale real-time (32, 33) - ele nu trebuie folosite
in aplicatii pentru a nu interfera cu biblioteca.

 Nota: Semnalele real-time sunt o extensie a semnalelor standard POSIX,
sunt specificate in POSIX.1-2001 si sunt suportate de Linux incepand cu
versiunea 2.2. Linux kernel suporta 33 semnale real-time, avand numerele
32 - 64; dintre acestea, unele (primele 2 sau 3) sunt folosite intern
de glibc si nu ar trebui folosite in codul utilizator, pentru a evita
interferentele; sunt definite macro-urile SIGRTMIN si SIGRTMAX, care
definesc intervalul de semnale real-time care pot fi folosite in codul
utilizator fara riscuri iar codul ar trebui sa se refere la ele prin
expresii de forma SIGRTMIN + n si verificand ca valoarea sa nu depaseasca
SIGRTMAX, in nici un caz nu ar trebui sa foloseasca numere hard-codate.
Semnalele real-time nu au semnificatii predefinite, toate pot fi folosite
pentru scopuri specifice aplicatiilor; handlerele lor implicite sunt de
terminare a procesului receptor; semnalele real-time au unele prorietati
diferite fata de semnalele standard:
 - pot fi retinute in pending (intr-o coada de asteptare) mai multe instante
din acelasi semnal;
 - pot fi trimise cu 'sigqueue()' insotite de o valoare (intreg sau pointer);
daca procesul receptor a asociat semnalului un hadler cu 'sigaction()'
si flagul 'SA_SIGINFO', el poate obtine valoarea respectiva via campul
'si_value' al structurii de tip 'siginfo_t' indicata de al doilea argument
al handlerului; in plus, campurile 'si_pid' si 'si_uid' ai structurii vor
furniza PID-ul si proprietarul real al procesului emitator;
- cand sunt primite mai multe semnale de acelasi tip, ele sunt tratate in
ordinea in care au fost trimise (astfel, se poate da relevanta ordinii
valorilor asociate si a identitatilor emitatorilor); cand sunt primite
semnale diferite, ele sunt tratate in ordinea crescatoare a numerlor de
semnal; cand sunt primite si semnale standard si semnale real-time, POSIX
nu specifica care sunt tratate primele, dar Linux da prioritate semnalelor
standard.
 Pentru a putea lucra su cu semnale real-time, tipul multime de semnale
'sigset_t' a fost largit de la 32 la 64 biti iar unele apeluri sistem au
variante inlocuitoare care suporta multimi mai mari de semnale:
'rt_sigaction()', 'rt_sigpending()', 'rt_sigprocmask()', 'rt_sigsuspend()',
etc. (sunt variante ale apelurilor fara 'rt_').

 Prezentam in continuiare principalele instrumente 'pthreads':


4.4. Threaduri, creare, terminare, asteptare:
---------------------------------------------

Putem crea/distruge/astepta terminarea threadurilor, folosind:

#include <pthread.h>
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                   void *(*start_routine) (void *), void *arg);

Compile and link with -pthread.

  ==>
 Lanseaza un nou thread in procesul apelant; poate fi lansat din threadul
principal (liderul grupului de threaduri) sau dintr-un alt thread al lui;
threadul isi incepe executia prin apelarea functiei 'start_routine()' cu
argumentul 'arg' si se poate termina intr-unul dintre urmatoarele feluri:
- apeleaza 'pthread_exit()' cu o valoare de iesire (exit status value);
 aceasta valoare poate fi recuperata de un alt thread din acelasi proces,
 care il asteapta pe primul cu 'pthread_join()';
- functia 'start_routine()' returneaza; acesta echivaleaza cu a apela
 'pthread_exit()' avand ca argument valoarea furnizata de instructiunea
 'return';
- este anulat de un alt thread cu 'pthread_cancel()';
- oricare dintre threadurile procesului apeleaza 'exit()' sau threadul
 principal efectueaza 'return' din 'main()'; acestea cauzeaza terminarea
 tuturor threadurilor procesului.
 Argumentul 'attr' poineaza o structura de tip 'pthread_attr_t' al carei
continut este folosit la crearea threadului pentru a determina atributele
sale; aceasta structura poate fi initializata in prealabil cu functia
'pthread_attr_init()' sau alte functii inrudite; daca 'attr' este NULL,
threadul este creat cu atribute implicite.
 Inainte de a returna, un apel reusit al lui 'pthread_create()' stocheaza
identificatorul noului thread in bufferul pointat de 'thread'; acest
identificator, de tip 'pthread_t', are relevanta locala, la nivelul
procesului gazda, nu este vorba de identificatorii 'pid' sau 'tgid' ai
unui task despre care am discutat mai devreme (si returnati de 'gettid()'
sau 'getpid()'); identificatorul poate fi folosit pentru a indica threadul
in apeluri ulterioare ale altor functii din biblioteca 'pthreads';
identificatorul este unic (doar) la nivelul procesului gazda si poate fi
refolosit dupa ce un thread terminat a fost interceptat prin asteptare
(joined) sau un thread detasat s-a terminat (a se vedea mai jos).
 Ce mosteneste/nu mosteneste threadul creat:
- noul thread mosteneste o copie a mastii de semnale blocate a threadului
 creator (care se poate seta cu 'pthread_sigmask()' sau 'sigprocmask()');
 notam ca masca de semnale blocate este un atribut per-thread (iar in
 Linux este per-task);
- multimea semnalelor in pending (care se poate consulta cu 'sigpending()')
 pentru noul thread este vida;
- noul thread nu mosteneste stiva alternativa pentru executarea handlerelor
 de semnal a threadului creator (alternate signal stack, care poate fi setata
 cu 'sigaltstack()' si care este un atribut per-thread);
- noul thread mosteneste mediul de virgula mobila al threadului creator
 (floating-point environment, care se poate seta cu functiile din 'fenv.h'
 si care descrie modul cum se fac rotunjirile si sunt tratate exceptiile de
 virgula mobila);
- valoarea initiala a ceasului CPU pentru noul thread este 0; ceasul CPU
 (CPU-time clock) este un timer software per thread ce retine timpul
 consumat cu calcule; identitatea sa se poate consulta cu
 'pthread_getcpuclockid()' iar aceasta se poate da apoi ca argument
 functiilor 'clock_settime()', 'clock_gettime()', 'clock_getres()' care
 seteaza/consulta/consulta rezolutia timerului;
 In caz de succes, functia 'pthread_create()' returneaza 0, in caz de esec,
returneaza un cod de eroare asemanator valorilor lui 'errno', iar
continutul lui '*thread' este nedefinit.

 Notam ca 'errno' este o variabila per-thread si in fiecare thread poate avea
alta valoare; nu este specificat modul cum functiile 'pthreads' afecteaza
'errno'; in general, functiile 'pthreads' furnizeaza codul erorii pe calea
valorii returnate iar 'errno' este folosit de alte functii.
 Daca dorim sa folosim 'perror()', 'strerror()', etc. in legatura cu codurile
de eroare returnate de functiile 'pthreads' (valorile sunt asemanatoare),
putem proceda astfel:
  if((errno = pthread_functie(argumente)) != 0) perror(mesaj);

 Un thread poate fi asteptabil (joinable) sau detasat (detached).
 Daca un thread este asteptabil, atunci un alt thread poate apela
'pthread_join()' pentru a-i astepta terminarea si a-i prelua exit status-ul.
Doar dupa ce un thread asteptabil terminat a fost interceptat la asteptare
(joined) ultimele sale resurse sunt eliberate catre sistem.
 Cand un thread detasat se termina, resursele sale sunt eliberate automat
catre sistem; nu este posibila interceptarea prin asteptare (join) a
threadului in scopul de a-i obtine exit status-ul. A face un thread detasat
este util pentru anumite tipuri de threaduri de fundal (daemon threads), de
al caror exit status aplicatia nu are nevoie.
 Implicit, un nou thread este creat sa fie asteptabil (joinable state);
obiectul '*attr' poate fi insa setat cu 'pthread_attr_setdetachstate()'
a.i. threadul sa fie creat detasat (detached state).
 Un thread creat sa fie asteptabil (joinable state) ar trebui pana la urma
sa fie ori interceptat la asteptare (joined) folosind 'pthread_join()' ori
detasat folosind 'pthread_detach()'; este o eroare sa fie specificat
ID-ul unui thread creat detasat (detached state) intr-un apel ulterior al
lui 'pthread_detach()' sau 'pthread_join()'.

#include <pthread.h>
pthread_t pthread_self(void);

Compile and link with -pthread.

  ==>
 Functia returneaza ID-ul threadului apelant; este aceeasi valoare care este
furnizata in '*thread' de apelul 'pthread_create()' care a creat threadul.
Functia nu esueaza niciodata.

#include <pthread.h>
int pthread_equal(pthread_t t1, pthread_t t2);

Compile and link with -pthread.

  ==>
 Functia compara cele doua ID-uri de threaduri, returnand o valoare nenula
daca sunt egale si 0 daca sunt diferite. Functia nu esueaza niciodata.

Nota: POSIX nu impune o anumita implementare a tipului 'pthread_t' si de aceea
trebuie considerat opac. De aceea, nu este protabil ca ID-urile sa fie
comparate cu '=='. De asemenea, orice incercare de a folosi aceste ID-uri
in alte functii decat cele pthreads este neportabila si poate duce la
rezultate nedefinite.

#include <pthread.h>
int pthread_cancel(pthread_t thread);

Compile and link with -pthread.

  ==>
 Trimite o cerere de anulare (cancellation  request) threadului 'thread';
modul si momentul in care threadul vizat reactioneaza depinde de doua
atribute aflate sub controlul threadului respectiv: starea anularii
(cancellation state) si tipul anularii (cancellation type).
 Un thread isi poate seta cancellation state folosind functia
'pthread_setcancelstate()' iar ea poate fi activata (enabled, este
implicita pentru threadurile noi) sau dezactivata (disabled); daca este
dezactivata, cererea de anulare primita este pastrata intr-o coada de
asteptare pana cand threadul activeaza cancellation state; daca este
activata, momentul cand se produce anularea este determinat de cancellation
type.
 Un thread isi poate seta cancellation type folosind functia
'pthread_setcanceltype()' iar ea poate fi asincrona (asynchronous) sau
amanata (deferred, implicita pentru threadurile noi); daca este asincrona,
cererea de anulare poate fi satisfacuta oricand (de regula, imediat, dar
sistemul nu garanteaza asta); daca este amanata, satisfacerea cererii de
anulare este intarziata pana la urmatorul apel pe care il face threadul
al unei functii care are statut de punct de anulare (cancellation point);
o lista completa a acestor functii poate fi aflata cu 'man 7 pthreads' iar
ea include functiile: 'open()', 'creat()', 'close()', 'read()', 'write()',
'system()', 'wait()', 'pause()', 'sleep()'.
 Satisfacerea cererii de anulare presupune efectuarea in thread, in ordine,
a urmatorilor pasi:
1. Handlerele de curatare la anulare (cancellation clean-up handlers) sunt
 extrase din stiva (pop), in ordinea inversa a inserarii (push) si sunt
 apelate; aceste handlere sunt functii care se executa automat atunci cand
 un thread este anulat si pot, de exemplu, sa descuie (unlock) un mutex
 pentru a permite altor threaduri sa progreseze; fiecare thread are o stiva
 proprie de asemenea handlere si o poate gestiona (push, pop, handlere) cu
 functii ca 'pthread_cleanup_push()', 'pthread_cleanup_pop()'.
2. Sunt apelati destructorii datelor specifice threadului (thread-specific
  data destructors), create cu 'pthread_key_create()', intr-o ordine
  nespecificata.
3. Threadul este terminat (in sensul lui 'pthread_exit()').
Pasii de mai sus se efectueaza asincron in ceea ce priveste apelul
'pthread_cancel()'; valoarea returnata de 'pthread_cancel() doar
informeaza apelantul daca cererea de anulare a fost pusa in coada de
asteptare cu succes.
 Dupa ce un thread anulat s-a terminat, un join cu acel thread folosind
'pthread_join()' furnizeaza valoarea PTHREAD_CANCELED ca exit status al
threadului in locatia indicata de argumentul sau 'retval' (join-ul cu
un thread este singurul mod in care se poate afla ca anularea s-a incheiat).
 In caz de succes, functia 'pthread_cancel()' returneaza 0, in caz de esec,
returneaza un cod de eroare nenul.
 In Linux, anularea threadurilor este implementata folosind semnale.

#include <pthread.h>
int pthread_setcancelstate(int state, int *oldstate);
int pthread_setcanceltype(int type, int *oldtype);

Compile and link with -pthread.

  ==>
 Functia 'pthread_setcancelstate()' seteaza cancellation state pentru
threadul apelant la valoarea 'state', care poate fi 'PTHREAD_CANCEL_ENABLE'
(cancellation state este activata, este starea implicita in noile threaduri,
inclusiv cel initial) sau 'PTHREAD_CANCEL_DISABLE' (cancellation state este
dezactivata); in locatia indicata de 'oldstate' este recuperata valoarea
anterioara.
 Functia 'pthread_setcanceltype()' seteaza cancellation type pentru threadul
apelant la valoarea 'type', care poate fi 'PTHREAD_CANCEL_DEFERRED'
(cancellation type este amanata, este starea implicita in noile threaduri,
inclusiv cel initial) sau 'PTHREAD_CANCEL_ASYNCHRONOUS' (cancellation type
este asincrona); observatie: chiar si in cazul cu anulare amanata, inca se
poate actiona asupra unui cancellation point intr-un handler de semnal
asincron iar efectul este ca si cand ar fi fost cancelare asincrona.
 Operatiile set-and-get efectuate de fiecare dintre cele doua functii sunt
atomice in ceea ce priveste alte threaduri din proces care apeleaza aceeasi
functie.
 In caz de succes, ambele functii returneaza 0, in caz de esec, returneaza
un cod de eroare nenul.
 Pentru alte detalii, a se revedea functia 'pthread_cancel()', mai sus.
 Note:
 - In implementarea Linux, argumentul 'oldstate' poate fi NULL, caz in care
starea anterioara nu este furnizata; POSIX.1 nu specifica aceasta, deci o
aplicatie portabila ar trebui sa specifice doar 'oldstate' non-NULL.
- Dezactivarea de scurta durata a cancellation state este utila atunci cand
threadul efectueaza anumite actiuni critice ce nu trebuie intrerupte de
cereri de anulare; cancellation type asincron este folosit rar, deoarece
un thread care poate fi anulat in orice moment nu isi poate rezerva in
siguranta resurse, cum ar fi alocarea de memorie cu 'malloc()', obtinerea
semafoarelor, etc. - de exemplu, nu se va sti daca anumite resurse au apucat
sa fie alocate, anumite structuri de date interne s-ar putea afla intr-o
stare de inconsistenta, astfel incat handlerele clean-up nu vor fi utile.
 Functiile care pot fi anulate asincron in siguranta s.n. "async-cancel-safe
functions"; POSIX.1-2001 si POSIX.1-2008 cer ca doar 'pthread_cancel()',
'pthread_setcancelstate()' si 'pthread_setcanceltype()' sa fie
async-cancel-safe; alte functii de biblioteca nu pot fi apelata e in
siguranta dintr-un thread cu cancellation type asincron.
 O situatie cand cancelabilitatea asincrona este utila este pentru a anula
un thread aflat intr-o bucla pur limitata de calcule.

#include <pthread.h>
void pthread_testcancel(void);

Compile and link with -pthread.

  ==>
 Apelul functiei creaza un punct de anulare (cancellation point) in threadul
apelant, a.i. un thread care altfel ar executa un cod ce nu contine puncte de
anulare va raspunde unei cereri de anulare.
 Daca cancellation state este dezactivata (cu 'pthread_setcancelstate()') sau
nu exista cereri de anulare in asteptare, un apel al lui 'pthread_testcancel()'
nu are efect.
 Functia nu esueaza niciodata; daca threadul apelant este anulat ca o
consecinta a unui apel al functiei, functia nu returneaza.

#include <pthread.h>
void pthread_exit(void *retval);

Compile and link with -pthread.

  ==>
 Termina threadul apelant si furnizeaza o valoare via 'retval' care, daca
threadul este joinable, este accesibila unui alt thread din acelasi proces,
care apeleaza 'pthread_join()'. Sunt efectuati, de asemenea, pasii 1, 2
descrisi la 'pthread_cancel()'. Nu sunt eliberate resursele partajate intre
procese (process-shared resources), de exemplu, mutex-uri, variabile de
conditie, semafoare, descriptori de fisiere. Nu sunt apelate functiile
inregistrate cu 'atexit()'.
 Dupa ce ultimul thread al unui proces se termina, procesul se termina ca
la apelarea lui 'exit(0)' - astfel, resursele partajate intre procese si
functiile inregistrate cu 'atexit()' sunt apelate.
 Functia 'pthread_exit()' nu returneaza apelantului si are succes mereu.
Note:
 Executarea unui 'return' din functia de start a oricarui thread in
afara de cel principal (a se vedea argumentul 'start_routine' al lui
'pthread_create()') are ca efect o apelare implicita a lui 'pthread_exit()',
folosind valoarea returnata de functie ca exit status al threadului.
 Pentru a perimite altor threaduri sa-si continue executia, threadul
principal ar trebui sa se termine cu 'pthread_exit()', nu cu 'exit()'.
 Valoarea pointata de 'retval' nu ar trebui sa fie amplasata pe stiva
threadului apelant, deoarece continutul acestei stive este nedefinit dupa
terminarea threadului.

#include <pthread.h>
int pthread_join(pthread_t thread, void **retval);

Compile and link with -pthread.

  ==>
 Pune in asteptare threadul apelant pana cand threadul 'thread' se termina;
daca thradul respectiv este deja terminat, 'pthread_join()' returneaza
imediat, nu se asteapta; threadul asteptat trebuie sa fie asteptabil
(joinable).
 Daca 'retval' nu este NULL, va fi copiat in locatia pointata exit status-ul
threadului tinta, i.e. valoarea pe care acesta a furnizat-o lui
'pthread_exit()' (sau, echivalent, 'return' din 'start_routine()', a se
vedea 'pthread_create()'); daca threadul tinta a fost anulat (canceled),
atunci in locatia respectiva va fi copiata valoarea 'PTHREAD_CANCELED'.
 Daca mai multe threaduri incearca simultan join cu un acelasi thread,
rezultatul este nedefinit; daca threadul care apeleaza 'pthread_join()'
este anulat (canceled),  atunci threadul tinta va ramane asteptabil
(joinable), i.e. nu va fi detasat (detached).
 In caz de succes, functia 'pthread_join()' returneaza 0, in caz de esec,
returneaza un cod de eroare nenul.
Note:
 Dupa un apel reusit al lui 'pthread_join()', apelantul are garantia ca
threadul tinta este terminat; astfel, apelantul poate efectua orice curatire
(clean-up) care este necesara dupa terminarea threadului, cum ar fi
eliberarea memoriei sau a altor resurse alocate explicit pentru threadul tinta.
 Asteptarea (join) unui thread care a fost deja asteptat (joined) anterior
are efect nedefinit.
 Esecul in a efectua join cu un thread care este asteptabil (joinable), i.e.
care nu este detasat (detached), produce un "zombie thread"; asa ceva este de
evitat, deoarece threadurile zombie consuma resurse sistem iar cand s-au
acumulat suficiente threaduri zombie (si nu s-a terminat procesul gazda), nu
va mai fi posibila crearea de noi threaduri sau procese (in Linux,
threadurile sunt taskuri si se umple tabela de taskuri).
 Nu exista un analog pentru threaduri al lui 'waitpid(-1, &status, 0)', i.e.
"join cu un thread terminat oarecare"; daca este perceputa nevoia unei
asemenea functionalitati, probabil trebuie regandit designul aplicatiei.
 Toate threadurile unui proces sunt imperecheabile: orice thread poate face
join cu orice alt thread din acelasi proces.

#include <pthread.h>
int pthread_detach(pthread_t thread);

Compile and link with -pthread.

  ==>
 Marcheaza threadul 'thread' ca fiind detasat (detached). Cand un thread
detasat se termina, resursele sale sunt automat eliberate fara a fi nevoie ca
un alt thread sa-l astepte (join).
 Daca vrem sa detasam threadul apelant, putem folosi:
           pthread_detach(pthread_self());
 Incercarea de a detasa un thread deja detasat produce un comportament
nedefinit.
 In caz de succes, functia returneaza 0, in caz de esec, returneaza un cod de
eroare.
 Note:
- Odata ce un thread a fost detasat, el nu poate fi asteptat (joined) cu
'pthread_join()' si nici nu poate fi facut asteptabil (joinable) din nou.
- Un thread poate fi creat in starea detasat, folosind functia
'pthread_attr_setdetachstate()' pentru a seta atributul referitor la starea
de detasare (detach state) din obiectul cu atribute de threaduri indicat de
argumentul 'attr' al functiei 'pthread_create()'. Atributul detach state
doar determina comportamentul sistemului atunci cand threadul se termina, el
nu impiedica threadul sa fie terminat daca procesul se termina cu 'exit()'
(sau, echivalent, daca threadul principal returneaza).
- Pentru orice thread pe care il creaza aplicatia ar trebui apelat fie
'pthread_join()' fie 'pthread_detach()', a.i. resursele alocate de sistem
pentru thread sa fie eliberate. Resursele threadurilor pentru care nu au fost
efectuate nici una dintre aceste actiuni vor fi eliberate, insa, la terminarea
procesului gazda.

Exemplul 7:
===========

Cream un proces (P) cu mai multe threaduri (Tn) organizate astfel:

     / T1 -- T2
 P --
     \ T3 -- T4

Cu tot cu threadul principal, sunt 5 threaduri. Threadurile se for rula in
paralel, P va astepta (join) T1, T2, T3 iar T3 va astepta (join) T4:

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

pthread_t t1, t2, t3, t4;

#define scrie(...) {\
  char buffer[2048];\
  sprintf(buffer, __VA_ARGS__);\
  write(1, buffer, strlen(buffer));\
}

void *f1(void *);
void *f2(void *);
void *f3(void *);
void *f4(void *);

void *f1(void *arg) {
  int i;
  pthread_create(&t2, NULL, &f2, "2");
  for(i = 0; i < 6; ++i) {
    scrie("Thread %s iteratia %d\n", (char *)arg, i);
    usleep(100);
  }
  return (void *)6;
}

void *f2(void *arg) {
  int i;
  for(i = 0; i < 3; ++i) {
    scrie("Thread %s iteratia %d\n", (char *)arg, i);
    usleep(100);
  }
  return (void *)3;
}

void *f3(void *arg) {
  int i; void *r;
  pthread_create(&t4, NULL, &f4, "4");
  for(i = 0; i < 4; ++i) {
    scrie("Thread %s iteratia %d\n", (char *)arg, i);
    usleep(100);
  }
  pthread_join(t4, &r);
  scrie("Threadul %s a primit prin join %d\n", (char *)arg, (int)(long)r);
  return (void *)4;
}

void *f4(void *arg) {
  int i;
  for(i = 0; i < 2; ++i) {
    scrie("Thread %s iteratia %d\n", (char *)arg, i);
    usleep(100);
  }
  return (void *)2;
}

int main() {
  void *r;
  pthread_create(&t1, NULL, &f1, "1");
  pthread_create(&t3, NULL, &f3, "3");
  pthread_join(t1, &r);
  scrie("Threadul principal a primit prin join %d\n", (int)(long)r);
  pthread_join(t2, &r);
  scrie("Threadul principal a primit prin join %d\n", (int)(long)r);
  pthread_join(t3, &r);
  scrie("Threadul principal a primit prin join %d\n", (int)(long)r);
  return 0;
}

Exemplu de testare (fisierul sursa este 'prog.c'):

$gcc -Wall -o prog prog.c -pthread
$./prog
Thread 1 iteratia 0
Thread 3 iteratia 0
Thread 4 iteratia 0
Thread 2 iteratia 0
Thread 1 iteratia 1
Thread 2 iteratia 1
Thread 3 iteratia 1
Thread 4 iteratia 1
Thread 1 iteratia 2
Thread 2 iteratia 2
Thread 3 iteratia 2
Thread 1 iteratia 3
Thread 3 iteratia 3
Thread 1 iteratia 4
Threadul 3 a primit prin join 2
Thread 1 iteratia 5
Threadul principal a primit prin join 6
Threadul principal a primit prin join 3
Threadul principal a primit prin join 4

Comentarii:
- Programul ne arata ca din orice thread al unui proces putem astepta
 (join) orice thread al aceluiasi proces. Pentru simplitate, nu am mai
 testat succesul functiilor apelate.
- Ca si in cazul unui exemplu anterioar, am folosit un macro 'scrie()'
 in loc de 'printf()', pentru a impiedica conditiile de cursa legate
 folosirea bufferelor 'FILE' alocate in zona partajata.
- Puteam specifica adresele functiilor si fara '&', de exemplu, 'f1'
 in loc de '&f1'.
- Functiile executate in threaduri trebuie sa returneze 'void *' dar
 acest tip ofera suficienta felxibilitate, deoarece se pot face conversii
 intre 'void *' si orice alt tip pointer sau tip intreg de marime
 cel mult 'long'; daca vrem sa transmitem mai multe informatii, le putem
 pune in membrii unei structuri si sa transmitem adresa structurii
 (conversia oricarui tip pointer dinspre / spre 'void *' se face implicit);
 daca informatia de transmis incape in 'sizeof(void *)', putem sa o convertim
 la 'void *' si sa o transmitem ca atare; compilatorul nu poate, insa, sa
 genereze conversii in mod implicit intre 'void *' si orice alt tip;
 compilatorul poate sa genereze implicit conversii intre 'void *' si un
 tip intreg de aceeasi dimensiune, iar de la acest tip mai departe trebuie
 sa facem conversiile explicit.
  Un tip intreg (cu semn) a carui dimensiune este garantat egala cu a unui
 pointer este 'intptr_t' definit in 'stdint.h' (sau '/usr/include/stdint.h');
 de obicei, acest tip este 'long'; astfel, daca dorim conversia de la
 'void *' la 'int', putem scrie '(int)(intptr_t)r' (unde 'r' este de tip
 'void *'), sau chiar '(int)(long)r'; daca incercam sa facem '(int)r',
 atunci, pe sistemele pe 64 biti, unde sizeof(int) == 4 iar
 sizeof(long) == 8, compilatorul va da un avertisment (warning):
 'cast from pointer to integer of different size'.
- Atentie ca daca dam ca parametru 'void *' o aceeasi adresa de memorie
 mai multor functii executate in threaduri diferite, locatia respectiva
 va fi accesata partajat de threadurile respective si exista risc de
 conditii de cursa; de asemenea, cand dintr-o asemenea functie returnam o
 valoare de tip 'void *', nu este recomandabil sa returnam adresa unei
 variabile automatice alocate in functia respectiva, deoarece aceasta este
 alocata pe stiva threadului iar aceasta stiva nu mai contine informatie
 relevanta dupa returul din functie (si terminarea threadului) - va fi un
 pointer dangling.

Exemplul 8 (preluat din [2]):
==========

 Determinarea valorii maxime dintr-un vector de intregi, folosind
threaduri paralele care inspecteaza cate un segment din vector:

#include <pthread.h>
#include <stdlib.h>
#include <stdio.h>

#define SIZE_ARRAY 1000
#define NR_THREADS 6

typedef struct {int *arr; int from; int to;} TH_STRUCT;

void *thread_fn_max(void *param) {
  TH_STRUCT *s = (TH_STRUCT*) param;
  int i, max;
  max = s -> arr[s -> from];
  for(i = s -> from; i <= s -> to; i++)
    if(s -> arr[i] > max) max = s -> arr[i];
  return (void*)(long)max;
}

void generate_random_array(int *v, int size) {
  int i;
  for(i = 0; i < size; i++) v[i] = rand() % 1000000;
}

int main() {
  int v[SIZE_ARRAY];
  TH_STRUCT params[NR_THREADS]; pthread_t tid[NR_THREADS];
  int i, thMax, max; void *result;

  srand(time(NULL)); generate_random_array(v, SIZE_ARRAY);

  for(i=0; i<NR_THREADS; i++){
    params[i].arr = v;
    if(i == 0) params[i].from = 0; else params[i].from = params[i-1].to + 1;
    params[i].to = params[i].from + SIZE_ARRAY / NR_THREADS - 1;
    if(i < SIZE_ARRAY % NR_THREADS) params[i].to++;
    pthread_create(&tid[i], NULL, thread_fn_max, &params[i]);
  }

  max = 0;
  for(i = 0; i < NR_THREADS; i++){
    pthread_join(tid[i], &result);
    thMax = (int)(long)result;
    if(thMax > max) max = thMax;
  }

  printf("The maximum value is %d.\n", max);
  return 0;
}

Exemplu de testare (fisierul sursa este 'prog.c'):

$gcc -Wall -o prog prog.c -pthread
$./prog
The maximum value is 999961.

Comentarii:
- Functia executata de un thread determina valoarea maxima dintr-o
 portiune a unui array de intregi, cuprinsa intre doua pozitii (indici);
 ea primeste informatiile necesarea printr-o structura a carei adresa
 este transmisa ca parametru; structura contine adresa array-ului,
 pozitia de inceput si positia de sfarsit a portiunii prelucrate;
- Pentru a imparti munca intre threaduri cat mai echitabil, daca
 array-ul are 'SIZE_ARRAY' elemente si avem 'NR_THREADS', numarul
 de elemente procesate de fiecare thread ar trebui să fie
 'SIZE_ARRAY / NR_THREADS'. In cazul in care impartirea nu se face
 exact, este echitabil ca primele 'SIZE_ARRAY % NR_THREADS' threaduri
 sa proceseze cate un element in plus.
- Threadurile sunt lansate la intervale de timp mici unul dupa altul,
 se executa aproximativ in paralel, dar sunt asteptate in ordinea
 in care au fost create; nu avem un instrument nativ (de tip 'wait(NULL)')
 cu care sa asteptam si sa interceptam threadurile in ordinea in care sa
 termina.

 Prezentam cateva dintre functiile cu care se poate opera asupra unui obiect
de tip 'pthread_attr_t':

#include <pthread.h>
int pthread_attr_init(pthread_attr_t *attr);
int pthread_attr_destroy(pthread_attr_t *attr);

Compile and link with -pthread.

  ==>
 Functia 'pthread_attr_init()' initializeaza obiectul cu atribute de
threaduri pointat de 'attr' cu valorile implicite; dupa acest apel,
atribute individuale stocate in obiect pot fi modificate cu functii ca
'pthread_attr_setdetachstate()', 'pthread_attr_setstack()', etc. (a se
vedea mai jos); obiectul setat astfel poate fi folosit apoi la unul sau
mai multe apeluri 'pthread_create()' pentru a crea threaduri; reamintim
insa ca daca vrem sa cream threaduri cu atributele implicite, e suficient
sa apelam 'pthread_create()' cu argumentul 'attr' avand valoarea NULL.
Apelarea lui 'pthread_attr_init()' asupra unui obiect deja initializat are
efect nedefinit.
 Cand un obiect cu atribute de threaduri nu mai este necesar, el trebuie
distrus cu 'pthread_attr_destroy()'; distrugerea obiectului nu are efect
asupra threadurilor create cu ajutorul lui.
 Odata ce un obiect cu atribute de threaduri a fost distrus, el poate fi
reinitializat cu 'pthread_attr_init()'; oricea alta folosire a obiectului
distrus are efect nedefinit.
 Tipul 'pthread_attr_t type' trebuie tratat ca opac: orice acces la
obiect pe alta cale decat cu functiile pthreads este neportabila si
produce efecte nedefinite.
 In caz de succes, 'pthread_attr_init()' si 'pthread_attr_destroy()'
returneaza 0, in caz de esec, returneaza un cod de eroare nenul.

#define _GNU_SOURCE
#include <pthread.h>
int pthread_getattr_np(pthread_t thread, pthread_attr_t *attr);

 ==>
 Functie GNU (non standard - sufixul '_np' din nume inseamna
nonportabil) care recupereaza in obiectul pointat de 'attr' atributele
curente ale threadului (aflat in executie) 'thread'; ele pot diferi de
cele folosite la crearea threadului (cu 'pthread_create()'), de exemplu
poate diferi:
- starea de detasare (detach state), deoarece un thread joinabil se
 poate detasa dupa creare (cu 'pthread_detach()');
- dimensiunea stivei, pe care implementarea o poate alinia adecvat;
- dimensiunea de garda (guard size), pe care implementarea o poate
 rotunji in sus la un multiplu de pagina sau ignora (i.e. trata ca 0)
 daca aplicatia isi aloca propria stiva; o zona de garda (guard area)
 consta dintr-un grup de pagini puse la capatul zonei stiva si care
 sunt protejate la citire/scriere - daca threadul isi depaseste
 (overflow) stiva intrand in zona de garda, are loc segmentation fault
 (in Linux, se primeste semnalul SIGSECV), a.i. depasirea este semnalata.
- daca dimensiunea stivei nu a fost setata intre atributele folosite
 la crearea threadului, se va raporta adresa stivei actuala pe care
 implementarea a selectat-o pentru thread.
 Cand obiectul cu atribute de threaduri setat de 'pthread_getattr_np()'
nu mai este necesar, el trebuie distrus cu 'pthread_attr_destroy()'.
 In caz de succes, functia returneaza 0, in caz de esec, returneaza un
cod de eroare nenul.

#include <pthread.h>
int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
int pthread_attr_getdetachstate(const pthread_attr_t *attr,
                                  int *detachstate);
  ==>
 Functia 'pthread_attr_setdetachstate()' seteaza atributul referitor la
starea de detasare (detach state) din obiectul cu atribute de threaduri
indicat de 'attr' la valoarea 'detachstate'; atributul determina daca un
thread creat cu obiectul '*attr' va fi creat intr-o stare asteptabila
(joinable) sau detasata (detached); valorile lui 'detachstate' pot fi:
'PTHREAD_CREATE_DETACHED' (threadurile vor fi create in detached state)
sau 'PTHREAD_CREATE_JOINABLE' (threadurile vor fi create in joinable state).
 Valoarea implicita a atributului intr-un obiect cu atribute de threaduri
nou initializat este 'PTHREAD_CREATE_JOINABLE'.
 Functia 'pthread_attr_getdetachstate()' furnizeaza in locatia indicata de
'detachstate' atributul detach state din obiectul cu atribute de threaduri
indicat de 'attr'.
 In caz de succes, ambele functii returneaza 0, in caz de esec, returneaza
un cod de eroare nenul.

#include <pthread.h>
int pthread_attr_setstack(pthread_attr_t *attr,
                          void stackaddr[.stacksize],
                          size_t stacksize);
int pthread_attr_getstack(const pthread_attr_t *restrict attr,
                          void **restrict stackaddr,
                          size_t *restrict stacksize);
  ==>
 Functia 'pthread_attr_setstack()' seteaza atributele referitoare la
adresa stivei (adresa inferioara) si dimensiunea stivei din obiectul cu
atribute de threaduri indicat de 'attr' la valorile specificate in
locatiile pointate de 'stackaddr', respectiv 'stacksize'; paginile zonei
stiva specificate trebuie sa aiba permisiune de citire si scriere. Daca
vrem sa folosim obiectul indicat de 'attr' pentru a crea mai multe threaduri,
trebuie sa schimbam de fiecare data zona stiva, pentru ca threadurile sa nu
opereze pe aceeasi stiva.
 Functia 'pthread_attr_getstack()' furnizeaza atributele respective in
locatiile indicate.
 In caz de succes, ambele functii returneaza 0, in caz de esec (de exemplu,
in cazul primei functii, stiva indicata are < PTHREAD_STACK_MIN (16384)
octeti, sau adresele de inceput si sfarsit ale stivei nu sunt aliniate
adecvat, sau apelantul nu are permisiuni de citire si scriere pe zona stiva
respectiva), returneaza un cod de eroare nenul.
 Cele doua functii sunt folosite atunci cand se doreste ca aplicatia sa preia
toata responsabilitatea in ceea ce priveste alocarea stivelor; in majoritatea
aplicatiilor, aceste functii nu sunt insa necesare si ar trebui evitate
(setarile implicite sunt suficienate).

Observatie: calificatorul de tip 'restrict' este o indicatie pentru
compilator ca, daca memoria adresata prin pointerul calificat cu 'restrict'
este modificata, nici un alt pointer nu va accesa acea memorie; compilatorul
poate alege sa optimizeze codul care foloseste pointeri calificati cu
'restrict' intr-un mod care ar putea altfel avea ca efect un comportament
incorect. Este responsabilitatea programatorului sa asigure ca pointerii
calificati cu 'restrict' sunt folositi asa cum s-a intentionat, altfel poate
rezulta un comportament nedefinit.

#include <pthread.h>
int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
int pthread_attr_getstacksize(const pthread_attr_t *restrict attr,
                              size_t *restrict stacksize);

  ==>
 Functia 'pthread_attr_setstacksize()' seteaza atributul referitor la
dimensiunea stivei din obiectul cu atribute de threaduri indicat de 'attr'
la valoarea 'stacksize'; atributul determina dimensiunea minima in octeti
a stivei care va fi alocata pentru threadurile create cu ajutorul obiectului
respectiv.
 Functia 'pthread_attr_getstacksize()' furnizeaza valoarea atributului in
locatia indicata.
 In caz de succes, ambele functii returneaza 0, in caz de esec (de exemplu,
in cazul primei functii, stiva indicata are < PTHREAD_STACK_MIN (16384)
octeti, sau dimensiunea nu este multiplu de pagina), returneaza un cod de
eroare nenul.
 Nota:

 Dimensiunea stivei unui thread este fixata la momentul crearii threadului.
Doar threadul principal isi poate creste dinamic stiva.
 Daca limita de resursa soft (soft resource limit) 'RLIMIT_STACK' la momentul
pornirii programului are alta valoare decat RLIM_INFINITY ("unlimited"), el
determina dimensiunea implicita a stivei pentru noile threaduri; daca limita
este "unlimited", pentru dimensiunea stivei este folosita o valoare
dependenta de arhitectura, de exemplu, pentru x86_64, dimensiunea este 2 MB.
Pentru limitele de resursa si zona stiva a unui proces, a se revedea si
cursul de USO.

#include <pthread.h>
int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize);
int pthread_attr_getguardsize(const pthread_attr_t *restrict attr,
                              size_t *restrict guardsize);
  ==>
 Functia 'pthread_attr_setguardsize()' seteaza atributul referitor la
dimensiunea zonei de garda de la capatul stivei din obiectul cu atribute de
threaduri indicat de 'attr' la valoarea 'guardsize'.
 Daca 'guardsize' este > 0, atunci pentru threadurile create cu ajutorul
obiectului '*attr' se aloca o zona suplimentara de cel putin 'guardsize'
octeti la capatul stivei care sa functioneza ca zona de garda pentru stiva.
 Daca 'guardsize' este 0, threadurile create cu ajutorul obiectului '*attr'
nu vor avea o zona de garda.
 Dimensiunea implicita a zonei de garda este de o pagina.
 Daca in obiectul '*attr' a fost setat atributul de adresa stivei (de
exemplu, cu 'pthread_attr_setstack()'), ceea ce inseamna ca apelantul este
cel care aloca stiva threadului, atributul referitor la dimensiunea zonei
de garda este ignorat (i.e. nu este creata o zona de garda) si este
responsabilitatea aplicatiei sa gestioneze stack overflow (de exemplu,
folosind 'mprotect()' pentru a defini manual o zona de garda la capatul
stivei pe care a alocat-o).
 Functia 'pthread_attr_getguardsize()' furnizeaza in locatia indicata
atributul respectiv.
 In caz de succes, ambele functii returneaza 0, in caz de esec, returneaza
un cod de eroare nenul.
Nota: am spus mai devreme (la functia 'pthread_getattr_np()') ca o zona de
garda (guard area) consta dintr-un grup de pagini puse la capatul zonei
stiva si care sunt protejate la citire/scriere - daca threadul isi depaseste
(overflow) stiva intrand in zona de garda, are loc segmentation fault
 (in Linux, se primeste semnalul SIGSECV), a.i. depasirea este semnalata.
Zonele de garda incep de la adrese aliniate la nivel de pagina iar
dimensiunea este rotunjita intern in sus la multiplu de pagina cand se creaza
un thread (cu toate acestea, 'pthread_attr_getguardsize()' furnizeaza
dimensiunea guard size care a fost setata cu 'pthread_attr_setguardsize()').
Setarea guard size la 0 poate fi util pentru a economisi memorie intr-o
aplicatie care creaza mai multe threaduri si are certitudinea ca nu poate
aparea stack overflow. Setarea guard size la o valoare mai mare decat cea
implicita poate fi necesara pentru a detecta stack overflows atunci cand
threadul aloca pe stiva structuri de date mari.

Exemplul 9 (adaptat din [1]):
==========

Crearea unui thread initializat cu detasare:

#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>

pthread_t thr; pthread_attr_t attr;

void *threadFunc(void *arg) {
  int i;
  for(i = 0; i < 3; ++i) {sleep(1); printf("%d\n", i);}
  return NULL;
}

int main() {

  /* Asigneaza valori implicite */
  if(errno = pthread_attr_init(&attr))
    {perror("pthread_attr_init"); exit(EXIT_FAILURE);}

  if(errno = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED))
    {perror("pthread_attr_setdetachstate"); exit(EXIT_FAILURE);}


  if(errno = pthread_create(&thr, &attr, threadFunc, (void *) 1))
    {perror("pthread_create"); exit(EXIT_FAILURE);}

  /* Nu ne mai trebuie */
  if(errno = pthread_attr_destroy(&attr))
    {perror("pthread_attr_destroy"); exit(EXIT_FAILURE);}

  printf("Threadul principal se termina\n");
 /* Permitem threadului creat sa continuie dupa terminarea celui principal */
  pthread_exit(NULL);
  return 0; // unreachable
}

Exemplu de testare (executabilul este 'prog'):

$./prog
Threadul principal se termina
0
1
2


4.5. Sincronizarea threadurilor:
--------------------------------

 Prezentam in continuare doua instrumente din biblioteca pthreads care se
pot folosi la comunicarea si sincronizarea dintre threaduri: mutexuri si
variabile de conditie.
 Mutexurile permit threadurilor sa-si sincronizeze utilizarea resurselor
partajate, de exemplu sa le utilizeze in excluziune mutuala, iar variabilele
de conditie permit threadurilor sa se informeze reciproc asupra faptului ca o
resursa partajata si-a aschimbat starea.


4.5.1. Mutexuri:
----------------

 Reamintim din cursul 6 SO ca, la nivel de concept, un mutex este o variabila
cu doua stari posibile: deschis/inchis si in legatura cu care sunt definite
doua operatii (atomice): lock/unlock; lock = daca mutexul este deschis, il
inchide iar apelantul continua, iar daca mutexul este inchis, apelantul este
blocat la mutex-ul respectiv; unlock = daca mutexul este deschis, nu face
nimic, iar daca este inchis, il deschide si trezeste pe unul dintre cei
blocati la el (daca exista) - acesta isi va finaliza operatia lock si va
continua, iar mutexul va ramane inchis (daca nu era nimeni blocat la el,
mutexul ramane deschis). Mutexurile sunt versiuni simplificate de semafoare,
pe care le folosim atunci cand nu vrem sa numaram ci doar sa obtinem
excluziunea mutuala.
 Asemeni semafoarelor POSIX despre care am discutat mai devreme, mutexurile
pthreads sunt plasate in spatiul utilizator si astfel pot fi operate atat cu
instrumente specifice pthreads dar si cu instructiuni obisnuite de accesare
a memoriei, ceea ce insa nu este recomandabil.
 Spre deosebire de semafoare, care necesita un apel sistem pentru operatiile
de tip lock/unlock iar apelurile sistem sunt costisitoare, mutexurile sunt
implementate folosind operatii - masina atomice (gen TSL) asupra locatiilor
de memorie vizibile tuturor threadurilor si necesita apel sistem doar atunci
cand trebuie sa blocheze threadul; in Linux, apelul sistem folosit de
mutexuri pentru blocare este 'futex()'.

#include <pthread.h>
int pthread_mutex_init(pthread_mutex_t *restrict mutex,
                       const pthread_mutexattr_t *restrict attr);
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
int pthread_mutex_destroy(pthread_mutex_t *mutex);

  ==>
 Inainte de a fi folosit, un mutex trebuie initializat.
 Functia 'pthread_mutex_init()' initializeaza mutexul pointat de 'mutex' cu
atributele din obiectul de tip 'pthread_mutexattr_t' pointat de 'attr' si
care trebuie initializat in prealabil; daca 'attr' este NULL, mutexul este
initializat cu atributele implicite. Mutexul devine initializat si deschis
(unlocked).
 Doar mutexul insusi poate fi folosit la sincronizare, incercarea de a folosi
copii ale sale in apelurile 'pthread_mutex_lock()','pthread_mutex_trylock()',
'pthread_mutex_unlock()', 'pthread_mutex_destroy()' are efect nedefinit.
 Incercarea de a initializa un mutex deja initializat are efect nedefinit.
 Mutexurile alocate static (deci, nu dinamic in heap sau automatic, pe
stiva) pot fi initializate cu atributele implicite si folosind macro-ul
'PTHREAD_MUTEX_INITIALIZER':
                pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
efectul este echivalent cu initializarea dinamica printr-un apel al functiei
'pthread_mutex_init()' cu argumentul 'attr' NULL, cu exceptia faptului ca nu
se efectueaza verificari ale erorilor.
 Functia 'pthread_mutex_destroy()' distruge obiectul mutex pointat de
'mutex'; in fapt, mutexul devine neinitializat; el poate fi reinitializat
folosind 'pthread_mutex_init()'; rezultatul altor accesari ale mutexului dupa
distrugere este nedefinit. Mutexurile alocate dinamic sau automatic trebuie
distruse atunci cand nu mais sunt necesare, cele alocate static si
initializate cu 'PTHREAD_MUTEX_INITIALIZER' nu este necesar sa fie distruse;
daca mutexul rezida intr-o zona alocata dinamic, el trebuie distrus inainte
de eliberarea zonei ('free()'); daca mutexul este alocat automatic, el
trebuie distrus inainte ca functia sa gazda sa returneze.
 Un mutex initializat care este descuiat (unlocked) poate fi distrus in
siguranta; incercarea de a distruge un mutex neinitializat sau incuiat
(locked) are efect nedefinit.
 In caz de succes, cele doua functii returneaza 0, in caz de esec, returneaza
un cod de eroare.

#include <pthread.h>
int pthread_mutexattr_init(pthread_mutexattr_t *attr);
int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);

  ==>
 Functia 'pthread_mutexattr_init()' initializeaza obiectul cu atribute de
mutexuri pointat de 'attr' cu valorile implicite ale atributelor;
incercarea de a initializa un obiect deja initializat are efect nedefinit.
 Dupa ce obiectul obiectul cu atribute de mutexuri a fost folosit pentru a
initializa unul sau mai multe mutexuri, orice functie care afecteaza
obiectul (inclusiv cea de distrugere) nu va afecta mutexurile initializate
anterior.
 Functia 'pthread_mutexattr_destroy() distruge obiectul cu atribute de
mutexuri pointat de 'attr'; in fapt, obiectul devine neinitializat; el
poate fi reinitializat folosind 'pthread_mutexattr_init()'; rezultatul
altor accesari ale obiectului dupa distrugere este nedefinit; incercarea
de a distruge un obiect neinitializat are efect nedefinit.
 In caz de succes, cele doua functii returneaza 0, in caz de esec, returneaza
un cod de eroare.

 Odata initializat un obiect cu atribute de mutexuri, putem consulta /
modifica ulterior unele dintre atributele continute, folosind functii ca
'pthread_mutexattr_gettype()', 'pthread_mutexattr_settype()', etc.
(vom vedea mai tarziu).

#include <pthread.h>
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);

#include <pthread.h>
#include <time.h>
int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex,
                            const struct timespec *restrict abstime);

  ==>
 Functia 'pthread_mutex_lock()' incearca sa inchida mutexul pointat de
'mutex', in sensul operatiei lock descrisa mai devreme: daca mutexul
era deshis, il inchide , apelantul devine detinatorul (owner) mutexului,
iar functia returneaza imediat; daca mutexul era inchis de alt thread,
apelantul ramane blocat in apel la mutexul respectiv; in orice moment,
cel mult un thread poate detine mutexul; doar threadul care detine un
mutex inchis poate sa-l deschida (unlock); datorita proprietatii de
posesie, in loc de inchidere (lock) / deschidere (unloc) se mai spune
achizitionare (acquire) / eliberare (release).
 Daca un thread incearca sa re-incuie un mutex pe care deja l-a incuiat,
efectul depinde de tipul mutexului (a se vedea mai jos); in Linux, pentru
tipul implicit de mutex, are loc thread deadlock.
 Functia 'pthread_mutex_trylock()' este la fel ca 'pthread_mutex_lock(), cu
exceptia faptului ca daca mutexul este curent inchis, nu blocheaza apelantul
ci esueaza returnand codul de eroare EBUSY.
 Functia 'pthread_mutex_timedlock()' este la fel ca 'pthread_mutex_lock(),
cu exceptia faptului ca apelantul poate specifica, in locatia pointata de
'abstime' o limita a timpului cat apelantul va fi blocat asteptand sa
achizitioneze mutexul; daca intervalul de timp specificat expira fara
ca apelantul sa achizitioneze mutexul, apelantul continua iar functia
'pthread_mutex_timedlock()' returneaza codul de eroare ETIMEDOUT.
 Functia 'pthread_mutex_unlock()' deschide mutexul pointat de 'mutex',
in sensul operatiei lock descrisa mai devreme: daca erau threaduri blocate
la el, este ales unul dintre ele (nespecificat), caruia i se permite sa
inchida / achizitioneze mutexul, acesta isi finalizeaza apelul de inchidere
si continua, iar mutexul ramane inchis; daca nu erau threaduri blocate la
el, mutexul ramane deschis; in toate cazurile, apelul'pthread_mutex_unlock()'
returneaza (nu blocheaza). Un thread poate deschide doar un mutex care
anterior a fost inchis / achizitionat de el. Este o eroare a incerca
deschiderea unui mutex deschis sau care este inchis / detinut de alt thread.

Nota: pentru a preveni interblocarea (deadlock) threadurilor la mutexuri,
se pot folosi urmatoarele strategii:
- definirea unei ierarhii a mutexurilor: daca mai multe threaduri doresc
 sa inchida un acelasi set de mutexuri, trebuie sa incerce sa le inchida
 in aceeasi ordine;
- "incerci si apoi revii": un thread incearca sa inchida primul mutex
 folosind 'pthread_mutex_lock()', apoi incearca sa inchida mutexurile
 ramase cu folosind 'pthread_mutex_trylock()'; daca vreunul dintre apelurile
 'pthread_mutex_trylock()' esueaza (cu EBUSY), threadul elibereaza toate
 mutexurile, apoi incearca din nou, eventual dupa un interval de tip de
 intarziere.
A doua strategie este mai putin eficienta decat prima, deoarece pot fi
necesare mai multe iteratii, dar poate fi mai flexibila, deoarece nu necesita
o ierarhie rigida a mutexurilor.

Exemplul 10 (adaptat din [1]):
===========

Folosirea unui mutex pentru a proteja accesul in excluziune mutuala la o
variabila globala, partajata intre mai multe threaduri:

#include <pthread.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>

static int glob = 0;
static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;

/* Loop 'arg' times incrementing 'glob' */
static void *threadFunc(void *arg) {
  int loops = *((int *) arg);
  int loc, j;
  for (j = 0; j < loops; j++) {
    if(errno = pthread_mutex_lock(&mtx))
      {perror("pthread_mutex_lock"); exit(EXIT_FAILURE);}
    loc = glob; loc++; glob = loc;
    if(errno = pthread_mutex_unlock(&mtx))
      {perror("pthread_mutex_unlock"); exit(EXIT_FAILURE);}
  }
  return NULL;
}

int main(int argc, char *argv[]) {
  pthread_t t1, t2; int loops1, loops2;
  loops1 = (argc > 1) ? atoi(argv[1]) : 10000000;
  loops2 = loops1;
  if(errno = pthread_create(&t1, NULL, threadFunc, &loops1))
    {perror("pthread_create"); exit(EXIT_FAILURE);}
  if(errno = pthread_create(&t2, NULL, threadFunc, &loops2))
    {perror("pthread_create"); exit(EXIT_FAILURE);}
  if(errno = pthread_join(t1, NULL))
    {perror("pthread_join"); exit(EXIT_FAILURE);}
  if(errno = pthread_join(t2, NULL))
    {perror("pthread_join"); exit(EXIT_FAILURE);}
  printf("glob = %d total loops = %d\n", glob, loops1 + loops2);
  exit(EXIT_SUCCESS);
}

Exemplu de testare (executabilul este 'prog'):

$./prog
glob = 20000000 total loops = 20000000

Comentarii:
- Deoarece am furnizat functiilor executate de threaduri numerul de iteratii
 printr-o locatie de memorie, am folosit locatii diferite, 'loop1' si
 'loop2' pentru respectiva cele doua threaduri; nu era insa nevoie, deoarece
 threadurile nu incearca sa modifice locatia pointata de 'arg', asa ca nu
 apar conditii de cursa.
- Rezultatul afisat ne-a aratat ca nu s-a pierdut nici o unitate de
 incrementare (via eventuale conditii de cursa legate de variabila
 partajata 'glob').

Exemplul 11 (adaptat din [2], unde este realizat cu semafoare):
===========

 Dorim sa scriem o functie care adauga la finalul unui fisier un mesaj dat
(logging). Aceasta functie trebuie sa poata fi apelata din threaduri diferite
pentru a scrie in acelasi fisier, fara ca fisierul sa devina corupt. In acest
caz, resursa comuna este fisierul, iar regiunea critica va fi codul ce
opereaza asupra fisierului. Excluziunea mutuala se va realiza cu ajutorul
unui mutex:

#include <pthread.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>

char *filename;

void write_log(const char *message, pthread_mutex_t *mtx) {
  int fd;
  //entering the critical region
  pthread_mutex_lock(mtx);
  if((fd = open(filename, O_CREAT | O_WRONLY | O_APPEND, 0644)) == -1)
    perror(filename);
  else
    {write(fd, message, strlen(message)); close(fd);}
  //exiting the critical region
  pthread_mutex_unlock(mtx);
}

typedef struct {int value; pthread_mutex_t *mtx;} TH_STRUCT;
#define NR_THREADS 4

void *thread_function(void *p) {
  TH_STRUCT *s = (TH_STRUCT*)p; int i, count; char message[20];
  for(i = 0; i < 3; i++) {
    usleep(1000 * (rand() % 20));
    count = s->value + i + 1;
    snprintf(message, 20, "Log entry %d\n", count);
    write_log(message, s->mtx);
  }
  return NULL;
}

int main(int argc, char **argv) {
  pthread_mutex_t mtx;
  TH_STRUCT params[NR_THREADS]; pthread_t tids[NR_THREADS];
  int i;
  switch(argc) {
    case 1: filename = "log.txt"; break;
    case 2: filename = argv[1]; break;
    default: fprintf(stderr, "Usage: %s [filename]\n", argv[0]);
             exit(EXIT_FAILURE);
  }
  //initialize random number generator
  srand(time(NULL));
  //initialize the mutex
  if(errno = pthread_mutex_init(&mtx, NULL))
    {perror("pthread_mutex_init"); exit(EXIT_FAILURE);}
  //create the threads
  for(i = 0; i < NR_THREADS; i++) {
    params[i].value = 10 * (i + 1); params[i].mtx = &mtx;
    if(errno = pthread_create(&tids[i], NULL, thread_function, &params[i]))
      {perror("pthread_create"); exit(EXIT_FAILURE);}
  }
  //wait for the threads to finish
  for(i = 0; i < NR_THREADS; i++)
    pthread_join(tids[i], NULL);
  //destroy the mutex
  pthread_mutex_destroy(&mtx);
  return 0;
}

Exemplu de testare (sursa este 'prog.c'):

$gcc -Wall -o prog prog.c -pthread
$./prog flog.txt
$cat flog.txt
Log entry 31
Log entry 11
Log entry 41
Log entry 21
Log entry 42
Log entry 32
Log entry 12
Log entry 13
Log entry 43
Log entry 22
Log entry 33
Log entry 23
$cat flog.txt | wc -l
12
$rm flog.txt

Comentarii:
- Am testat doar apelurile care este de asteptat sa esueze (de exemplu,
 deschiderea fisierului cu 'open()', nu si inchiderea cu 'close()' - daca
 avem incredere ca nu am comis erori de programare, descriptorul furnizat
 lui 'close()' este valid si deschis, deci 'close()' va avea succes;
 excesul de verificari poate scadea performanta programului.
- Initializarea mutexului se putea face si definind:
     static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
 in loc de:
  if(errno = pthread_mutex_init(&mtx, NULL))
    {perror("pthread_mutex_init"); exit(EXIT_FAILURE);}

 Pentru comparatie, acelasi program ca  mai inainte, dar cu semafoare POSIX
anonime:

#include <pthread.h>
#include <semaphore.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>

char *filename;

void write_log(const char *message, sem_t *logSem) {
  int fd;
  //entering the critical region
  sem_wait(logSem);
  if((fd = open(filename, O_CREAT | O_WRONLY | O_APPEND, 0644)) == -1)
    perror(filename);
  else
    {write(fd, message, strlen(message)); close(fd);}
  //exiting the critical region
  sem_post(logSem);
}

typedef struct {int value; sem_t *logSem;} TH_STRUCT;
#define NR_THREADS 4

void *thread_function(void *p) {
  TH_STRUCT *s = (TH_STRUCT*)p; int i, count; char message[20];
  for(i = 0; i < 3; i++) {
    usleep(1000 * (rand() % 20));
    count = s->value + i + 1;
    snprintf(message, 20, "Log entry %d\n", count);
    write_log(message, s->logSem);
  }
  return NULL;
}

int main(int argc, char **argv) {
  sem_t logSem; TH_STRUCT params[NR_THREADS]; pthread_t tids[NR_THREADS];
  int i;
  switch(argc) {
    case 1: filename = "log.txt"; break;
    case 2: filename = argv[1]; break;
    default: fprintf(stderr, "Usage: %s [filename]\n", argv[0]);
             exit(EXIT_FAILURE);
  }
  //initialize random number generator
  srand(time(NULL));
  //initialize the semaphore
  if(sem_init(&logSem, 0, 1) != 0) {perror("sem_init"); exit(EXIT_FAILURE);}
  //create the threads
  for(i = 0; i < NR_THREADS; i++) {
    params[i].value = 10 * (i + 1); params[i].logSem = &logSem;
    if(errno = pthread_create(&tids[i], NULL, thread_function, &params[i]))
      {perror("pthread_create"); exit(EXIT_FAILURE);}
  }
  //wait for the threads to finish
  for(i = 0; i < NR_THREADS; i++)
    pthread_join(tids[i], NULL);
  //destroy the semaphore
  sem_destroy(&logSem);
  return 0;
}

Exemplu de testare (sursa este 'prog.c'):

$gcc -Wall -o prog prog.c -pthread
$./prog
$cat log.txt
Log entry 31
Log entry 11
Log entry 12
Log entry 41
Log entry 13
Log entry 21
Log entry 32
Log entry 42
Log entry 22
Log entry 43
Log entry 33
Log entry 23
$cat log.txt | wc -l
12
rm log.txt

 Pentru comparatie, acelasi program ca mai inainte, dar cu semafoare POSIX
cu nume; ele pot fi folosite si din procese diferite care acceseaza un
acelasi fisier:

#include <pthread.h>
#include <semaphore.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>

char *filename, *semname;

void write_log(const char *message, sem_t *logSem) {
  int fd;
  //entering the critical region
  sem_wait(logSem);
  if((fd = open(filename, O_CREAT | O_WRONLY | O_APPEND, 0644)) == -1)
    perror(filename);
  else {
    write(fd, message, strlen(message)); close(fd);}
  //exiting the critical region
  sem_post(logSem);
}

typedef struct {int value; sem_t *logSem;} TH_STRUCT;
#define NR_THREADS 4

void *thread_function(void *p) {
  TH_STRUCT *s = (TH_STRUCT*)p; int i, count; char message[20];
  for(i = 0; i < 3; i++) {
    usleep(1000 * (rand() % 20));
    count = s->value + i + 1;
    snprintf(message, 20, "Log entry %d\n", count);
    write_log(message, s->logSem);
  }
  return NULL;
}

int main(int argc, char **argv) {
  sem_t *logSem; TH_STRUCT params[NR_THREADS]; pthread_t tids[NR_THREADS];
  int i;
  switch(argc) {
    case 1: filename = "log.txt"; semname = "/log_semaphore"; break;
    case 2: filename = argv[1]; semname = "/log_semaphore"; break;
    case 3: filename = argv[1]; semname = argv[2]; break;
    default: fprintf(stderr, "Usage: %s [filename [semaphore]]\n", argv[0]);
             exit(EXIT_FAILURE);
  }
  //initialize random number generator
  srand(time(NULL));
  //initialize the semaphore
  if((logSem = sem_open(semname, O_CREAT, 0644, 1)) == SEM_FAILED)
    {perror("sem_open"); exit(EXIT_FAILURE);}
  //create the threads
  for(i = 0; i < NR_THREADS; i++) {
    params[i].value = 10 * (i + 1); params[i].logSem = logSem;
    if(errno = pthread_create(&tids[i], NULL, thread_function, &params[i]))
      {perror("pthread_create"); exit(EXIT_FAILURE);}
  }
  //wait for the threads to finish
  for(i = 0; i < NR_THREADS; i++)
    pthread_join(tids[i], NULL);
  //destroy the semaphore
  sem_close(logSem);
  sem_unlink(semname);
  return 0;
}

Exemplu de testare (sursa este 'prog.c'):

$gcc -Wall -o prog prog.c -pthread
$./prog flog.txt /fsem
$cat flog.txt
Log entry 21
Log entry 11
Log entry 22
Log entry 31
Log entry 32
Log entry 33
Log entry 41
Log entry 23
Log entry 12
Log entry 42
Log entry 13
Log entry 43
$cat flog.txt | wc -l
12
$rm flog.txt

Comentariu:
  Puteam transmite ca parametru functiei 'write_log()' numele semaforului
 (acel 'semname') iar functia sa-i faca inclusiv deschiderea; atunci, in
 functie am fi definit o variabila locala 'sem_t *logSem', am fi apelat
 la inceput 'logSem = sem_open(semname, 0)' (deci, fara 'O_CREAT') si la
 sfarsit 'sem_close(logSem)'; in 'main()' am fi pastrat apelul
 'sem_open(semname, O_CREAT, 0644, 1)' (deci, cu 'O_CREAT').

 Ficare mutex are un tip (este un atribut al mutexului care se poate
specifica prin obiectul de tip 'pthread_mutexattr_t' pointat de argumentul
'attr' al functiei 'pthread_mutex_init()'), care defineste comportamentul
sau in anumite situatii speciale:
 - incercarea unui thread de a inchide un mutex pe care l-a inchis deja
  in prealabi (i.e. il detine);
 - incercarea unui thread de a deschide un mutex pe care nu l-a inchis el
  (i.e. nu il detine);
 - incercarea unui thread de a dechide un mutex deschis (i.e. ne-detinut
  de nimieni).
Tipurile de mutex pot fi:
'PTHREAD_MUTEX_NORMAL' : nu are implementata detectarea auto-deadlock-ului;
  daca un thread incearca sa inchida un mutex pe care deja l-a inchis,
  rezulta deadlock; incercarea de a deschide un mutex deschis sau care este
  inchis (detinut) de alt thread, are efect nedefinit (in Linux, pentru acest
  tip de mutex, ambele operatii reusesc).
'PTHREAD_MUTEX_ERRORCHECK': se face verificarea erorilor la toate operatiile;
  in toate cele trei scenarii descrise mai sus, functiile pthreads relevante
  returneaza eroare; acest tip de mutex este, in mod tipic, mai lent decat
  un mutex normal, dar poate fi util ca instrument de depanare pentru a
  descoperi unde aplicatia utilizeaza inadecvat;
'PTHREAD_MUTEX_RECURSIVE' : implementeaza conceptul de contorizare a
  inchiderilor (lock count) - cand un thread inchide prima data
  (achizitioneaza) un mutex, contorul este setat la 1; fiecare operatie
  ulterioara de inchidere / deschidere efectuata de acelasi thread
  incrementeaza contorul / contorul, iar mutexul este eliberat (i.e.
  facut disponibil altor threaduri pentru a fi achizitionat)doar cand
  contorul a ajuns la 0; incercarea de a deschide un mutex deschis sau
  incercarea de a deschide un mutex inchis de alt thread esueaza.

 Implementarea Linux ofera initializatori statici non-standard (deci,
non-portabili) pentru fiecare dintre tipurile de mai sus (de exemplu,
'PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP').

 In plus fata de tipurile de mutex de mai sus, SUSv3 defineste tipul
'PTHREAD_MUTEX_DEFAULT', care este tipul implicit al unui mutex initializat
cu 'PTHREAD_MUTEX_INITIALIZER' sau cu 'pthread_mutex_init()' avand argumentul
'attr' NULL; comportamentul acestui tip de mutex in cele trei scenarii de mai
sus este nedefinit in standard, fiind lasat la dispozitia implementatorului;
in Linux, un mutex 'PTHREAD_MUTEX_DEFAULT' se comporta ca un mutex
'PTHREAD_MUTEX_NORMAL'.

 Pentru a afla / seta tipul unui mutex (intr-un obiect cu atribute de
mutexuri, care poate fi folosit ulterior la initializat mutexuri), se
pot folosi:

#include <pthread.h>
int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict attr,
                              int *restrict type);
int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);

  ==>
 Consulta, respectiv seteaza, atributul de tip din obiectul cu atribute de
mutexuri pointat de 'attr' la valoarea indicata de type; aceasta valoare
poate fi specifcicata prin constantele 'PTHREAD_MUTEX_NORMAL',
'PTHREAD_MUTEX_ERRORCHECK', 'PTHREAD_MUTEX_RECURSIVE PTHREAD_MUTEX_DEFAULT';
valoarea implicita a atributuilui de tip este 'PTHREAD_MUTEX_DEFAULT'; obiectul
pointat de 'attr' trebuie initializat in prealabil, altfel efectul functiilor
este nedefinit.
 In caz de succes, ambele functii returneaza 0, in caz de esec, returneaza
un cod de eroare nenul.
 Nota: este recomandabil ca in aplicatii sa nu se foloseasca mutexuri
'PTHREAD_MUTEX_RECURSIVE' cu variabile de conditie, deoarece deschiderea
implicita efectuata de 'pthread_cond_timedwait()' sau 'pthread_cond_wait()'
s-ar putea sa nu elibereze in fapt mutexul, daca a fost inchis de mai multe
ori, si atunci nici un alt thread nu va putea satisface conditia
predicatului.

 Manualul de programare POSIX mentioneaza ca daca un semnal este livrat unui
thread care astepta la un mutex, dupa revenirea din handlerul semnalului,
threadul trebuie sa-si reia asteptarea la mutex ca si cand nu ar fost
intrerupt.

 Un alt atribut de mutex (stocat intr-un obiect cu atribute de mutexuri,
care poate fi folosit ulterior la initializat mutexuri), este atributul de
partajare intre procese (process-shared attribute) - el se refera la
posibilitatea ca mutexul sa fie partajat si intre threaduri din procese
diferite, nu doar intre threaduri din acelasi proces:

#include <pthread.h>
int pthread_mutexattr_getpshared(const pthread_mutexattr_t *attr,
                                 int *pshared);
int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr,
                                 int pshared);

Compile and link with -pthread.

  ==>
 Consulta, respectiv seteaza, atributul de partajare intre procese
(process-shared attribute) din obiectul cu atribute de mutexuri pointat de
'attr'; obiectul pointat de 'attr' trebuie sa fie initializat, altfel
comportamentul este nedefinit; valorile posibile ale atributului si
semnificatiile lor sunt:
'PTHREAD_PROCESS_SHARED' :  mutexurile create astfel pot fi partajate intre
  toate threadurile care au acces la memoria care contine mutexul, chiar
  daca threadurile respective sunt in procese diferite;
'PTHREAD_PROCESS_PRIVATE' : mutexurile create astfel pot fi partajate doar
  intre thredurile create din acelasi proces care a initializat mutexul.
Valoarea implicita a atributului de partajare intre procese este
'PTHREAD_PROCESS_PRIVATE'.
 In caz de succes, cele doua functii returneaza 0, in caz de esec, returneaza
un cod de eroare pozitiv.
 Observatie: Despre atributul de partajare intre procese am mai discutat,
cu ocazia semafoarelor POSIX. Am vazut ca, in Linux/glibc, acest atribut
indica daca pagina in care este alocat mutexul este mapata 'mmap()' in
spatiul utilizator cu 'MAP_PRIVATE' (si atunci va fi partajata intre
threadurile procesului dar va fi mostenita copy-on-write de procesele copil,
care isi vor face duplicate in cazul cand o vor modifica) sau 'MAP_SHARED'
(si atunci va fi mostenita partajat de procesele copil, care vor modifica
acelasi exemplar al paginii).

Exemplul 12 (adaptat din [1]):
==============================

 Ilustram modul de setare/consultare a tipului unui mutex:

#include <pthread.h>
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
int main(){
  pthread_mutex_t mtx;
  pthread_mutexattr_t mtxAttr;

  if(errno = pthread_mutexattr_init(&mtxAttr))
    {perror("pthread_mutexattr_init"); exit(EXIT_FAILURE);}

  if(errno = pthread_mutexattr_settype(&mtxAttr, PTHREAD_MUTEX_ERRORCHECK))
    {perror("pthread_mutexattr_settype"); exit(EXIT_FAILURE);}

  if(errno = pthread_mutex_init(&mtx, &mtxAttr))
    {perror("pthread_mutex_init"); exit(EXIT_FAILURE);}

  if(errno = pthread_mutexattr_destroy(&mtxAttr))
    {perror("pthread_mutexattr_destroy"); exit(EXIT_FAILURE);}
  return 0;
}

 Un alt atribut de mutex (stocat intr-un obiect cu atribute de mutexuri,
care poate fi folosit ulterior la initializat mutexuri), este atributul de
robustete (robustness) - el specifica comportamentul mutexului atunci cand
threadul detinator (owning thread, deci cel care a inchis si detine
mutexul) se termina (dies) fara a elibera (unlock) mutexul. Avem
urmatoarele functii:

#include <pthread.h>
int pthread_mutexattr_getrobust(const pthread_mutexattr_t *attr,
                                int *robustness);
int pthread_mutexattr_setrobust(const pthread_mutexattr_t *attr,
                                int robustness);

Compile and link with -pthread.

  ==>
 Consulta, respectiv seteaza, atributul de robustete (robustness attribute)
din obiectul cu atribute de mutexuri pointat de 'attr'; obiectul pointat de
'attr' trebuie sa fie initializat, altfel comportamentul este nedefinit;
valorile posibile ale atributului si semnificatiile lor sunt:
'PTHREAD_MUTEX_STALLED' : este valoarea implicita; daca detinatorul mutexului
  se termina fara a il deschide, mutexul ramane inchis (locked) si orice
  incercare ulterioara de a apela 'pthread_mutex_lock()' asupra mutexului
  va bloca indefinit (deadlock).
'PTHREAD_MUTEX_ROBUST' : daca detinatorul mutexului se termina fara a il
  deschide, orice incercare ulterioara de a apela 'pthread_mutex_lock()'
  asupra mutexului va avea succes (va achizitiona mutexul si va returna
  imediat), returnand valoarea 'EOWNERDEAD', pentru a indica faptul ca
  detinatorul original nu mai exista iar mutexul este intr-o stare
  inconsistenta. De obicei, dupa returnarea lui 'EOWNERDEAD', noul
  detinator ar trebui sa apeleze 'pthread_mutex_consistent()' pe mutexul
  achizitionat pentru a-l face din nou consistent inainte de a-l
  folosi mai departe. Daca noul detinator deschide mutexul folosind
  'pthread_mutex_unlock()' inainte de a-l face consistent, mutexul va fi
  permanent inutilizabil si orice incercare ulterioara de a-l inchide
  folosind 'pthread_mutex_lock()' va esua cu eroarea 'ENOTRECOVERABLE';
  singura operatie permisa asupra unui asemenea mutex este distrugerea
  cu 'pthread_mutex_destroy()'. Daca noul detinator se termina inainte
  de a apela 'pthread_mutex_consistent()', urmatoarele operatii
  'pthread_mutex_lock()' asupra acestui mutex vor returna in continuare
  'EOWNERDEAD'.
 In caz de succes, cele doua functii returneaza 0, in caz de esec,
returneaza un cod de eroare pozitiv. In implementarea glibc, functia
'pthread_mutexattr_getrobust()'  returneaza intotdeauna 0.
 Nota: In implementarea Linux, cand se folosesc mutexuri process-shared
robuste, un thread aflat in asteptare primeste de asemenea notificarea
'EOWNERDEAD' atunci cand detinatorul unui mutex robust efectueaza 'execve()'
fara a elibera (unlock) mai intai mutexul; POSIX.1 nu specifica aceasta.

#include <pthread.h>
int pthread_mutex_consistent(pthread_mutex_t *mutex);

Compile and link with -pthread.

  ==>
 Face un mutex robust consistent, daca este intr-o stare inconsistenta.
 In caz de succes, returneaza 0, in caz de esec, returneaza un cod de eroare
pozitiv.

Observatie:
 In general, un mutex este folosit pentru a proteja niste date partajate
a.i. accesarea lor de catre threaduri sa se faca in excluziune mutuala.
Uneori, daca prelucrarea efectuata asupra datelor respective in zona
protejta este incompleta (de exemplu, pentru ca threadul a murit), datele
vor ramane corupte/inconsistente iar alte threaduri ar trebui informate
asupra acestui lucru, pentru a nu le mai accesa. Pentru aceasta se foloseste
un mutex robust: daca detinatorul mutexului moare (asadar, nu a incheiat de
prelucrat datele partajate ca sa elibereze mutexul), urmatorul thread care
va apela 'pthread_mutex_lock()' va obtine mutexul, va intra in zona
protejata, dar va fi informat prin valoarea returnata 'EOWNERDEAD' ca
precedentul thread care a fost acolo nu si-a terminat prelucrarea si ca
datele partajate ar putea fi corupte; atunci, noul detinator poate inspecta
integritatea datelor partajate si poate alege intre doua variante:
 - repara datele partajate sau considera ca nu au fost alterate, continua
  prelucrarea lor si trece mutexul in starea de consistenta apeland
  'pthread_mutex_consistent()'; din acest moment, mutexul se va comporta
  normal iar alte threaduri nu vor percepe ca a fost vreo problema cu datele
  partajate;
 - considera ca datele partajate sunt alterate iremediabil, elibereaza
  mutexul apeland 'pthread_mutex_unlock()' si il face cu aceasta ocazie
  permanent inutilizabil; din acest moment, orice alt thread va incerca
  achizitionarea mutexului cu 'pthread_mutex_lock()', nu va reusi si va fi
  informat ca nu are rost sa mai acceseze datele protejate, prin vloarea
  'ENOTRECOVERABLE'.
 Notam ca functia 'pthread_mutex_consistent()' doar informeaza implementarea
ca datele partajate protejate de mutex au fost restaurate la o stare
consistenta si ca de acum pot fi efectuate operatii normale cu mutexul.
Este responsabilitatea aplicatiei sa asigure ca datele partajate au fost
restaurate la o stare consistenta inainte de a apela functia
'pthread_mutex_consistent()'.
 Daca nu este de asteptat ca threadurile sa moara in timpul zonelor critice
protejate de mutexuri, se pot folosi mutexuri non-robuste, deoarece sunt mai
rapide.

Exemplul 13 (preluat din 'man  pthread_mutexattr_setrobust'):
===========

 Programul urmator demonstreaza utilizarea atributului de robustete. In acest
program, threadul care detine mutexul se termina prematur, fara a elibera
mutexul. Ulterior, threadul principal achizitioneaza cu succes mutexul si
obtine codul de eroare 'EOWNERDEAD, dupa care face mutexul consistent:

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
#include <errno.h>

#define handle_error_en(en, msg) \
               do { errno = en; perror(msg); exit(EXIT_FAILURE); } while(0)

static pthread_mutex_t mtx;

static void *original_owner_thread(void *ptr) {
  printf("[original owner] Setting lock...\n");
  pthread_mutex_lock(&mtx);
  printf("[original owner] Locked. Now exiting without unlocking.\n");
  pthread_exit(NULL);
}

int main(int argc, char *argv[]) {
  pthread_t thr; pthread_mutexattr_t attr; int s;
  pthread_mutexattr_init(&attr); /* initialize the attributes object */
  pthread_mutexattr_setrobust(&attr, PTHREAD_MUTEX_ROBUST);/*set robustness*/
  pthread_mutex_init(&mtx, &attr); /* initialize the mutex */
  pthread_create(&thr, NULL, original_owner_thread, NULL);
  sleep(2);
    /* "original_owner_thread" should have exited by now */
  printf("[main thread] Attempting to lock the robust mutex.\n");
  s = pthread_mutex_lock(&mtx);
  if (s == EOWNERDEAD) {
    printf("[main thread] pthread_mutex_lock() returned EOWNERDEAD\n");
    printf("[main thread] Now make the mutex consistent\n");
    s = pthread_mutex_consistent(&mtx);
    if (s != 0) handle_error_en(s, "pthread_mutex_consistent");
    printf("[main thread] Mutex is now consistent; unlocking\n");
    s = pthread_mutex_unlock(&mtx);
    if (s != 0) handle_error_en(s, "pthread_mutex_unlock");
    exit(EXIT_SUCCESS);
  } else if (s == 0) {
    printf("[main thread] pthread_mutex_lock() unexpectedly succeeded\n");
    exit(EXIT_FAILURE);
  } else {
    printf("[main thread] pthread_mutex_lock() unexpectedly failed\n");
    handle_error_en(s, "pthread_mutex_lock");
  }
}

Exemplu de testare (sursa este 'prog.c'):

$gcc -Wall -o prog prog.c -pthread
$./prog
[original owner] Setting lock...
[original owner] Locked. Now exiting without unlocking.
[main thread] Attempting to lock the robust mutex.
[main thread] pthread_mutex_lock() returned EOWNERDEAD
[main thread] Now make the mutex consistent
[main thread] Mutex is now consistent; unlocking


4.5.2. Variabile de conditie:
-----------------------------

 Daca un mutex previne accesarea in acelasi timp de catre mai multe threaduri
a unei resurse partajate (excluziune mutuala), o variabila de conditie
permite unui thread sa semnaleze altor threaduri schimbarea starii unei
resurse partajate sau sa se blocheze in asteptarea unei asemenea semnalari.

 Scenariul avut in vedere este urmatorul:
 Presupunem ca o resursa este partajata intre mai multe threaduri producator
(cara adauga unitati de valoare) si un threadu consumator (care consuma
unitati de valoare, daca sunt disponibile). Pentru a preveni conditiile de
cursa, accesul la resursa este protejat de un mutex.

 O prima varianta de implementare ar fi:

pthread_mutex_t mtx; /* mutex */
 ...

/* un producator */
  pthread_mutex_lock(&mtx);
  /* adauga la resursa unitati */
  pthread_mutex_unlock(&mtx);

/* consumatorul */
  while(1) {
    pthread_mutex_lock(&mtx);
    if(/* resursa incarcata, exista unitati */)
      /* consuma unitatile resursa */
    pthread_mutex_unlock(&mtx);
  }

Implementarea de mai sus este corecta dar ineficienta, deoarece nu la toate
iteratiile 'while' consumatorul va exploata resursa - la multe iteratii,
el doar va constata ca resursa nu si-a aschimbat starea (nu a fost
reincarcata fata de iteratia anterioara la care a fost descarcata) si
va itera mai departe; astfel, se iroseste mult timp procesor.
O variabila de conditie permite insa consumatorului sa se blocheze (wait)
daca resursa nu a fost reincarcata (in loc sa cicleze inutil) pana cand
un alt thread, anume un producator, ii va semnala (signal) ca ca poate
continua. Noua varianta de implementare va fi:

pthread_mutex_t mtx; /* mutex */
pthread_cond_t cond; /* variabila de conditie */
 ...

/* un producator */
  pthread_mutex_lock(&mtx);
  /* adauga la resursa unitati */
  pthread_mutex_unlock(&mtx);
  pthread_cond_signal(&cond);

/* consumatorul */
  while(1) {
    pthread_mutex_lock(&mtx);
    while( ! /* resursa incarcata, exista unitati */)
               pthread_cond_wait(&cond, &mtx);
    /* consuma unitatile resursa */
    pthread_mutex_unlock(&mtx);
  }

Acum, comportamentul threadurilor este urmatorul:
- Fiecare producator, dupa ce a reincarcat resursa, apeleaza
 'pthread_cond_signal(&cond)' pentru trimite (cate) o semnalizare
  variabilei de conditie 'cond'; daca nu erau threaduri in
  asteptare la 'cond', semnalizarile se pierd.
- Consumatorul, daca va constata ca resursa nu a fost reincarcata,
 apeleaza 'pthread_cond_wait(&cond, &mtx)' pentru a intra in asteptarea
 unei semnalizari la variabila 'cond', eliberand in acelasi timp mutexul
 'mtx' (ca sa permita producatorilor sa intre in zona critica si sa
 actualizaza resursa); cand 'cond' primeste o semnalizare, consumatorul
 este trezit si in acelasi timp mutexul este re-inchis (pentru a
 permite consumatorului sa exploateze resursa in excluziune mutuala);
 testarea 'if' a fost inlocuita cu o testare 'while', deoarece la
 trezire consumatorul nu are garantia ca este satisfacut si predicatul
 care conditioneaza exploatarea resursei (anume ceea ce am specificat prin
 '/* resursa incarcata, exista unitati */'); nu se va irosi timp procesor
 cu multe ciclari inutile, deoarece la fiecare ciclare cauzata de predicatul
 fals threadul va astepta o semnalizare iar daca aceasta vine, este de
 asteptat ca un alt thread sa o fi trimis dupa ce a schimbat starea resursei.
  In orice caz, se evidentiaza un tipar de efectuare a asteptarii:
 fiecare variabila de conditie are asociat un predicat care angajaza una sau
 mai multe variabile partajate iar un apel 'pthread_cond_wait()' este
 guvernat de un ciclu 'while', 'do', 'for' (si nu de o alternativa 'if').
- Deoarece instrumentele pthreads contin cod care se executa in
 spatiul utilizator (parte a threadurilor), operatiile legate
 de 'pthread_cond_wait(&cond, &mtx)' sunt efectuate in
 ordinea: deschidere 'mtx', blocare consumator,
 respectiv: deblocare consumator, inchidere 'mtx'
 (intr-adevar, codul utilizator al consumatorului, daca este blocat,
 nu poate efectua operatii legate de 'mtx'); exista, insa, riscurile:
 -- odata deblocat 'mtx', un producator poate continua si semnaliza 'cond'
   inainte ca consumatorul sa se blocheze; atunci semnalizarea se pierde
   (nu astepta nimeni la 'cond') iar cand consumatorul se va bloca, va
   astepta la infinit;
 -- odata deblocat consumatorul dar inainte de inchiderea 'mtx', el sa-si
   continue zona critica dar intre timp si un producator sa intre in zona
   critica, deoarece 'mtx' este deschis; atunci, pot aparea conditii de
   cursa;
 din aceste motive, operatiile de deschidere 'mtx' si blocare a
 consumatorului, respectiv, deblocare a consumatorului si inchidere 'mtx',
 se efectueaza atomic.
Notam urmatoarele:
- O variabila de conditie poate fi folosita doar in legatura cu un
 mutex - apelul 'pthread_cond_wait(&cond, &mtx)' creaza un binding la run
 time intre 'cond' si 'mtx'; o variabila de conditie nu poate fi asociata
 simultan cu mai multe mutexuri (altfel, comportamentul este nedefinit),
 dar un mutex poate fi asociat simultan cu mai multe variabila de conditie;
 daca mai multe threaduri asteapta la o aceeasi variabila de conditie, ea poate
 fi semnalizata in doua feluri: cu 'pthread_cond_signal()', si atunci
 semnalizarea va fi primita de cel putin unul dintre threadurile
 care asteapta (nu este specificat cate sau care), sau cu
 'pthread_cond_broadcast()', si atunci semnalizarea va fi primita de
 toate threadurile care asteapta.
- In codul producatorului, puteam inversa ultimele linii:
     pthread_cond_signal(&cond);
     pthread_mutex_unlock(&mtx);
 codul ramanea corect dar mai putin performant, deoarece cosnumatorul ar
 fi fost trezit doar ca sa se blocheze imediat la loc, incercand sa inchida
 un mutex ramas inchis (s-ar fi deblocat automat mai tarziu, cand mutexul
 a fost deschis explicit de producator).
- Un exemplu tipic de utilizare a unui mutex cu mai multe variabile de
 conditie simultan este urmatorul
(sursa: https://stackoverflow.com/questions/4062126/
can-2-pthread-condition-variables-share-the-same-mutex):

mutex queue_mutex;
cond queue_is_not_full_cond;
cond queue_is_not_empty_cond;

push()
   lock(queue_mutex)
      while(queue is full)
        wait(queue_is_not_full_cond,queue_mutex);
      do push...
      signal(queue_is_not_empty_cond)
   unlock(queue_mutex)

pop()
   lock(queue_mutex)
      while(queue is empty)
        wait(queue_is_not_empty_cond,queue_mutex);
      do pop...
      signal(queue_is_not_full_cond)
   unlock(queue_mutex)

 Variabilele de conditie sunt obiecte de tip 'pthread_cond_t'; asemanator
mutexurilor, ele sunt plasate in spatiul utilizator (si astfel pot fi operate
atat cu instrumente specifice pthreads cat si cu instructiuni obisnuite de
accesare a memoriei, ceea ce insa nu este recomandabil), trebuie initializate
inainte de folosire, cand sunt alocate static se pot initializa si cu un
macro, cand nu mai sunt necesare trebuie distruse (nu este nevoie daca sunt
alocate static), si intotdeauna trebuie sa operam cu variabilele originale,
nu cu copii ale acestora (altfel, rezultatul este nedefinit).
 Avem urmatoarele instrumente pthreads:

#include <pthread.h>
int pthread_cond_init(pthread_cond_t *restrict cond,
                      const pthread_condattr_t *restrict attr);
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
int pthread_cond_destroy(pthread_cond_t *cond);

  ==>
 Functia 'pthread_cond_init()' initializeaza variabila de
conditie pointata de 'cond' cu atributele din obiectul de tip
'pthread_condattr_t' pointat de 'attr'; daca 'attr' este NULL,
variabila de conditie este initializata cu atributele implicite;
altfel, daca obiectul de tip 'pthread_condattr_t' pointat
de 'attr' nu este initializat, comportamentul este nedefinit.
 Doar variabila de conditie insasi poate fi folosita la
sincronizare, incercarea de a folosi copii ale sale in apelurile
'pthread_cond_wait()', 'pthread_cond_timedwait()', 'pthread_cond_signal()',
'pthread_cond_broadcast()', 'pthread_cond_destroy()' are efect nedefinit.
 Incercarea de a initializa o variabila de conditie deja initializata
are efect nedefinit.
 Variabilele de conditie pot fi initializate cu atributele implicite si
folosind macro-ul 'PTHREAD_COND_INITIALIZER':
                pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
efectul este echivalent cu initializarea dinamica printr-un apel al functiei
'pthread_cond_init()' cu argumentul 'attr' NULL, cu exceptia faptului ca nu
se efectueaza verificari ale erorilor.
 Functia 'pthread_cond_destroy()' distruge variabia de conditie
pointata de 'cond'; in fapt, ea devine neinitializata; ea poate fi
reinitilizata folosind 'pthread_cond_init()'; rezultatul altor
accesari ale variabilei de conditie dupa distrugere este dendefinit.
 O variabila de conditie initializata la care nu sunt blocate
threaduri poate fi distrusa in siguranta; incercarea de a distruge o
variabila de conditie neinitializata sau la care sunt blocate
threaduri are efect nedefinit.
 In caz de succes, cele doua functii returneaza 0, in caz de esec, returneaza
un cod de eroare.

#include <pthread.h>
int pthread_cond_broadcast(pthread_cond_t *cond);
int pthread_cond_signal(pthread_cond_t *cond);

 ==>
 Cele doua functii deblocheaza threaduri blocate la variabila de conditie
pointata de 'cond'.
 Functia 'pthread_cond_broadcast()' deblocheaza toate threadurile blocate
la variabila respectiva, functia 'pthread_cond_signal()' deblocheaza cel
putin unul dinthre threadurile blocate la variabila respectiva - asa dupa cum
ne informeaza si 'man pthread_cond_broadcast', pe sistemele multi-procesor
poate fi imposibil de implementat eficient apelul 'pthread_cond_signal()'
a.i. sa nu se deblocheze mai mult de un thread; de aceea, POSIX.1‐2008
documenteaza explicit ca mai multe threaduri pot efectua return din apelul
lor 'pthread_cond_wait()' sau 'pthread_cond_timedwait()' ca urmare a unui
apel 'pthread_cond_signal()' (efect numit "spurious wakeup", trezire falsa).
 Cand sunt deblocate mai multe threaduri, politica de planificare (scheduling
policy) va determina in ce ordine se deblocheaza; fiecare thread deblocat de
un apel 'pthread_cond_broadcast()' sau 'pthread_cond_signal()' va efectua
return din apelul sau 'pthread_cond_wait()' sau 'pthread_cond_timedwait()'
si va incerca inchiderea mutexului asociat variabilei de apelul respectiv,
in mod atomic cu deblocarea - ele vor concura pentru achizitionarea mutexului
in conformitate cu politica de planificare (daca este cazul), ca si cand
fiecare ar fi apelat 'pthread_mutex_lock()', si atunci cel mult unul va
achizitiona mutexul si isi va continua executia, restul ramanand blocate
la mutex; este posibil ca toate sa ramana blocate la mutex, daca, de exemplu,
mutexul era detinut de un alt thread care nu astepta la variabila de conditie
sau semnalizata.
 Functiile 'pthread_cond_broadcast()' si 'pthread_cond_signal()' pot
fi apelate de un thread indiferent daca detine sau nu mutexul pe
care threadurile care apeleaza 'pthread_cond_wait()' sau
'pthread_cond_timedwait()' l-au asociat variabilei de conditie in
timpul asteptarii lor; cu totate acestea, daca este necesar un
comportament la planificare predictibil, atunci mutexul ar trebui sa fie
inchis de catre threadul care apeleaza 'pthread_cond_broadcast()' sau
'pthread_cond_signal()'.
 Daca nici un thread nu asteapta la variabila de conditie, functiile
'pthread_cond_broadcast()' si 'pthread_cond_signal()' nu au efect
(semnalizarea se pierde).
 Daca variabila de conditie indicata de 'cond' nu este initializata,
comportamentul functiilor 'pthread_cond_broadcast()' sau
'pthread_cond_signal()' este nedefinit.
 In caz de succes, functiile 'pthread_cond_broadcast()' si
'pthread_cond_signal()' returneaza 0, in caz de esec, returneaza un
cod de eroare (diferit, insa, de 'EINTR').
 Functia 'pthread_cond_signal()' nu poate fi folosita in siguranta (safe)
dintr-un handler de semnal care este invocat asincron; in plus, chiar daca
ar fi fost safe, inca ar exista conditii de cursa in testarea conditiei
booleene a lui 'pthread_cond_wait()' care nu au putut fi eliminate eficient.
Astfel, mutexurile si variabilele de conditie nu sunt adecvate pentru a
debloca un thread care asteapta prin semnalizarea dintr-un handler de semnal.

Observatii:
 - Deoarece la 'pthread_cond_signal()' stim ca vor fi trezite cel putin unul
 dintre threadurile aflate in asteptare dar nu stim exact cate, am putea
 folosi mereu 'pthread_cond_broadcast()', unde rezultatul este complet
 predictibil; 'pthread_cond_signal()' insa poate fi mai eficient. In general,
 'pthread_cond_signal()' este folosit atunci cand toate threadurile care
 asteapta sunt proiectate sa indeplineasca exact aceeasi sarcina si este
 suficient sa fie trezit unul, nu conteaza care, pentru ca sarcina sa fie
 indeplinita; 'pthread_cond_broadcast()' este folosit atunci cand threadurile
 care asteapta sunt proiectate sa indeplineasca sarcini diferite (in care
 caz, probabil ca ele vor avea predicate diferite asociate cu variabila de
 conditie).
- O variabila de conditie nu retine o stare proprie, ea este doar un mecanism
 de comunicare intre threaduri; daca nici un thread nu asteapta la variabila
 de conditie la momentul cand ea este semnalata, semnalizarea se pierde iar
 un thread care va astepta ulterior la variabila respectiva va fi deblocat
 doar atunci cand variabila va fi semnalizata din nou.

#include <pthread.h>
int pthread_cond_timedwait(pthread_cond_t *restrict cond,
                           pthread_mutex_t *restrict mutex,
                           const struct timespec *restrict abstime);
int pthread_cond_wait(pthread_cond_t *restrict cond,
                      pthread_mutex_t *restrict mutex);

  ==>
 Functiile 'pthread_cond_timedwait()' si 'pthread_cond_wait()' deschid
mutexul pointat de 'mutex' si apoi blocheaza threadul apelant la variabila
de conditie pointata de 'cond', in mod atomic - asadar, un alt thread nu
poate sa achizitioneze mutexul si sa semnalizeze variabila de conditie
inainte ca threadul care a apelat 'pthread_cond_timedwait()' sau
'pthread_cond_wait()' sa se blocheze la variabila respectiva; mai exact,
daca un alt thread poate achizitiona mutexul dupa threadul care trebuie
sa se blocheze l-a eliberat, atunci un apel ulterior in acel thread al
'pthread_cond_broadcast()' sau 'pthread_cond_signal()' se va comporta
ca si cand ar fi fost cerut dupa ce threadul care trebuie sa se blocheze
s-a blocat.
 Aplicatia trebuie sa sigure ca functiile 'pthread_cond_timedwait()' si
'pthread_cond_wait()' sunt apelate cu mutexul inchis (detinut) de catre
threadul apelant, altfel ele vor returna eroare (in cazul mutexurilor
'PTHREAD_MUTEX_ERRORCHECK') sau comportamentul lor va fi nedefinit.
 Dupa returul cu succes di aceste functii, mutexul este inchis si detinut
de threadul apelant.
 Cand se utilizeaza variabile de conditie, exista intotdeauna un
predicat boolean care angajaza variabile partajate, asociat cu fiecare
'pthread_cond_timedwait()' sau 'pthread_cond_wait()', care este adevarat
daca threadul ar trebui sa continue. Am vazut ca pot avea loc treziri false
(spurious wakeup) din 'pthread_cond_timedwait()' sau 'pthread_cond_wait()'.
Deoarece returul din aceste functii nu implica nimic in legatura cu valoarea
acestui predicat, el ar trebui reevaluat la un astfel de return.
 Cand un thread asteapta la o variabila de conditie avand specificat
un mutex oricaruia dintre apelurile 'pthread_cond_timedwait()' sau
'pthread_cond_wait()', este formata o asociere dinamica (dynamic binding)
intre mutex si variabila de conditie, care isi mentine efectul cat timp
macar un thread este blocat la variabila de conditie. In tot acest timp,
incercarea oricarui thread de a astepta la variabila de conditie respectiva
folosind un alt mutex are efect nedefinit - toate threadurile care asteapta
concurent la o aceeasi variabila de conditie trebuie sa specifice un acelasi
mutex. Odata ce toate threadurile care asteapta au fost deblocate (ca prin
'pthread_cond_broadcast()'), urmatoarea operatie de asteptare la acea
variabila de conditie va forma o noua asociere dinamica, cu mutexul
specificat de acea operatie de asteptare.
 Chiar daca asocierea dinamica dintre variabila de conditie si mutex
poate fi eliminata sau inlocuita intre momentul in care un thread este
deblocat dintr-o asteptare la variabila de conditie si momentul cand
'pthread_cond_timedwait()' sau 'pthread_cond_wait()' returneaza in apelant ,
sau incepe curatare la anulare (cancellation  cleanup), threadul deblocat
va putea intotdeauna sa re-achizitioneze mutexul specificat in apelul
'pthread_cond_timedwait()' sau 'pthread_cond_wait()' din care s-a
returnat.
 Un apel 'pthread_cond_timedwait()' sau 'pthread_cond_wait()' este
un punct de anulare (cancellation point) (a se vedea anularea
threadurilor, mai sus). Cand cancellation type al unui thread este setat
'PTHREAD_CANCEL_DEFERRED', un efect lateral (side-effect) al actionarii
asupra unei cereri de anulare (cancellation request) in timpul unui
'pthread_cond_timedwait()' sau 'pthread_cond_wait()' este ca mutexul
este, in fapt, re-achizitionat inaintea apelarii primului handler de
curatare la anulare (cancellation clean-up handler). Efectul este ca si
cand threadul ar fi deblocat, putand sa-si continuie executia pana la
punctul de retur din 'pthread_cond_timedwait()' sau 'pthread_cond_wait()',
dar la acel punct detecteaza cererea de anulare si, in loc ca
'pthread_cond_timedwait()' sau 'pthread_cond_wait()' sa returneze in apelant,
lanseaza activitatile de anulare a threadului, care includ si apelarea
handlerelor de curatare la anulare (cancellation cleanup handlers).
 Un  thread care a fost deblocat deoarece a fost anulat (canceled) in
timp ce era blocat intr-un apel 'pthread_cond_timedwait()' sau
'pthread_cond_wait()' nu trebuie sa consume nici o semnalizare care poate fi
concurent directionata la variabila de conditie, daca exista alte threaduri
blocate la ea.
 Functia 'pthread_cond_timedwait()' este echivalenta cu functia
'pthread_cond_wait()', cu exceptia faptului ca asteptarea are o limita
de timp - functia returneaza codul de eroare 'ETIMEDOUT' daca trece timpul
absolut (secunde si nanosecunde fata de Epoch) specificat de 'abstime'
(i.e. timpul sistem devine >= timpul specificat de 'abstime') inainte
ca variabila de conditie 'cond' sa fie semnalizata, sau daca timpul absolut
specficiat de 'abstime' deja trecuse la momentul apelului. La o asemenea
expirare a timpului, 'pthread_cond_timedwait()' va elibera si re-achizitiona
totusi mutexul indicat de 'mutex' si poate consuma o semnalizare concurent
directionata la variabila de conditie.
 Variabila de conditie are un atribut de ceas care specifica ce ceas va
fi folosit pentru a masura timpul specificat de 'abstime'; valoarea implicita
a acestui atribut specifica ceasul sistemului (system clock).
  Manualul de programare POSIX mentioneaza ca daca un semnal este livrat unui
thread care astepta la o variabila de conditie, dupa revenirea din handlerul
semnalului, threadul trebuie sa-si reia asteptarea la variabila de conditie
ca si cand nu ar fost intrerupt, sau functia de asteptare trebuie sa
returneze 0 din cauza trezirii false (spurious wakeup).
 Efectul functiilor 'pthread_cond_timedwait()' si 'pthread_cond_wait()' nu
este definit daca variabila de conditie sau mutexul specificate nu sunt
initializate.
 In caz de succes, functiile 'pthread_cond_timedwait()' si
'pthread_cond_wait()' returneaza 0, in caz de esec, returneaza un
cod de eroare. Cu exceptia cazului 'ETIMEDOUT', toate verificarile de erori
vor actiona ca si cand ele au fost efectuate imediat la inceputul procesarii
functiilor si vor provoca un retur cu eroare, in fapt, inainte de a modifica
tarea mutexului sau variabilei de conditie.

Exemplul 14:
============

 Rezolvam problema producator consumator, urmand tiparul rezolvarii din
cursul 6 SO cu monitoare in limbajul Pidgin Pascal, dar folosind
instrumente pthreads - threaduri, mutex si variabile de conditie.
De asemenea, am inlocuit ciclurile infinite 'while(1)' cu cicluri
finite 'for':

#include <pthread.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>

#define N 5
int buf[N], b = 0, v = 0;
void insert_item(int item) {
  buf[b] = item; b = (b + 1) % N;
}
int remove_item() {
  int item;
  item = buf[v]; v = (v + 1) % N;
  return item;
}

/* begin monitor */
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t full = PTHREAD_COND_INITIALIZER;
pthread_cond_t empty = PTHREAD_COND_INITIALIZER;
int count = 0;
void insert(int item) {
  pthread_mutex_lock(&lock);
  while (count == N) pthread_cond_wait(&full, &lock);
  insert_item(item);
  count = count + 1;
  if(count == 1) pthread_cond_signal(&empty);
  pthread_mutex_unlock(&lock);
}
int extract() {
  int item;
  pthread_mutex_lock(&lock);
  while(count == 0) pthread_cond_wait(&empty, &lock);
  item = remove_item();
  count = count - 1;
  if(count == N - 1) pthread_cond_signal(&full);
  pthread_mutex_unlock(&lock);
  return item;
}
/* end monitor */

int produce_item() {
  static int item = 0;
  return ++item;
}
void consume_item(int item) {
  printf("%d\n", item);
}
void *producer(void *arg) {
  int i, item;
  for(i = 0; i < 10; ++i) {item = produce_item(); insert(item);}
  return NULL;
}
void *consumer(void *arg) {
  int i, item;
  for(i = 0; i < 10; ++i) {item = extract(); consume_item(item);}
  return NULL;
}

int main() {
  pthread_t tprod, tcons;
  if(errno = pthread_create(&tprod, NULL, producer, NULL))
    {perror("pthread_create"); exit(EXIT_FAILURE);}
  if(errno = pthread_create(&tcons, NULL, consumer, NULL))
    {perror("pthread_create"); exit(EXIT_FAILURE);}
  pthread_join(tprod, NULL); pthread_join(tcons, NULL);
  return 0;
}

Exemplu de testare (sursa este 'prog.c'):

$gcc -Wall -o prog prog.c -pthread
$./prog
1
2
3
4
5
6
7
8
9
10

Comentarii:

- Fata de exemplul cu monitoare, am redenumit functia 'remove()'
 in 'extract()', pentru a nu intra in conflict cu functia predefinita
 'remove()' pentru fisiere din 'stdio.h'.
- Doar cosnumatorul apeleaza 'printf()', deci nu sunt conditii de cursa
legate de bufferele 'FILE'.

Exemplul 15 (adaptat din [2]):
===========

 O companie are un cont comun, pentru mai multi angajati, a carui balanta
este reprezentata de variabila globala 'balance'. Asupra contului se pot
face operatiuni de depunere (deposit) si retragere (withdraw), fiecare
actiune fiind modelata de un thread separat. Balanta contului nu poate
deveni negativa, asa ca un thread care vrea sa retraga bani trebuie sa
astepte ca suma dorita sa existe in cont.
 Vom avea in total 7 thread-uri:
 - threadurile 0, 2, 3, 4 vor extrage fiecare cate 7 lei;
 - threadurile 1, 5, 6 vor depune fiecare cate 11 lei.
Vom folosi un mutex ca sa sincronizam accesul la variabila 'balance' iar
threadurile care nu pot efectua retragerea vor astepta folosind o variabila
conditionala.

#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>

typedef struct {
  int id; pthread_mutex_t *lock; pthread_cond_t *cond;
} TH_STRUCT;

int balance = 0;

#define AMOUNT_WITHDRAW 7
void *thread_withdraw(void *arg) {
  TH_STRUCT *s = (TH_STRUCT*)arg;
  usleep(10000 * s->id);
  pthread_mutex_lock(s->lock);
  while(balance < AMOUNT_WITHDRAW) {
    printf("[Th%d] Not enough money (%d). Will wait...\n", s->id, balance);
    pthread_cond_wait(s->cond, s->lock);
  }
  balance -= AMOUNT_WITHDRAW;
  printf("[Th%d] Withdrawn %d. Current balance is %d.\n",
         s->id, AMOUNT_WITHDRAW, balance);
  pthread_mutex_unlock(s->lock);
  return NULL;
}

#define AMOUNT_DEPOSIT 11
void *thread_deposit(void *arg) {
  TH_STRUCT *s = (TH_STRUCT*)arg;
  usleep(10000 * s->id);
  pthread_mutex_lock(s->lock);
  balance += AMOUNT_DEPOSIT;
  printf("[Th%d] Deposited %d. Current balance is %d.\n",
         s->id, AMOUNT_DEPOSIT, balance);
  if(balance >= 2 * AMOUNT_WITHDRAW)
    pthread_cond_broadcast(s->cond);
  else if (balance >= AMOUNT_WITHDRAW)
    pthread_cond_signal(s->cond);
  pthread_mutex_unlock(s->lock);
  return NULL;
}

#define NR_THREADS 7
int main() {
  TH_STRUCT params[NR_THREADS]; pthread_t tids[NR_THREADS]; int i;
  static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
  static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
  for(i = 0; i < NR_THREADS; i++) {
    params[i].id = i; params[i].lock = &lock; params[i].cond = &cond;
    if(i == 0 || i == 2 || i == 3 || i == 4)
      errno = pthread_create(&tids[i], NULL, thread_withdraw, &params[i]);
    else
      errno = pthread_create(&tids[i], NULL, thread_deposit, &params[i]);
    if(errno) {perror("pthread_create"); exit(EXIT_FAILURE);}
  }
  for(i = 0; i < NR_THREADS; i++) pthread_join(tids[i], NULL);
  pthread_mutex_destroy(&lock);
  pthread_cond_destroy(&cond);
  return 0;
}

Exemplu de testare (sursa este 'prog.c'):

$gcc -Wall -o prog prog.c -pthread
$./prog
[Th0] Not enough money (0). Will wait...
[Th1] Deposited 11. Current balance is 11.
[Th0] Withdrawn 7. Current balance is 4.
[Th2] Not enough money (4). Will wait...
[Th3] Not enough money (4). Will wait...
[Th4] Not enough money (4). Will wait...
[Th5] Deposited 11. Current balance is 15.
[Th2] Withdrawn 7. Current balance is 8.
[Th3] Withdrawn 7. Current balance is 1.
[Th4] Not enough money (1). Will wait...
[Th6] Deposited 11. Current balance is 12.
[Th4] Withdrawn 7. Current balance is 5.

Comentarii:
- Pentru eficienta, daca la o depunere balanta curenta devine foarte mare
 ('balance >= 2 * AMOUNT_WITHDRAW'), atunci ne asteptam ca mai multe
 threaduri in asteptare pot retrage si folosim 'pthread_cond_broadcast()';
 altfel, daca totusi balanta devine doar suficient de mare a.i. sa se
 poata face macar o retragere, nu ne asteptam ca vor putea retrage foarte
 multe threaduri si atunci folosim 'pthread_cond_signal()' (pentru a trezi
 cel putin unul).
- Intrucat afisarile 'printf()' se fac in zona de excluziune mutuala, nu
 exista risc de conditii de cursa legate de bufferele 'FILE' alocate in
 memoria partajata.

Exemplul 16 (adaptat din [1]):
===========

  Am spus mai devreme ca putem folosi 'pthread_join()' doar pentru a astepta
(join) un thread terminat anume si ca nu exista un mecanism predefinit pentru
a astepta (join) un thread terminat oarecare. Urmatorul exemplu arata cum
putem folosi o variabila de conditie pentru a surmonta acest inconvenient:

#include <pthread.h>
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

static pthread_cond_t threadDied = PTHREAD_COND_INITIALIZER;
static pthread_mutex_t threadMutex = PTHREAD_MUTEX_INITIALIZER;
/* Protects all of the following global variables */

static int totThreads = 0;
static int numLive = 0;
static int numUnjoined = 0;
/* Total number of threads created */
/* Total number of threads still alive or
   terminated but not yet joined */
/* Number of terminated threads that
   have not yet been joined */

enum tstate {TS_ALIVE, TS_TERMINATED, TS_JOINED};
/* Thread states */
/* Thread is alive */
/* Thread terminated, not yet joined */
/* Thread terminated, and joined */

static struct {
  pthread_t tid;
  enum tstate state;
  int sleepTime, idx;
} *thread;
/* Info about each thread */
/* ID of this thread */
/* Thread state (TS_* constants above) */
/* Number seconds to live before terminating */
/* Thread index */

static void * threadFunc(void *arg) {
  int idx = *((int *) arg);
  sleep(thread[idx].sleepTime);
  /* Simulate doing some work */
  if(errno = pthread_mutex_lock(&threadMutex))
    {perror("pthread_mutex_lock"); exit(EXIT_FAILURE);}
  printf("Thread %d terminating\n", idx);
  numUnjoined++; thread[idx].state = TS_TERMINATED;
  if(errno = pthread_mutex_unlock(&threadMutex))
    {perror("pthread_mutex_unlock"); exit(EXIT_FAILURE);}
  if(errno = pthread_cond_signal(&threadDied))
    {perror("pthread_cond_signal"); exit(EXIT_FAILURE);}
  return NULL;
}

int main(int argc, char *argv[]) {
  int idx;
  if (argc < 2 || strcmp(argv[1], "--help") == 0) {
    fprintf(stderr, "Usage: %s nsecs...\n", argv[0]); exit(EXIT_FAILURE);
  }
  if((thread = calloc(argc - 1, sizeof(*thread))) == NULL)
    {perror("calloc"); exit(EXIT_FAILURE);}

  /* Create all threads */
  for (idx = 0; idx < argc - 1; idx++) {
    thread[idx].idx = idx;
    thread[idx].sleepTime = atoi(argv[idx + 1]);
    thread[idx].state = TS_ALIVE;
    if(errno = pthread_create(&thread[idx].tid, NULL, threadFunc, &thread[idx].idx))
      {perror("pthread_create"); exit(EXIT_FAILURE);}
  }
  totThreads = argc - 1; numLive = totThreads;

  /* Join with terminated threads */
  while (numLive > 0) {
    if(errno = pthread_mutex_lock(&threadMutex))
      {perror("pthread_mutex_lock"); exit(EXIT_FAILURE);}
    while (numUnjoined == 0) {
      if(errno = pthread_cond_wait(&threadDied, &threadMutex))
        {perror("pthread_cond_wait"); exit(EXIT_FAILURE);}
    }
    for (idx = 0; idx < totThreads; idx++) {
      if (thread[idx].state == TS_TERMINATED){
         if(errno = pthread_join(thread[idx].tid, NULL))
           {perror("pthread_join"); exit(EXIT_FAILURE);}
         thread[idx].state = TS_JOINED;
         numLive--; numUnjoined--;
         printf("Reaped thread %d (numLive=%d)\n", idx, numLive);
      }
    }
    if(errno = pthread_mutex_unlock(&threadMutex))
      {perror("pthread_mutex_unlock"); exit(EXIT_FAILURE);}
  }
  exit(EXIT_SUCCESS);
}

Comentarii:
- Programul de mai sus creaza cate un thread pentru fiecare argument din
 linia de comanda; argumentul specifica un numar de secunde iar threadul
 doarme numarul respectiv de secunde si se termina - astfel, este simulata
 ideea ca threadul efectueaza o activitate pentru o perioada de timp.
- Programul mentine un set de variabile globale care retin informatii despre
 toate thredurile create. Pentru fiecare thread, un element din array-ul
 global alocat dinamic 'thread' retine ID-ul threadului (campul 'tid') si
 starea sa curenta (campul 'state'); starea poate fi: 'TS_ALIVE' (threadul
 nu e terminat), 'TS_TERMINATED' (threadul este terminat dar inca nu este
 interceptat prin asteptare (joined)) sau 'TS_JOINED' (threadul este terminat
 si a fost interceptat prin asteptare (joined)). De asemenea, exista
 contoarele globale 'totThreads' (numarul total de threaduri), 'numLive'
 (numarul de threaduri ne-terminate sau terminate dar ne interceptate
 prin asteptare (join)) si 'numUnjoined' (numarul de threaduri terminate
 dar inca ne interceptate prin asteptare (join)).
- De fiecare data can un thread se termina, el asigneaza 'TS_TERMINATED'
 campului 'state' din elementul sau din array-ul 'thread', incrementeaza
 'numUnjoined' si semnaleaza variabial de conditie 'threadDied'; threadul
 principal efectueaza o bucla infinita 'while' care asteapta la variabila de
 conditie 'threadDied' iar cand este semnalizata parcurge array-ul 'thread'
 si de fiecare data cand gaseste un thread 'TS_TERMINATED' (terminat dar
 inca ne interceptat prin asteptare (joined)), il intercepteaza cu
 'pthread_join()' (aplicat campului 'tid' din elementul sau din array-ul
 'thread') si ii schimba starea in 'TS_JOINED'.
  Ciclul 'while' din threadul principal se termina cand toate threadurile
 create au fost terminate si interceptate prin asteptare, i.e. 'numLive'
 devine 0.
- Afisarile cu 'printf()' au fost efectuate in excluziunea mutuala
 implementata cu ajutorul mutexului 'threadMutex', astfel incat au fost
 evitate conditiile de cursa legate de bufferele 'FILE' care sunt alocate
 in zona partajata intre threaduri; de asemenea, am furnizat ca parametru
 functiilor apelate de threaduri indicele 'idx' in cate o locatie de
 memorie proprie, aflata in elementul corespunzator din array-ul 'thread',
 tot pentru a evita conditii de cursa, legate de accesarea unei aceeasi
 locatii ('idx' de pe stiva lui 'main()') atat de catre threaduri cat si
 de catre ciclurile 'for' din 'main()'.
- Notam ca, desi threadurile sunt create asteptabile (joinable) si sunt
 eliminate imediat ce se termina folosind 'pthread_join()', nu avem nevoie
 de aceasta abordare pentru a afla despre terminarea threadurilor - puteam
 marca threadurile a detasate (detached), nu mai foloseam 'pthread_join()',
 si doar tineam evidenta terminarii threadurilor folosind array-ul 'thread'
 si variabilelor globale asociate; threadul principal le-ar fi accesat insa
 doar la trezirile din asteptare in urma semnalizarii variabilei de conditie.

Exemplu de testare (sursa este 'prog.c'):

$gcc -Wall -o prog prog.c -pthread
$./prog 1 1 2 3 3
Thread 1 terminating
Thread 0 terminating
Reaped thread 0 (numLive=4)
Reaped thread 1 (numLive=3)
Thread 2 terminating
Reaped thread 2 (numLive=2)
Thread 4 terminating
Thread 3 terminating
Reaped thread 3 (numLive=1)
Reaped thread 4 (numLive=0)
$

 Prezentam cateva dintre functiile cu care se poate opera asupra unui obiect
de tip 'pthread_condattr_t':

#include <pthread.h>
int pthread_condattr_init(pthread_condattr_t *attr);
int pthread_condattr_destroy(pthread_condattr_t *attr);

  ==>
 Functia 'pthread_condattr_init()' initializeaza obiectul cu atribute de
variabile de conditie pointat de 'attr' cu valorile implicite ale
atributelor; incercarea de a initializa un obiect deja initializat are
efect nedefinit.
 Dupa ce obiectul cu atribute de variabile de conditie a fost folosit
pentru a initializa una sau mai multe variabile de conditie, orice functie
care afecteaza obiectul (inclusiv cea de distrugere) nu va afecta
variabilele de conditie initializate anterior.
 POSIX.1‐2008 cere sa fie implementate cel putin doua atribute, atributul
de ceas (clock attribute) si atributul de partajare intre procese
(process-shared attribute).
 Functia 'pthread_condattr_destroy()' distruge obiectul cu atribute de
variabile de conditie pointat de 'attr'; in fapt, obiectul devine
neinitializat; el poate fi reinitializat folosind 'pthread_condattr_init()';
rezultatul altor accesari ale obiectului dupa distrugere este nedefinit;
incercarea de a distruge un obiect neinitializat are efect nedefinit.
 In caz de succes, cele doua functii returneaza 0, in caz de esec, returneaza
un cod de eroare.

#include <pthread.h>
int pthread_condattr_getpshared(const pthread_condattr_t *restrict attr,
                                int *restrict pshared);
int pthread_condattr_setpshared(pthread_condattr_t *attr,
                                int pshared);

  ==>
 Consulta, respectiv seteaza, atributul atributul de partajare intre procese
(process-shared attribute) din obiectul cu atribute de variabile de conditie
pointat de 'attr'; obiectul pointat de 'attr' trebuie sa fie initializat,
altfel comportamentul este nedefinit; valorile posibile ale atributului si
semnificatiile lor sunt:
'PTHREAD_PROCESS_SHARED' :  asupra variabilei de conditie pot opera toate
  threadurile care au acces la memoria unde este alocata variabila, chiar
  daca threadurile respective sunt in procese diferite;
'PTHREAD_PROCESS_PRIVATE' : asupra variabilei de conditie pot opera doar
  thredurile create in acelasi proces cu threadul care a initializat
  variabila; daca threaduri din alte procese incearca sa opereze asupra
  variabilei, efectul este nedefinit.
Valoarea implicita a atributului de partajare intre procese este
'PTHREAD_PROCESS_PRIVATE'.
 In caz de succes, cele doua functii returneaza 0, in caz de esec, returneaza
un cod de eroare.
 Pentru alte comentarii despre partajarea intre procese/threaduri, a se
(re)vedea 'pthread_mutexattr_getpshared()' / 'pthread_mutexattr_setpshared()'
mai sus.

Exemplul 17:
============

Aratam ca instrumentele de sincronizare pthreads (mutexuri, variabile de
conditie) pot fi folosite si pentru sincronizarea altor taskuri decat cele
create prin instrumente pthreads, de exemplu procese obisnuite - in acest
caz insa, mutexurile si variabilele de conditie trebuie create cu atributul
'PTHREAD_PROCESS_SHARED'. Exemplul de mai jos il reia pe cel precedent
(care genera threaduri care faceau asteptari limitate si astepta terminarea
lor), dar lucreaza cu procese create cu 'fork()', nu cu threaduri create cu
'pthreads_create()':

#include <pthread.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

enum tstate {TS_ALIVE, TS_TERMINATED, TS_JOINED};

struct thread_type {pid_t pid; enum tstate state; int sleepTime;} *thread;
void *adr;
int *totThreads, *numLive, *numUnjoined;
pthread_mutex_t *threadMutex; pthread_cond_t *threadDied;

int main(int argc, char *argv[]) {
  pthread_mutexattr_t mattr; pthread_condattr_t cattr;
  int idx, length;

  if (argc < 2 || strcmp(argv[1], "--help") == 0) {
    fprintf(stderr, "Usage: %s nsecs...\n", argv[0]); exit(EXIT_FAILURE);
  }


  length = (argc - 1) * sizeof(struct thread_type)
         + 3 * sizeof(int)
         + sizeof(pthread_mutex_t) + sizeof(pthread_cond_t);
  adr = mmap(NULL,length,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,-1,0);

  totThreads = (int *)adr; *totThreads = argc - 1;
  numLive = totThreads + 1; *numLive = *totThreads;
  numUnjoined = numLive + 1; *numUnjoined = 0;
  threadMutex = (pthread_mutex_t *)(numUnjoined + 1);
  threadDied = (pthread_cond_t *)(threadMutex + 1);
  thread = (struct thread_type *)(threadDied + 1);

  pthread_mutexattr_init(&mattr);
  pthread_mutexattr_setpshared(&mattr, PTHREAD_PROCESS_SHARED);
  pthread_mutex_init(threadMutex, &mattr);
  pthread_mutexattr_destroy(&mattr);

  pthread_condattr_init(&cattr);
  pthread_condattr_setpshared(&cattr, PTHREAD_PROCESS_SHARED);
  pthread_cond_init(threadDied, &cattr);
  pthread_condattr_destroy(&cattr);

  for (idx = 0; idx < argc - 1; idx++) {
    thread[idx].sleepTime = atoi(argv[idx + 1]);
    thread[idx].state = TS_ALIVE;
    thread[idx].pid = fork();
    if(thread[idx].pid) continue;
    sleep(thread[idx].sleepTime);
    pthread_mutex_lock(threadMutex);
    printf("Thread %d terminating\n", idx);
    (*numUnjoined)++; thread[idx].state = TS_TERMINATED;
    pthread_mutex_unlock(threadMutex);
    pthread_cond_signal(threadDied);
    return EXIT_SUCCESS;
  }

  while (*numLive > 0) {
    pthread_mutex_lock(threadMutex);
    while (*numUnjoined == 0)
      pthread_cond_wait(threadDied, threadMutex);
    for (idx = 0; idx < *totThreads; idx++) {
      if (thread[idx].state == TS_TERMINATED){
         waitpid(thread[idx].pid, NULL, 0);
         thread[idx].state = TS_JOINED;
         (*numLive)--; (*numUnjoined)--;
         printf("Reaped thread %d (numLive=%d)\n", idx, *numLive);
      }
    }
    pthread_mutex_unlock(threadMutex);
  }

  pthread_mutex_destroy(threadMutex);
  pthread_cond_destroy(threadDied);
  munmap(adr, length);

  return EXIT_SUCCESS;
}

Exemplu de testare (sursa este 'prog.c'):

$gcc -Wall -o prog prog.c -pthread
$./prog 1 1 2 3 3
Thread 0 terminating
Reaped thread 0 (numLive=4)
Thread 1 terminating
Reaped thread 1 (numLive=3)
Thread 2 terminating
Reaped thread 2 (numLive=2)
Thread 4 terminating
Thread 3 terminating
Reaped thread 3 (numLive=1)
Reaped thread 4 (numLive=0)

Comentarii:
- Nu este necesara abordarea din acest exemplu, deoarece pentru
 procese avem instrumente de asteptat un copil oarecare: 'wait()',
 'waitpid(-1, ...)', etc..
- Pentru simplitatea codului, nu am mai testat succesul apelurilor.
- Am inlocuit 'tid' (de tip 'pthread_t') cu 'pid' (de tip 'pid_t') si nu a
 mai fost nevoie sa retinem pentru fiecare thread o copie separata a lui
 'idx', deoarece la multiplicarea proceselor cu 'fork()' se multiplica
 insusi 'idx' din 'main()'.
- Datele care trebuie partajate intre procese au fost alocate intr-o
 zona de memorie partajata, alocata cu 'mmap()'; notam ca si mutexul si
 variabila de conditie trebuie alocate acolo (nu doar initializate cu
 'PTHREAD_PROCESS_SHARED'), deoarece, altfel, procesele ar ajunge sa
 opereze pe copii diferite ale acestora, nu pe original, iar comportamentul
 ar fi (dupa cum am mai spus) nedefinit.
- In loc de 'pthread_join()', am folosit 'waitpid()'.


4.6. Gestiunea semnalelor in threaduri:
---------------------------------------

 Biblioteca pthreads ofera si instrumente pentru a gestiona semnale, unele
dintre ele fiind similare instrumentelor generale pentru procese:

#include <signal.h>
int pthread_kill(pthread_t thread, int sig);

Compile and link with -pthread.

  ==>
 Trimite semnalul 'sig' threadului 'thread', aflat in acelasi proces ca
apelantul. Semnalul este directionat asincron catre thread. Daca 'sig' este
0, nu este trimis nici unsemnal, dar este efectuata verificarea la erori.
 Note:
 Tratarea semnalelor prin executarea de handlere (signal dispositions) este
la nivel de proces (process-wide): daca este instalat un handler de semnal,
handlerul va fi invocat in threadul 'thread', dar daca efectul tratarii
semnalului (disposition of the signal) este "stop", "continue", sau
"terminate",  aceasta actiune va afecta intregul proces.
 Implementarea glibc a lui 'pthread_kill()' produce eroarea 'EINVAL' daca
se incearca transmiterea vreunuia dintre semnalele real-time folosite intern
de catre implementarea NPTL a threadurilor.
 In caz de succes, functia returneaza 0, in caz de esec, returneaza un cod
de eroare si nu se trimite nici un semnal. Un caz de eroare poate fi si
folosirea unui thread ID invalid sau dupa sfarsitul duratei sale de viata
(lifetime).


#include <signal.h>
int pthread_sigmask(int how, const sigset_t *set, sigset_t *oldset);

Compile and link with -pthread.

  ==>
 Functia este folosita pentru blocarea semnalelor in threadul apelant si
este similara lui 'sigprocmask()', folosita in general in lucrul cu procese,
cu diferenta ca folosirea sa in programele multithread este explicit
spacificata de POSIX.1. iar in caz de succes returneaza 0 si in caz de esec
returneaza un cod de eroare nenul.
 Note:
 Un nou thread mosteneste o copie a mastii de semnale a creatorului sau.
 Implementarea glibc a functieil 'pthread_sigmask()' ignora tacit incercarea
de a bloca semnalele real-time folosite intern de catre implementarea NPTL a
threadurilor.

#include <signal.h>
int sigwait(const sigset_t *set, int *sig);

  ==>
 Suspenda executarea threadului apelant pana cand in unul dintre semnalele
din multimea pointata de 'set' a venit si asteapta sa fie tratat (i.e. devine
pending). Functia accepta semnalul, i.e. il elimina din lista de semnale
aflate in pending, si furnizeaza numarul semnalului in locatia pointata de
'sig'. In caz de succes, functia returneaza 0, in caz de esec, returneaza
un cod de eroare pozitiv.
 Note:
 Functia 'sigwait()' este implementata folisind 'sigtimedwait()'.
 Implementarea glibc a functiei 'sigwait()' ignora tacit incercarile de a
astepta semnalele real-time folosite intern de catre implementarea NPTL a
threadurilor.

Observatii:
 - Pe langa functiile de mai sus, se pot folosi in legatura cu semnalele
  si alte functii generale, utilizabile la lucrul cu procese: 'kill()',
  'raise()', 'sigaction()', 'sigpending()', etc.
 - Reamintim anumite aspecte despre care am discutat si la inceputul
  capitolului:
   Handlerele de semnal sunt valabile pentru toate threadurile unui proces,
  dar masca de semnale blocate si stiva alternativa folosita la executarea
  handlerelor (alternate signal stack) (in cazul cand la instalarea
  handlerului cu ' sigaction()' am specificat folosirea unei stive
  alternative) sunt specifice per-thread.
   Un semnal poate fi directionat (si deci plasat in pending) catre un
  proces (process-directed) sau catre un thread (thread-directed) iar
  un apel 'sigpending()' furnizeaza o multime de semnale care este
  totalitatea semnalelor process-directed aflate in pending si a semnalelor
  thread-directed aflate in pending pentru taskul apelant; un semnal
  process-directed este livrat (delivered, se apeleaza handlerul) unui
  thread al procesului selectat arbitrar dintre cele care nu blocheaza
  semnalul.

Exemplul 18 (adaptat din 'man pthread_sigmask'):
===========

 Urmatorul program blocheaza cateva semnale in threadul principal, apoi
creaza un thread dedicat pentru a prelua acele semnale via 'sigwait()':

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <errno.h>

/* Simple error handling functions */

#define handle_error_en(en, msg) \
do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)

static void * sig_thread(void *arg) {
  sigset_t *set = arg; int s, sig;
  for (;;) {
    s = sigwait(set, &sig);
    if (s != 0) handle_error_en(s, "sigwait");
    printf("Signal handling thread got signal %d\n", sig);
  }
}

int main(int argc, char *argv[]) {
  pthread_t thread; sigset_t set; int s;

  /* Block SIGQUIT and SIGUSR1; other threads created by main()
              will inherit a copy of the signal mask. */

  sigemptyset(&set); sigaddset(&set, SIGQUIT); sigaddset(&set, SIGUSR1);
  s = pthread_sigmask(SIG_BLOCK, &set, NULL);
  if (s != 0) handle_error_en(s, "pthread_sigmask");

  s = pthread_create(&thread, NULL, &sig_thread, (void *) &set);
  if (s != 0) handle_error_en(s, "pthread_create");

  /* Main thread carries on to create other threads and/or do
              other work */

  pause();  /* Dummy pause so we can test program */
}

Exemplu de testare (executabilul este 'a.out'):

$./a.out &
[1] 6053
$kill -QUIT %1 ; sleep 1
Signal handling thread got signal 3
$kill -USR1 %1 ; sleep 1
Signal handling thread got signal 10
$kill -TERM %1 ; sleep 1
[1]+  Terminated              ./a.out

Comentarii:
- programul a fost lansat in background (cu '&') pentru ca shell-ul sa
 ramana activ in foreground si sa poata primi comenzi 'kill'; am presupus,
 insa, ca terminalul a fost setat '-tostop', pentru a permite proceselor
 din background sa scrie pe terminal;
- in urma lansarii programului, shell-ul a asociat procesului copil aflat
 in executie un numar de job, care are sens doar la nivelul procesului shell
 si care a for afisat (anume '[1]') iar ulterior putem referi in comenzi
 shell procesul respectiv prin numarul sau de job precedat de '%' (anume
 '%1'), nu numai prin PID-ul sau (anume '6053'); la terminarea copilului,
 numarul de job poate fi refolosit;
 - procesul lansat are doua threaduri, dintre care doar cel care executa
 'sig_thread()' e activ; threadul principal doarme in 'pause(0)' si nu va fi
 trezit decat daca primeste un semnal thread-directed; semnalele
 process-directed vor fi tratate in singurul thread actv la momentul
 primirii, 'sig_thread()'; comenzile shell 'kill' (care efectueaza apelul
 'kill()') trimit semnale procesului, deci vor fi tratate in threadul
 'sig_thread()';
- la rulare, s-au transmis semnalele SIGQUIT, SIGUSR1, SIGTERM; toate au ca
 handler implicit terminarea programului, li se pot asocia handlere
 utilizator, dar in programul nostru nu am facut asa ceva (a ramas handlerul
 implicit); semnalelor SIGQUIT si SIGUSR1 au fost preluate de 'sigwait()' si
 astfel nu li s-a apelat handlerul (nu s-a terminat programul); semnalul
 SIGTERM a fost primit de proces, livrat in threadul ''sig_thread()', nu a
 fost preluat de 'sigwait()', i s-a apelat handlerul (cel implicit), care a
 terminat tot procesul (toate threadurile sale);
- intrucat doar un thread al procesului lansat a fost activ, nu a existat
 riscul aparitiei conditiilor de cursa legate de bufferele 'FILE' si deci
 am putut folosi in siguranta 'printf()';
- liniile de comanda shell folosite pentru a trimite semnale au fost, de
 fapt, inlantuiri de 2 comenzi ('kill -semnal job' si 'sleep secunde')
 care s-au executat pe rand (operatorul lnie de comanda ';') si abia la
 sfarsit s-a afisat prompterul; motivul adaugarii lui 'sleep 1' (care
 pune shell-ul in steptare pentru 1 secunda) a fost ca sa aiba timp
 threadul 'sig_thread()' sa afiseze mesajul 'Signal handling ...'
 inainte de aparitia prompterului (deci, pentru un ouptput inteligibil).


4.7. Teme:
----------

1. Implementati si alte probleme clasice de sincronizare (problema
 filozofilor care mananca, problema cititorilor si scriitorilor,
 problema frizerului somnoros, etc.) folosind threaduri si instrumente
 pthreads.


Daniel Dragulici
14 ianuarie 2024
